

** Viewport.axaml.cs **
Path: D:\OpenDraft\OpenDraft\ODCore\Viewport.axaml.cs

using Avalonia;
using Avalonia.Controls;
using Avalonia.Input;
using Avalonia.Media;
using Avalonia.Threading;
using OpenDraft.ODCore.ODData;
using OpenDraft.ODCore.ODEditor;
using OpenDraft.ODCore.ODEditor.ODDynamics;
using OpenDraft.ODCore.ODGeometry;
using OpenDraft.ODCore.ODMath;
using System;
using System.Collections.ObjectModel;
using System.Diagnostics;
namespace OpenDraft
{
    public partial class Viewport : UserControl
    {
        public static readonly StyledProperty<ObservableCollection<ODElement>> ElementsProperty =
            AvaloniaProperty.Register<Viewport, ObservableCollection<ODElement>>(nameof(Elements));
        public static readonly StyledProperty<ODDrawConnector> DrawConnectorProperty =
            AvaloniaProperty.Register<Viewport, ODDrawConnector>(nameof(DrawConnector));
        public static readonly StyledProperty<IODEditorInputService> InputServiceProperty =
            AvaloniaProperty.Register<Viewport, IODEditorInputService>(nameof(InputService));
        public static readonly StyledProperty<ObservableCollection<ODDynamicElement>> DynamicElementsProperty =
            AvaloniaProperty.Register<Viewport, ObservableCollection<ODDynamicElement>>(nameof(DynamicElements));
        public ObservableCollection<ODElement> Elements
        {
            get => GetValue(ElementsProperty);
            set => SetValue(ElementsProperty, value);
        }
        public ODDrawConnector DrawConnector
        {
            get => GetValue(DrawConnectorProperty);
            set => SetValue(DrawConnectorProperty, value);
        }
        public IODEditorInputService InputService
        {
            get => GetValue(InputServiceProperty);
            set => SetValue(InputServiceProperty, value);
        }
        public ObservableCollection<ODDynamicElement> DynamicElements
        {
            get => GetValue(DynamicElementsProperty);
            set => SetValue(DynamicElementsProperty, value);
        }
        private readonly ViewportCamera Camera = new();
        private bool isPanning = false;
        private Point _lastPointerDragPosition;
        private Point _mousePosition;
        private Size _lastSize;
        private bool _isInitialized = false;
        public Viewport()
        {
            InitializeComponent();
            Background = Brushes.Transparent;
            Elements ??= new ObservableCollection<ODElement>();
            DynamicElements ??= new ObservableCollection<ODDynamicElement>();
            SubscribeToCollection(Elements, OnElementsChanged);
            SubscribeToCollection(DynamicElements, OnDynamicElementsChanged);
            PointerPressed += OnPointerPressed;
            PointerReleased += OnPointerReleased;
            PointerMoved += OnPointerMoved;
            PointerWheelChanged += OnPointerWheelChanged;
            PointerEntered += OnPointerEntered;
            PointerExited += OnPointerExited;
            SetupStaticCanvas();
            SetupDynamicCanvas();
        }
        private void SubscribeToCollection<T>(ObservableCollection<T> collection, System.Collections.Specialized.NotifyCollectionChangedEventHandler handler)
        {
            if (collection == null) return;
            collection.CollectionChanged -= handler;
            collection.CollectionChanged += handler;
        }
        private void OnElementsChanged(object? sender, System.Collections.Specialized.NotifyCollectionChangedEventArgs e)
        {
            StaticCanvas?.InvalidateVisual();
        }
        private void OnDynamicElementsChanged(object? sender, System.Collections.Specialized.NotifyCollectionChangedEventArgs e)
        {
            DynamicCanvas?.InvalidateVisual();
        }
        private void SetupStaticCanvas()
        {
            StaticCanvas.OnRender = (context, bounds) =>
            {
                if (Elements == null) return;
                var matrix = Camera.GetMatrix(bounds.Height);
                using (context.PushTransform(matrix))
                {
                    foreach (var element in Elements)
                    {
                        var layer = DrawConnector.GetLayerByID(element.LayerId);
                        if (layer != null)
                            element.Draw(context, DrawConnector);
                    }
                }
            };
            StaticCanvas.InvalidateVisual();
        }
        private void SetupDynamicCanvas()
        {
            DynamicCanvas.OnRender = (context, bounds) =>
            {
                if (DynamicElements == null) return;
                ODVec2 vpWorldSize = new ODVec2(bounds.Width / Camera.Scale, bounds.Height / Camera.Scale);
                ODVec2 worldMousePoint = new ODVec2(GetWorldMousePosition().X, GetWorldMousePosition().Y);
                var matrix = Camera.GetMatrix(bounds.Height);
                using (context.PushTransform(matrix))
                {
                    if (DynamicElements != null)
                        foreach (ODDynamicElement element in DynamicElements)
                        {
                            ODLayer? layer = DrawConnector.GetLayerByID(element.LayerId);
                            if (layer != null) element.Draw(context, DrawConnector, Camera.Scale, vpWorldSize, worldMousePoint);
                        }
                }
            };
            var timer = new DispatcherTimer { Interval = TimeSpan.FromMilliseconds(16) };
            timer.Tick += (_, _) => DynamicCanvas?.InvalidateVisual();
            timer.Start();
        }
        protected override Size ArrangeOverride(Size finalSize)
        {
            if (!_isInitialized)
            {
                _isInitialized = true;
                Camera.Position = new Point(-finalSize.Width / 2 / Camera.Scale, -finalSize.Height / 2 / Camera.Scale);
            }
            else
            {
                Camera.Position -= new Vector(
                    (finalSize.Width - _lastSize.Width) / 2 / Camera.Scale,
                    (finalSize.Height - _lastSize.Height) / 2 / Camera.Scale);
            }
            _lastSize = finalSize;
            StaticCanvas?.InvalidateVisual();
            return base.ArrangeOverride(finalSize);
        }
        protected override void OnPropertyChanged(AvaloniaPropertyChangedEventArgs change)
        {
            base.OnPropertyChanged(change);
            if (!_isInitialized) return;
            if (change.Property == ElementsProperty)
                SubscribeToCollection(Elements, OnElementsChanged);
            else if (change.Property == DynamicElementsProperty)
                SubscribeToCollection(DynamicElements, OnDynamicElementsChanged);
            StaticCanvas?.InvalidateVisual();
            DynamicCanvas?.InvalidateVisual();
        }
        private void OnPointerPressed(object? sender, PointerPressedEventArgs e)
        {
            if (e.GetCurrentPoint(this).Properties.IsMiddleButtonPressed)
            {
                _lastPointerDragPosition = e.GetPosition(this);
                isPanning = true;
            }
        }
        private void OnPointerReleased(object? sender, PointerReleasedEventArgs e)
        {
            if (e.InitialPressMouseButton == MouseButton.Left)
            {
                var ODVec2 = new ODVec2(GetWorldMousePosition().X, GetWorldMousePosition().Y);
                InputService?.RaisePointProvided(ODVec2);
                e.Handled = true;
            }
            if (e.InitialPressMouseButton == MouseButton.Middle)
                isPanning = false;
        }
        private void OnPointerMoved(object? sender, PointerEventArgs e)
        {
            _mousePosition = e.GetPosition(this);
            DynamicCanvas?.InvalidateVisual();
            if (!isPanning) return;
            var current = e.GetPosition(this);
            Camera.MoveBy(new Vector(-(current.X - _lastPointerDragPosition.X) / Camera.Scale,
                                     (current.Y - _lastPointerDragPosition.Y) / Camera.Scale));
            _lastPointerDragPosition = current;
            StaticCanvas?.InvalidateVisual();
        }
        private void OnPointerEntered(object? sender, PointerEventArgs e)
        {
            InputService?.RaiseViewportEntered();
        }
        private void OnPointerExited(object? sender, PointerEventArgs e)
        {
            InputService?.RaiseViewportExited();
        }
        private void OnPointerWheelChanged(object? sender, PointerWheelEventArgs e)
        {
            var mousePos = e.GetPosition(this);
            double zoomFactor = 1.1f;
            double oldScale = Camera.Scale;
            double newScale = oldScale * Math.Pow(zoomFactor, e.Delta.Y > 0 ? 1 : -1);
            Point ScreenToWorld(Point screen, double scale) =>
                new(screen.X / scale - Camera.Position.X, (Bounds.Height - screen.Y) / scale - Camera.Position.Y);
            var oldWorld = ScreenToWorld(mousePos, oldScale);
            var newWorld = ScreenToWorld(mousePos, newScale);
            Camera.Position += oldWorld - newWorld; // <--- fix here
            Camera.Scale = newScale;
            StaticCanvas?.InvalidateVisual();
            DynamicCanvas?.InvalidateVisual();
        }
        public Point GetScreenMousePosition() => _mousePosition;
        public ODVec2 GetWorldMousePosition()
        {
            double x = (_mousePosition.X / Camera.Scale + Camera.Position.X);
            double y = ((Bounds.Height - _mousePosition.Y) / Camera.Scale) + Camera.Position.Y;
            return new ODVec2(x,y);
        }
    }
}


** IODEditorInputService.cs **
Path: D:\OpenDraft\OpenDraft\ODCore\ODEditor\IODEditorInputService.cs

ï»¿// IEditorInputService.cs
using Avalonia.Input;
using OpenDraft.ODCore.ODGeometry;
using OpenDraft.ODCore.ODMath;
using System;
namespace OpenDraft.ODCore.ODEditor
{
    public interface IODEditorInputService
    {
        // Events for different input types
        event Action<Key> KeyPressed;
        event Action<ODVec2> PointProvided;
        event Action<string> TextInput;
        event Action<double> NumberInput;
        event Action CancelRequested;
        event Action ViewportEntered;
        event Action ViewportExited;
        // ADD THESE METHODS to the interface
        void RaiseKeyPressed(Key key);
        void RaisePointProvided(ODVec2 point);
        void RaiseTextInput(string text);
        void RaiseNumberInput(double number);
        void RaiseCancelRequested();
        void RaiseViewportEntered();
        void RaiseViewportExited();
        // Methods to request specific input modes
        void RequestPointInput();
        void RequestTextInput();
        void CancelInputRequest();
    }
}

** ODEditorContext.cs **
Path: D:\OpenDraft\OpenDraft\ODCore\ODEditor\ODEditorContext.cs

ï»¿using OpenDraft.ODCore.ODData;
using OpenDraft.ODCore.ODEditor.ODCommands;
using OpenDraft.ODCore.ODEditor.ODDynamics;
using OpenDraft.ODCore.ODGeometry;
using OpenDraft.ODCore.ODMath;
using System;
using System.Numerics;
using System.Threading;
using System.Threading.Tasks;
namespace OpenDraft.ODCore.ODEditor
{
    public class ODEditorContext : IODEditorGateway
    {
        private readonly ODEditor _editor;
        private readonly ODDataManager _dataManager;
        private readonly IODEditorInputService _inputService;
        private readonly CancellationTokenSource _cancellationTokenSource;
        private TaskCompletionSource<ODVec2>? _pointWaiter;
        private TaskCompletionSource<double>? _numberWaiter;
        private TaskCompletionSource<string>? _textWaiter;
        private TaskCompletionSource<string>? _choiceWaiter;
        public ODDataManager DataManager => _dataManager;
        public CancellationToken CancellationToken => _cancellationTokenSource.Token;
        public ODEditorContext(ODEditor editor, ODDataManager dataManager, IODEditorInputService inputService)
        {
            _editor = editor;
            _dataManager = dataManager;
            _inputService = inputService;
            _cancellationTokenSource = new CancellationTokenSource();
            // Subscribe to input service events
            _inputService.PointProvided += OnPointProvided;
            _inputService.NumberInput += OnNumberProvided;
            _inputService.TextInput += OnTextProvided;
        }
        public void AddDynamicElement(ODDynamicElement element)
        {
            _editor.AddDynamicElement(element);
        }
        public void RemoveDynamicElement(ODDynamicElement element)
        {
            _editor.RemoveDynamicElement(element);
        }
        public void ClearDynamicElements()
        {
            _editor.ClearDynamicElements();
        }
        private void OnPointProvided(ODVec2 point)
        {
            ProvidePoint(point);
        }
        private void OnNumberProvided(double number)
        {
            ProvideNumber(number);
        }
        private void OnTextProvided(string text)
        {
            ProvideText(text);
        }
        public Task<ODVec2> GetPointAsync(string prompt)
        {
            _editor.SetStatus(prompt); // FIXED: Now calls editor method
            ClearAllWaiters();
            _pointWaiter = new TaskCompletionSource<ODVec2>();
            return _pointWaiter.Task;
        }
        public Task<double> GetNumberAsync(string prompt)
        {
            _editor.SetStatus(prompt); // FIXED
            ClearAllWaiters();
            _numberWaiter = new TaskCompletionSource<double>();
            return _numberWaiter.Task;
        }
        public Task<string> GetTextAsync(string prompt)
        {
            _editor.SetStatus(prompt); // FIXED
            ClearAllWaiters();
            _textWaiter = new TaskCompletionSource<string>();
            return _textWaiter.Task;
        }
        public async Task<(ODVec2 start, ODVec2 end)> GetLineAsync(string promptStart, string promptEnd)
        {
            var start = await GetPointAsync(promptStart);
            var end = await GetPointAsync(promptEnd);
            return (start, end);
        }
        public Task<string> GetChoiceAsync(string prompt, params string[] options)
        {
            _editor.SetStatus(prompt); // FIXED
            ClearAllWaiters();
            _choiceWaiter = new TaskCompletionSource<string>();
            return _choiceWaiter.Task;
        }
        public void ProvidePoint(ODVec2 point)
        {
            if (point == null)
                throw new ArgumentNullException(nameof(point));
            if (_pointWaiter != null && !_pointWaiter.Task.IsCompleted)
            {
                _pointWaiter.TrySetResult(point);
            }
        }
        public void ProvideNumber(double number)
        {
            if (_numberWaiter != null && !_numberWaiter.Task.IsCompleted)
            {
                _numberWaiter.TrySetResult(number);
            }
        }
        public void ProvideText(string text)
        {
            if (_textWaiter != null && !_textWaiter.Task.IsCompleted)
            {
                _textWaiter.TrySetResult(text);
            }
        }
        public void ProvideChoice(string choice)
        {
            if (_choiceWaiter != null && !_choiceWaiter.Task.IsCompleted)
            {
                _choiceWaiter.TrySetResult(choice);
            }
        }
        public void Cancel()
        {
            _cancellationTokenSource.Cancel();
            _inputService.PointProvided -= OnPointProvided;
            _inputService.NumberInput -= OnNumberProvided;
            _inputService.TextInput -= OnTextProvided;
            ClearAllWaiters();
        }
        private void ClearAllWaiters()
        {
            _pointWaiter = null;
            _numberWaiter = null;
            _textWaiter = null;
            _choiceWaiter = null;
        }
        public void SetStatus(string message)
        {
            _editor.SetStatus(message);
        }
        public void ShowMessage(string message)
        {
            _editor.ShowMessage(message);
        }
    }
}

** ODEditorInputService.cs **
Path: D:\OpenDraft\OpenDraft\ODCore\ODEditor\ODEditorInputService.cs

ï»¿// EditorInputService.cs
using Avalonia.Input;
using OpenDraft.ODCore.ODGeometry;
using OpenDraft.ODCore.ODMath;
using System;
namespace OpenDraft.ODCore.ODEditor
{
    public class ODEditorInputService : IODEditorInputService
    {
        public event Action<Key>? KeyPressed;
        public event Action<ODVec2>? PointProvided;
        public event Action<string>? TextInput;
        public event Action<double>? NumberInput;
        public event Action? CancelRequested;
        public event Action? ViewportEntered;
        public event Action? ViewportExited;
        public void RaiseKeyPressed(Key key)
        {
            KeyPressed?.Invoke(key);
        }
        public void RaisePointProvided(ODVec2 point)
        {
            PointProvided?.Invoke(point);
        }
        public void RaiseTextInput(string text)
        {
            TextInput?.Invoke(text);
        }
        public void RaiseNumberInput(double number)
        {
            NumberInput?.Invoke(number);
        }
        public void RaiseCancelRequested()
        {
            CancelRequested?.Invoke();
        }
        public void RaiseViewportEntered()
        {
            ViewportEntered?.Invoke();
        }
        public void RaiseViewportExited()
        {
            ViewportExited?.Invoke();
        }
        // These can be expanded later for more sophisticated input handling
        public void RequestPointInput() { /* Future: change cursor, show hints */ }
        public void RequestTextInput() { /* Future: focus text box */ }
        public void CancelInputRequest() { /* Future: reset cursor */ }
    }
}

** IODEditorGateway.cs **
Path: D:\OpenDraft\OpenDraft\ODCore\ODEditor\ODCommands\IODEditorGateway.cs

ï»¿using OpenDraft.ODCore.ODData;
using OpenDraft.ODCore.ODEditor.ODDynamics;
using OpenDraft.ODCore.ODGeometry;
using OpenDraft.ODCore.ODMath;
using System.Threading;
using System.Threading.Tasks;
namespace OpenDraft.ODCore.ODEditor.ODCommands
{
    public interface IODEditorGateway
    {
        ODDataManager DataManager { get; }
        Task<ODVec2> GetPointAsync(string prompt);
        Task<double> GetNumberAsync(string prompt);
        Task<string> GetTextAsync(string prompt);
        Task<string> GetChoiceAsync(string prompt, params string[] options);
        Task<(ODVec2 start, ODVec2 end)> GetLineAsync(string promptStart, string promptEnd);
        void SetStatus(string message);
        void ShowMessage(string message);
        void AddDynamicElement(ODDynamicElement element);
        void RemoveDynamicElement(ODDynamicElement element);
        void ClearDynamicElements();
        CancellationToken CancellationToken { get; }
    }
}

** ODBaseEditorCommand.cs **
Path: D:\OpenDraft\OpenDraft\ODCore\ODEditor\ODCommands\ODBaseEditorCommand.cs

ï»¿// ODBaseEditorCommand.cs
using OpenDraft.ODCore.ODGeometry;
using OpenDraft.ODCore.ODMath;
using System;
using System.Reflection;
using System.Threading.Tasks;
namespace OpenDraft.ODCore.ODEditor.ODCommands
{
    public abstract class ODBaseEditorCommand : IODEditorCommand
    {
        private readonly Lazy<ODCommandAttribute> _attribute;
        public string Name => _attribute.Value.Name;
        public string Description => _attribute.Value.Description;
        protected ODBaseEditorCommand()
        {
            _attribute = new Lazy<ODCommandAttribute>(() =>
            {
                var attribute = GetType().GetCustomAttribute<ODCommandAttribute>();
                if (attribute == null)
                {
                    throw new InvalidOperationException(
                        $"Command {GetType().Name} must be decorated with [ODCommand] attribute");
                }
                return attribute;
            });
        }
        public abstract Task ExecuteAsync(IODEditorGateway editor);
        // Helper method for common validation
        protected void ValidatePoint(ODVec2 point, string paramName)
        {
            if (point == null)
                throw new ArgumentNullException(paramName);
            if (double.IsNaN(point.X) || double.IsNaN(point.Y) ||
                double.IsInfinity(point.X) || double.IsInfinity(point.Y))
                throw new ArgumentException($"Invalid point coordinates: ({point.X}, {point.Y})", paramName);
        }
    }
}

** ODCircleCommand.cs **
Path: D:\OpenDraft\OpenDraft\ODCore\ODEditor\ODCommands\ODCircleCommand.cs

ï»¿// Example of using dynamic elements in a command
using OpenDraft.ODCore.ODData;
using OpenDraft.ODCore.ODEditor.ODCommands;
using OpenDraft.ODCore.ODEditor.ODDynamics;
using OpenDraft.ODCore.ODGeometry;
using OpenDraft.ODCore.ODSystem;
using OpenDraft.ODCore.ODMath;
using System.Threading.Tasks;
using System;
[ODCommand("CIRCLE", "Creates a circle", "C")]
public class ODCircleCommand : ODBaseEditorCommand
{
    public override async Task ExecuteAsync(IODEditorGateway editor)
    {
        ushort layId = editor.DataManager.LayerManager.GetActiveLayer();
        ODLayer lay = editor.DataManager.LayerManager.GetLayerByID(layId)!;
        ODVec2 center = await editor.GetPointAsync("Specify center point:");
        ODRubberBandLine rubberBand = new ODRubberBandLine(center);
        rubberBand.LineWeight = ODSystem.GetRegistryValueAsDecimal("style/draw_tool_line_weight");
        rubberBand.Colour = new ODColour(ODSystem.GetRegistryValueAsString("style/draw_tool_colour") ?? "#FFFFFF");
        rubberBand.LineType = ODSystem.GetRegistryValueAsString("style/draw_tool_line_type");
        editor.AddDynamicElement(rubberBand);
        ODRubberBandCircle rubberCircle = new ODRubberBandCircle(center);
        rubberCircle.LineWeight = lay.LineWeight;
        rubberCircle.Colour = lay.Color;
        rubberCircle.LineType = lay.LineType;
        editor.AddDynamicElement(rubberCircle);
        ODVec2 radPoint = await editor.GetPointAsync("Specify radius:");
        // TODO CHANGE POINTS TO VECTORS
        double radius = Math.Sqrt(
            Math.Pow(radPoint.X - center.X, 2) + Math.Pow(radPoint.Y - center.Y, 2)
            );
        var circle = new ODCircle(center, radius);
        editor.DataManager.AddElement(circle); // Use DataManager directly
        editor.SetStatus("Circle created successfully");
    }
}

** ODLineCommand.cs **
Path: D:\OpenDraft\OpenDraft\ODCore\ODEditor\ODCommands\ODLineCommand.cs

ï»¿// Example of using dynamic elements in a command
using OpenDraft.ODCore.ODData;
using OpenDraft.ODCore.ODEditor.ODCommands;
using OpenDraft.ODCore.ODEditor.ODDynamics;
using OpenDraft.ODCore.ODGeometry;
using OpenDraft.ODCore.ODMath;
using System.Threading.Tasks;
[ODCommand("LINE", "Creates a line", "L")]
public class ODLineCommand : ODBaseEditorCommand
{
    public override async Task ExecuteAsync(IODEditorGateway editor)
    {
        ODVec2 start = await editor.GetPointAsync("Specify start point:");
        ushort layId = editor.DataManager.LayerManager.GetActiveLayer();
        ODLayer lay = editor.DataManager.LayerManager.GetLayerByID(layId)!;
        ODRubberBandLine rubberBand = new ODRubberBandLine(start);
        rubberBand.LineWeight = lay.LineWeight;
        rubberBand.Colour = lay.Color;
        rubberBand.LineType = lay.LineType;
        editor.AddDynamicElement(rubberBand);
        ODVec2 end   = await editor.GetPointAsync("Specify end point:");
        var line = new ODLine(start, end);
        editor.DataManager.AddElement(line);
        editor.SetStatus("Line created successfully");
    }
}

** ODCrosshair.cs **
Path: D:\OpenDraft\OpenDraft\ODCore\ODEditor\ODDynamics\ODCrosshair.cs

ï»¿using Avalonia;
using Avalonia.Media;
using OpenDraft.ODCore.ODData;
using OpenDraft.ODCore.ODGeometry;
using OpenDraft.ODCore.ODSystem;
using OpenDraft.ODCore.ODMath;
using System;
namespace OpenDraft.ODCore.ODEditor.ODDynamics
{
    public class ODCrosshairElement : ODDynamicElement
    {
        // Visibility
        public bool IsVisible { get; set; } = true;
        // Style properties
        private int _size = 10;
        public int Size
        {
            get => _size;
            set => _size = value;
        }
        public ODCrosshairElement()
        {
        }
        public override void Draw(DrawingContext context, ODDrawConnector connector,
            double scale, ODVec2 vpWorldSize, ODVec2 worldMousePosition)
        {
            if (!IsVisible)
                return;
            ODLayer? layer = connector.GetLayerByID(LayerId);
            // Get layer
            ODVec2 Center = worldMousePosition;
            double cSize = Size / scale; // Centre square size
            // Get styles from registry
            Color xColour = Avalonia.Media.Color.Parse(ODSystem.ODSystem.GetRegistryValueAsString("style/crosshair_x_colour") ?? "Red");
            Color yColour = Avalonia.Media.Color.Parse(ODSystem.ODSystem.GetRegistryValueAsString("style/crosshair_y_colour") ?? "Lime");
            Color sqColour = Avalonia.Media.Color.Parse(ODSystem.ODSystem.GetRegistryValueAsString("style/crosshair_sq_colour") ?? "White");
            float xThickness = ODSystem.ODSystem.GetRegistryValueAsDecimal("style/crosshair_line_weight") ?? 1;
            Pen xPen = new Pen(new SolidColorBrush(xColour), xThickness / scale);
            Pen yPen = new Pen(new SolidColorBrush(yColour), xThickness / scale);
            Pen sqPen = new Pen(new SolidColorBrush(sqColour), xThickness / scale);
            // Centre square
            context.DrawRectangle(null, sqPen,
                new Rect(
                    new Point(Center.X - cSize / 2, Center.Y - cSize / 2),
                    new Size(cSize, cSize)
                ));
            var top = new Point(Center.X, Center.Y + vpWorldSize.Y);
            var bottom = new Point(Center.X, Center.Y - vpWorldSize.Y);
            var left = new Point(Center.X - vpWorldSize.X, Center.Y);
            var right = new Point(Center.X + vpWorldSize.X, Center.Y);
            context.DrawLine(yPen, top, new Point(Center.X, Center.Y + cSize / 2)); // Top
            context.DrawLine(xPen, left, new Point(Center.X - cSize / 2, Center.Y)); // Left
            context.DrawLine(yPen, new Point(Center.X, Center.Y - cSize / 2), bottom); // Bottom
            context.DrawLine(xPen, new Point(Center.X + cSize / 2, Center.Y), right); // Right
        }
    }
}


** ODDynamicElement.cs **
Path: D:\OpenDraft\OpenDraft\ODCore\ODEditor\ODDynamics\ODDynamicElement.cs

ï»¿using Avalonia;
using Avalonia.Media;
using OpenDraft.ODCore.ODData;
using OpenDraft.ODCore.ODGeometry;
using OpenDraft.ODCore.ODMath;
using System;
namespace OpenDraft.ODCore.ODEditor.ODDynamics
{
    public class ODDynamicElement
    {
        public Guid Id { get; set; }
        public ODColour? Colour { get; set; } = null; // If null, use layer colour
        public double? LineWeight { get; set; } = 2.0f; // If null, use layer line weight
        public string? LineType { get; set; } = null; // If null, use layer line type
        public ushort LayerId { get; set; } = 0; // Default layer ID
        public ODDynamicElement()
        {
            Id = Guid.NewGuid();
        }
        public virtual void Draw(DrawingContext context, ODDrawConnector connector, 
            double scale, ODVec2 vpWorldSize, ODVec2 mousePosition)
        {
            // Base draw method, to be overridden by derived classes
        }
    }
}


** ODRubberBandCircle.cs **
Path: D:\OpenDraft\OpenDraft\ODCore\ODEditor\ODDynamics\ODRubberBandCircle.cs

ï»¿using Avalonia;
using Avalonia.Media;
using OpenDraft.ODCore.ODData;
using OpenDraft.ODCore.ODGeometry;
using OpenDraft.ODCore.ODMath;
using System;
using System.Diagnostics;
using System.Net;
namespace OpenDraft.ODCore.ODEditor.ODDynamics
{
    public class ODRubberBandCircle : ODDynamicElement
    {
        public ODVec2 Start { get; set; }
        public float Weight { get; set; } = 1.0f;
        public ODRubberBandCircle(ODVec2 start)
        {
            Start = start;
        }
        public override void Draw(DrawingContext context, ODDrawConnector connector,
            double scale, ODVec2 vpWorldSize, ODVec2 mousePosition)
        {
            ODLayer? layer = connector.GetLayerByID(LayerId);
            if (layer == null || !layer.IsVisible || layer.Color == null)
                return;
            // Get dash style from registry
            IDashStyle dashStyle = connector.ToAvaloniaDashStyle(LineType ?? layer.LineType);
            string effectiveColour = (Colour != null) ? Colour.ToHex() : layer.Color.ToHex();
            double effectiveLineWeight = LineWeight ?? layer.LineWeight;
            // Create pen
            Pen pen = new Pen(
                new SolidColorBrush(Color.Parse(effectiveColour)), // Brush only
                effectiveLineWeight,                               // Thickness
                dashStyle                                          // Dash style
            );
            double radius = Math.Sqrt(
                Math.Pow(mousePosition.X - Start.X, 2) + Math.Pow(mousePosition.Y - Start.Y, 2)
                );
            context.DrawEllipse(null, pen,
                new Point(Start.X, Start.Y),
                Math.Abs(radius),
                Math.Abs(radius));
        }
    }
}


** ODRubberBandLine.cs **
Path: D:\OpenDraft\OpenDraft\ODCore\ODEditor\ODDynamics\ODRubberBandLine.cs

ï»¿using Avalonia;
using Avalonia.Media;
using OpenDraft.ODCore.ODData;
using OpenDraft.ODCore.ODGeometry;
using OpenDraft.ODCore.ODMath;
using System;
namespace OpenDraft.ODCore.ODEditor.ODDynamics
{
    public class ODRubberBandLine : ODDynamicElement
    {
        public ODVec2 Start { get; set; }
        public ODRubberBandLine(ODVec2 start)
        {
            Start = start;
        }
        public override void Draw(DrawingContext context, ODDrawConnector connector,
            double scale, ODVec2 vpWorldSize, ODVec2 mousePosition)
        {
            ODLayer? layer = connector.GetLayerByID(LayerId);
            if (layer == null || !layer.IsVisible || layer.Color == null)
                return;
            // Get dash style from registry
            IDashStyle dashStyle = connector.ToAvaloniaDashStyle(LineType ?? layer.LineType);
            string effectiveColour = (Colour != null) ? Colour.ToHex() : layer.Color.ToHex();
            double effectiveLineWeight = LineWeight ?? layer.LineWeight;
            // Create pen
            Pen pen = new Pen(
                new SolidColorBrush(Color.Parse(effectiveColour)), // Brush only
                effectiveLineWeight,                               // Thickness
                dashStyle                                          // Dash style
            );
            context.DrawLine(pen, new Point(Start.X, Start.Y), new Point(mousePosition.X, mousePosition.Y));
        }
    }
}


** ODSnapIndicatorElement.cs **
Path: D:\OpenDraft\OpenDraft\ODCore\ODEditor\ODDynamics\ODSnapIndicatorElement.cs

ï»¿using Avalonia;
using Avalonia.Media;
using OpenDraft.ODCore.ODData;
using OpenDraft.ODCore.ODGeometry;
using OpenDraft.ODCore.ODMath;
using System;
namespace OpenDraft.ODCore.ODEditor.ODDynamics
{
    public class SnapIndicatorElement : ODDynamicElement
    {
        public ODVec2 Position { get; set; }
        public double Radius { get; set; } = 5.0;
        public SnapIndicatorElement(ODVec2 position)
        {
            Position = position;
        }
        public override void Draw(DrawingContext context, ODDrawConnector connector, 
            double scale, ODVec2 vpExtents, ODVec2 worldMousePosition)
        {
            var brush = new SolidColorBrush(Colors.Yellow);
            var pen = new Pen(brush, 1.5);
            context.DrawEllipse(null, pen,
                new Point(Position.X, Position.Y),
                Radius, Radius);
        }
    }
}


** ODCircle.cs **
Path: D:\OpenDraft\OpenDraft\ODCore\ODGeometry\ODCircle.cs

ï»¿using Avalonia;
using Avalonia.Media;
using OpenDraft.ODCore.ODData;
using OpenDraft.ODCore.ODMath;
namespace OpenDraft.ODCore.ODGeometry
{
    internal class ODCircle : ODElement
    {
        public ODVec2 Center { get; set; }
        public double Radius { get; set; }
        public ODCircle(ODVec2 center, double radius)
        {
            Center = center;
            Radius = radius;
        }
        public override void Draw(DrawingContext context, ODDrawConnector connector)
        {
            ODLayer? layer = connector.GetLayerByID(LayerId);
            if (layer != null && !layer.IsVisible)
                return;
            if (layer == null)
                return;
            // Get dash style from registry
            var dashStyle = connector.ToAvaloniaDashStyle(LineType ?? layer.LineType);
            ODColour effectiveColour = (Colour != null) ? Colour : layer.Color;
            double effectiveLineWeight = LineWeight ?? layer.LineWeight;
            // Create pen
            var pen = new Pen(
                new SolidColorBrush(effectiveColour.ToAvaloniaColor()), // Brush only
                effectiveLineWeight,                                    // Thickness
                dashStyle                                               // Dash style
            );
            context.DrawEllipse(null, pen, new Point(Center.X, Center.Y), Radius, Radius);
        }
    }
}


** ODLine.cs **
Path: D:\OpenDraft\OpenDraft\ODCore\ODGeometry\ODLine.cs

ï»¿using Avalonia;
using Avalonia.Media;
using Microsoft.Win32;
using OpenDraft.ODCore.ODData;
using OpenDraft.ODCore.ODMath;
using System;
namespace OpenDraft.ODCore.ODGeometry
{
    internal class ODLine : ODElement
    {
        public ODVec2 StartPoint { get; set; }
        public ODVec2 EndPoint { get; set; }
        public ODLine(ODVec2 startPoint, ODVec2 endPoint)
        {
            StartPoint = startPoint;
            EndPoint = endPoint;
        }
        public override void Draw(DrawingContext context, ODDrawConnector connector)
        {
            ODLayer? layer = connector.GetLayerByID(LayerId);
            if (layer != null && !layer.IsVisible)
                return;
            if (layer == null)
                return;
            // Get dash style from registry
            IDashStyle dashStyle = connector.ToAvaloniaDashStyle(LineType ?? layer.LineType);
            ODColour effectiveColour = (Colour != null) ? Colour : layer.Color;
            double effectiveLineWeight = LineWeight ?? layer.LineWeight;
            // Create pen
            var pen = new Pen(
                new SolidColorBrush(effectiveColour.ToAvaloniaColor()), // Brush only
                effectiveLineWeight,                                    // Thickness
                dashStyle                                               // Dash style
            );
            context.DrawLine(pen,
                    new Point(StartPoint.X, StartPoint.Y),
                    new Point(EndPoint.X, EndPoint.Y));
        }
    }
}


** ODPolyline.cs **
Path: D:\OpenDraft\OpenDraft\ODCore\ODGeometry\ODPolyline.cs

ï»¿using Avalonia;
using Avalonia.Media;
using Microsoft.Win32;
using OpenDraft.ODCore.ODData;
using System;
using System.Collections.Generic;
using OpenDraft.ODCore.ODMath;
using System.Linq;
namespace OpenDraft.ODCore.ODGeometry
{
    public class ODPolyline : ODElement
    {
        public List<ODVec2> Points { get; set; }
        public ODPolyline(List<ODVec2> points)
        {
            Points = points ?? new List<ODVec2>();
        }
        public override void Draw(DrawingContext context, ODDrawConnector connector)
        {
            ODLayer? layer = connector.GetLayerByID(LayerId);
            if (layer != null && !layer.IsVisible)
                return;
            if (layer == null)
                return;
            if (Points == null || Points.Count < 2)
                return;
            // Get dash style from registry
            var dashStyle = connector.ToAvaloniaDashStyle(LineType ?? layer.LineType);
            ODColour effectiveColour = (Colour != null) ? Colour : layer.Color;
            double effectiveLineWeight = LineWeight ?? layer.LineWeight;
            // Create pen
            var pen = new Pen(
                new SolidColorBrush(effectiveColour.ToAvaloniaColor()), // Brush only
                effectiveLineWeight,                                    // Thickness
                dashStyle                                               // Dash style
            );
            // Draw each segment individually
            for (int i = 1; i < Points.Count; i++)
            {
                context.DrawLine(pen,
                    new Point(Points[i - 1].X, Points[i - 1].Y),
                    new Point(Points[i].X, Points[i].Y));
            }
        }
        // Optional: Add convenience properties and methods
        public bool IsClosed => Points.Count > 2 && Points[0].Equals(Points[Points.Count - 1]);
        public double Length
        {
            get
            {
                if (Points.Count < 2) return 0;
                double length = 0;
                for (int i = 1; i < Points.Count; i++)
                {
                    length += Math.Sqrt(
                        Math.Pow(Points[i].X - Points[i - 1].X, 2) +
                        Math.Pow(Points[i].Y - Points[i - 1].Y, 2));
                }
                return length;
            }
        }
        public ODVec2 StartPoint => Points?.FirstOrDefault() ?? new ODVec2(0, 0);
        public ODVec2 EndPoint => Points?.LastOrDefault() ?? new ODVec2(0, 0);
        public void AddPoint(ODVec2 point)
        {
            Points.Add(point);
        }
        public void InsertPoint(int index, ODVec2 point)
        {
            if (index >= 0 && index <= Points.Count)
                Points.Insert(index, point);
        }
        public void RemovePoint(int index)
        {
            if (index >= 0 && index < Points.Count)
                Points.RemoveAt(index);
        }
        public ODRectangle GetBoundingBox()
        {
            if (Points == null || Points.Count == 0)
                return new ODRectangle(new ODVec2(0, 0), new ODVec2(0, 0));
            double minX = Points.Min(p => p.X);
            double maxX = Points.Max(p => p.X);
            double minY = Points.Min(p => p.Y);
            double maxY = Points.Max(p => p.Y);
            return new ODRectangle(new ODVec2(minX, minY), new ODVec2(maxX, maxY));
        }
    }
}

** ODRectangle.cs **
Path: D:\OpenDraft\OpenDraft\ODCore\ODGeometry\ODRectangle.cs

ï»¿using Avalonia;
using Avalonia.Media;
using OpenDraft.ODCore.ODData;
using System;
using System.Collections.Generic;
using OpenDraft.ODCore.ODMath;
using System.Linq;
using System.Xml.Linq;
namespace OpenDraft.ODCore.ODGeometry
{
    public class ODRectangle : ODElement
    {
        public ODVec2 TopLeft { get; set; }
        public ODVec2 BottomRight { get; set; }
        public ODRectangle(ODVec2 topLeft, ODVec2 bottomRight)
        {
            TopLeft = topLeft;
            BottomRight = bottomRight;
        }
        // Alternative constructor from center point and dimensions
        public ODRectangle(ODVec2 center, double width, double height)
        {
            double halfWidth = width / 2;
            double halfHeight = height / 2;
            TopLeft = new ODVec2(center.X - halfWidth, center.Y - halfHeight);
            BottomRight = new ODVec2(center.X + halfWidth, center.Y + halfHeight);
        }
        // Alternative constructor from corner point and dimensions
        public ODRectangle(ODVec2 corner, double width, double height, bool isTopLeft = true)
        {
            if (isTopLeft)
            {
                TopLeft = corner;
                BottomRight = new ODVec2(corner.X + width, corner.Y + height);
            }
            else
            {
                BottomRight = corner;
                TopLeft = new ODVec2(corner.X - width, corner.Y - height);
            }
        }
        public override void Draw(DrawingContext context, ODDrawConnector connector)
        {
            ODLayer? layer = connector.GetLayerByID(LayerId);
            if (layer != null && !layer.IsVisible)
                return;
            if (layer == null)
                return;
            // Get dash style from registry
            var dashStyle = connector.ToAvaloniaDashStyle(LineType ?? layer.LineType);
            ODColour effectiveColour = (Colour != null) ? Colour : layer.Color;
            double effectiveLineWeight = LineWeight ?? layer.LineWeight;
            // Create pen
            var pen = new Pen(
                new SolidColorBrush(effectiveColour.ToAvaloniaColor()), // Brush only
                effectiveLineWeight,                                    // Thickness
                dashStyle                                               // Dash style
            );
            // Create rectangle geometry
            Rect rect = new Rect(
                new Point(TopLeft.X, TopLeft.Y),
                new Point(BottomRight.X, BottomRight.Y)
            );
            // Draw the rectangle
            context.DrawRectangle(pen, rect);
        }
        // Properties for convenience
        public double X => TopLeft.X;
        public double Y => TopLeft.Y;
        public double Width => Math.Abs(BottomRight.X - TopLeft.X);
        public double Height => Math.Abs(BottomRight.Y - TopLeft.Y);
        public ODVec2 TopRight => new ODVec2(BottomRight.X, TopLeft.Y);
        public ODVec2 BottomLeft => new ODVec2(TopLeft.X, BottomRight.Y);
        public ODVec2 Center => new ODVec2(
            (TopLeft.X + BottomRight.X) / 2,
            (TopLeft.Y + BottomRight.Y) / 2
        );
        public double Area => Width * Height;
        public double Perimeter => 2 * (Width + Height);
        // Method to check if a point is inside the rectangle
        public bool ContainsPoint(ODVec2 point)
        {
            var minX = Math.Min(TopLeft.X, BottomRight.X);
            var maxX = Math.Max(TopLeft.X, BottomRight.X);
            var minY = Math.Min(TopLeft.Y, BottomRight.Y);
            var maxY = Math.Max(TopLeft.Y, BottomRight.Y);
            return point.X >= minX && point.X <= maxX &&
                   point.Y >= minY && point.Y <= maxY;
        }
        // Convert to polyline (useful for some operations)
        public ODPolyline ToPolyline()
        {
            var points = new List<ODVec2>
            {
                TopLeft,
                TopRight,
                BottomRight,
                BottomLeft,
                TopLeft // Close the rectangle
            };
            return new ODPolyline(points);
        }
        // Get bounding box (for compatibility with other geometry)
        public ODRectangle GetBoundingBox()
        {
            return this; // A rectangle is its own bounding box
        }
        // SVG export support
        public XElement ToSvgElement(ODLayer layer, ODLineStyleRegistry registry)
        {
            var element = new XElement("{http://www.w3.org/2000/svg}rect",
                new XAttribute("x", TopLeft.X),
                new XAttribute("y", TopLeft.Y),
                new XAttribute("width", Width),
                new XAttribute("height", Height),
                new XAttribute("fill", "none") // No fill by default
            );
            return element;
        }
        public override string ToString()
        {
            return $"Rectangle [({X:0.##}, {Y:0.##}) {Width:0.##}x{Height:0.##}]";
        }
    }
}

** ODSymbol.cs **
Path: D:\OpenDraft\OpenDraft\ODCore\ODGeometry\ODSymbol.cs

ï»¿using Avalonia.Media;
using OpenDraft.ODCore.ODData;
using OpenDraft.ODCore.ODMath;
using OpenDraft.ODCore.ODGeometry;
using System.Collections.Generic;
using System.Net;
namespace OpenDraft.ODCore.ODGeometry
{
    public class ODSymbolDefinition : ODElement
    {
        public string BlockName { get; set; }
        public ODVec2 InsertionPoint { get; set; }
        public double Rotation { get; set; }
        public double ScaleX { get; set; } = 1.0;
        public double ScaleY { get; set; } = 1.0;
        public ODSymbolDefinition(string blockName, ODVec2 insertionPoint)
        {
            BlockName = blockName;
            InsertionPoint = insertionPoint;
        }
        public override void Draw(DrawingContext context, ODDrawConnector connector)
        {
            ODLayer? layer = connector.GetLayerByID(LayerId);
            if (layer != null && !layer.IsVisible)
                return;
            if (layer == null)
                return;
            // Get dash style from registry
            var dashStyle = connector.ToAvaloniaDashStyle(LineType ?? layer.LineType);
            ODColour effectiveColour = (Colour != null) ? Colour : layer.Color;
            double effectiveLineWeight = LineWeight ?? layer.LineWeight;
            // Create pen
            var pen = new Pen(
                new SolidColorBrush(effectiveColour.ToAvaloniaColor()), // Brush only
                effectiveLineWeight,                                    // Thickness
                dashStyle                                               // Dash style
            );
            //foreach (ODElement element in GetBlockElements(BlockName))
            //{
            //element.Draw(context, lm);
            //}
        }
    }
}

** ODSymbolDefinition.cs **
Path: D:\OpenDraft\OpenDraft\ODCore\ODGeometry\ODSymbolDefinition.cs

ï»¿using OpenDraft.ODCore.ODGeometry;
using System.Collections.Generic;
using OpenDraft.ODCore.ODMath;
namespace OpenDraft.ODCore.ODGeometry
{
    public class ODSymbol : ODElement
    {
        public string Name { get; set; }
        public List<ODElement> Elements { get; set; } = new List<ODElement>();
        public ODSymbol(string name, ODVec2 basePoint)
        {
            Name = name;
        }
    }
}

** ODMath.cs **
Path: D:\OpenDraft\OpenDraft\ODCore\ODMath\ODMath.cs

ï»¿using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading.Tasks;
namespace OpenDraft.ODCore.ODMath
{
    public class ODVec2
        {
        public double X { get; set; }
        public double Y { get; set; }
        public ODVec2(double x, double y)
        {
            X = x;
            Y = y;
        }
        public static ODVec2 operator +(ODVec2 a, ODVec2 b)
        {
            return new ODVec2(a.X + b.X, a.Y + b.Y);
        }
        public static ODVec2 operator -(ODVec2 a, ODVec2 b)
        {
            return new ODVec2(a.X - b.X, a.Y - b.Y);
        }
        public static ODVec2 operator *(ODVec2 a, double scalar)
        {
            return new ODVec2(a.X * scalar, a.Y * scalar);
        }
        public static ODVec2 operator /(ODVec2 a, double scalar)
        {
            if (scalar == 0)
                throw new DivideByZeroException("Cannot divide by zero.");
            return new ODVec2(a.X / scalar, a.Y / scalar);
        }
        public double Magnitude()
        {
            return (double)Math.Sqrt(X * X + Y * Y);
        }
        public ODVec2 Normalize()
        {
            double magnitude = Magnitude();
            if (magnitude == 0)
                throw new InvalidOperationException("Cannot normalize a zero vector.");
            return this / magnitude;
        }
        public override string ToString()
        {
            return $"({X}, {Y})";
        }
    }
}


** ODSvgReader.cs **
Path: D:\OpenDraft\OpenDraft\XSVG\ODSvgReader.cs

ï»¿using OpenDraft.ODCore.ODData;
using OpenDraft.ODCore.ODGeometry;
using OpenDraft.ODCore.ODMath;
using System;
using System.Collections.Generic;
using System.Diagnostics;
using System.Text;
using System.Xml.Linq;
namespace OpenDraft.XSVG
{
    internal struct ODSvgStyle
    {
        public ODColour StrokeColor;
        public ODColour FillColor;
        public double StrokeWidth;
        public string LineType;
        public string LayerName;
        public bool IsVisible;
        public bool IsLocked;
    }
    public class CADLayer
    {
        public string Id { get; set; }
        public string Name { get; set; }
        public ODColour Color { get; set; }
        public bool Visible { get; set; }
        public bool Locked { get; set; }
        public double LineWeight { get; set; }
        public string LineType { get; set; }
    }
    public class ODSvgReader
    {
        private string? _filePath;
        private XDocument? _xDocument;
        private XNamespace _ns = "http://www.w3.org/2000/svg";
        private XNamespace _cadNs = "http://your-cad-app.org/cad/1.0";
        private XNamespace _dcNs = "http://purl.org/dc/elements/1.1/";
        private Dictionary<string, CADLayer> _layers = new Dictionary<string, CADLayer>();
        private Dictionary<string, XElement> _blockDefinitions = new Dictionary<string, XElement>();
        private CADMetadata _metadata = new CADMetadata();
        public void LoadSvgFile(string filePath)
        {
            _filePath = filePath;
            if (!System.IO.File.Exists(filePath))
                throw new System.IO.FileNotFoundException("SVG file not found", filePath);
            string fileContentsRaw = System.IO.File.ReadAllText(filePath);
            _xDocument = XDocument.Parse(fileContentsRaw);
            // Parse CAD-specific metadata and definitions
            ParseCADMetadata();
            ParseLayerDefinitions();
            ParseBlockDefinitions();
        }
        #region CAD Metadata Parsing
        private void ParseCADMetadata()
        {
            if (_xDocument?.Root == null) return;
            // Parse root CAD attributes
            _metadata.AppVersion = _xDocument.Root.Attribute(_cadNs + "app-version")?.Value;
            _metadata.FileVersion = _xDocument.Root.Attribute(_cadNs + "file-version")?.Value;
            _metadata.Units = _xDocument.Root.Attribute(_cadNs + "units")?.Value;
            _metadata.Precision = ParseDouble(_xDocument.Root.Attribute(_cadNs + "precision")?.Value) ?? 0.001;
            // Parse metadata section
            var metadataElement = _xDocument.Root.Element("metadata");
            if (metadataElement != null)
            {
                _metadata.Application = metadataElement.Element(_cadNs + "application")?.Value;
                _metadata.Version = metadataElement.Element(_cadNs + "version")?.Value;
                _metadata.Created = ParseDateTime(metadataElement.Element(_cadNs + "created")?.Value);
                _metadata.Modified = ParseDateTime(metadataElement.Element(_cadNs + "modified")?.Value);
                // Parse Dublin Core metadata
                _metadata.Title = metadataElement.Element(_dcNs + "title")?.Value;
                _metadata.Creator = metadataElement.Element(_dcNs + "creator")?.Value;
                _metadata.Description = metadataElement.Element(_dcNs + "description")?.Value;
                // Parse custom properties
                var propertiesElement = metadataElement.Element(_cadNs + "properties");
                if (propertiesElement != null)
                {
                    _metadata.Properties = new Dictionary<string, string>();
                    foreach (var propElement in propertiesElement.Elements(_cadNs + "property"))
                    {
                        var name = propElement.Attribute("name")?.Value;
                        var value = propElement.Attribute("value")?.Value;
                        if (name != null)
                        {
                            _metadata.Properties[name] = value ?? string.Empty;
                        }
                    }
                }
            }
        }
        private void ParseLayerDefinitions()
        {
            var layersElement = _xDocument?.Root?
                .Element("defs")?
                .Element(_cadNs + "layers");
            if (layersElement == null) return;
            foreach (var layerElement in layersElement.Elements(_cadNs + "layer"))
            {
                var layer = new CADLayer
                {
                    Id = layerElement.Attribute("id")?.Value,
                    Name = layerElement.Attribute("name")?.Value,
                    Color = ParseColor(layerElement.Attribute("color")?.Value),
                    Visible = layerElement.Attribute("visible")?.Value == "true",
                    Locked = layerElement.Attribute("locked")?.Value == "true",
                    LineWeight = ParseDouble(layerElement.Attribute("lineweight")?.Value) ?? 0.25,
                    LineType = layerElement.Attribute("linetype")?.Value ?? "continuous"
                };
                if (layer.Id != null)
                {
                    _layers[layer.Id] = layer;
                }
            }
        }
        private void ParseBlockDefinitions()
        {
            var defsElement = _xDocument?.Root?.Element("defs");
            if (defsElement == null) return;
            foreach (var symbolElement in defsElement.Elements(_ns + "symbol"))
            {
                var id = symbolElement.Attribute("id")?.Value;
                if (id != null)
                {
                    _blockDefinitions[id] = symbolElement;
                }
            }
        }
        #endregion
        #region Geometry Import
        public List<ODElement> ImportGeometry()
        {
            if (_xDocument == null)
                throw new InvalidOperationException("No SVG file loaded. Call LoadSvgFile first.");
            var geometries = new List<ODElement>();
            var svgElement = _xDocument.Root;
            // Process groups (layers) first
            geometries.AddRange(ProcessGroups(svgElement));
            // Import individual elements not in groups
            geometries.AddRange(ImportPaths(svgElement));
            geometries.AddRange(ImportRectangles(svgElement));
            geometries.AddRange(ImportLines(svgElement));
            geometries.AddRange(ImportCircles(svgElement));
            geometries.AddRange(ImportBlockReferences(svgElement));
            Debug.WriteLine($"Imported {geometries.Count} geometry objects from {_layers.Count} layers");
            return geometries;
        }
        private List<ODElement> ProcessGroups(XElement parentElement)
        {
            var elements = new List<ODElement>();
            foreach (var groupElement in parentElement.Elements(_ns + "g"))
            {
                var layerId = groupElement.Attribute(_cadNs + "layer-id")?.Value;
                var style = ParseStyle(groupElement, layerId);
                // Process elements within the group
                elements.AddRange(ImportPaths(groupElement, style));
                elements.AddRange(ImportRectangles(groupElement, style));
                elements.AddRange(ImportLines(groupElement, style));
                elements.AddRange(ImportCircles(groupElement, style));
                elements.AddRange(ImportBlockReferences(groupElement, style));
                elements.AddRange(ProcessGroups(groupElement)); // Recursive for nested groups
            }
            return elements;
        }
        private List<ODElement> ImportBlockReferences(XElement parentElement, ODSvgStyle? parentStyle = null)
        {
            var blocks = new List<ODElement>();
            foreach (var useElement in parentElement.Descendants(_ns + "use"))
            {
                var href = useElement.Attribute(XNamespace.Get("http://www.w3.org/1999/xlink") + "href")?.Value;
                if (!string.IsNullOrEmpty(href) && href.StartsWith("#"))
                {
                    var blockId = href.Substring(1);
                    if (_blockDefinitions.TryGetValue(blockId, out var blockDefinition))
                    {
                        var style = ParseStyle(useElement, null, parentStyle);
                        var x = ParseDouble(useElement.Attribute("x")?.Value) ?? 0;
                        var y = ParseDouble(useElement.Attribute("y")?.Value) ?? 0;
                        // Parse transformation
                        var transform = useElement.Attribute("transform")?.Value;
                        var rotation = ParseDouble(useElement.Attribute(_cadNs + "rotation")?.Value) ?? 0;
                        var blockElements = ParseBlockDefinition(blockDefinition, x, y, rotation, style);
                        foreach (var element in blockElements)
                        {
                            ApplyCADMetadata(element, useElement);
                            blocks.Add(element);
                        }
                    }
                }
            }
            return blocks;
        }
        private List<ODElement> ParseBlockDefinition(XElement blockDefinition, double x, double y, double rotation, ODSvgStyle style)
        {
            var elements = new List<ODElement>();
            // Process paths in block definition
            foreach (var pathElement in blockDefinition.Descendants(_ns + "path"))
            {
                var pathData = pathElement.Attribute("d")?.Value;
                if (!string.IsNullOrEmpty(pathData))
                {
                    var path = ParsePathData(pathData, style);
                    if (path != null)
                    {
                        // Apply block transformation
                        ApplyTransformation(path, x, y, rotation);
                        elements.Add(path);
                    }
                }
            }
            // Process rectangles in block definition
            foreach (var rectElement in blockDefinition.Descendants(_ns + "rect"))
            {
                var rectX = ParseDouble(rectElement.Attribute("x")?.Value) ?? 0;
                var rectY = ParseDouble(rectElement.Attribute("y")?.Value) ?? 0;
                var width = ParseDouble(rectElement.Attribute("width")?.Value) ?? 0;
                var height = ParseDouble(rectElement.Attribute("height")?.Value) ?? 0;
                var rectangle = new ODRectangle(
                    new ODVec2(rectX + x, rectY + y),
                    new ODVec2(rectX + x + width, rectY + y + height)
                );
                ApplyTransformation(rectangle, x, y, rotation);
                elements.Add(rectangle);
            }
            return elements;
        }
        private void ApplyTransformation(ODElement element, double x, double y, double rotation)
        {
            // This is a simplified transformation - you'll need to implement
            // proper transformation logic based on your ODElement hierarchy
            if (element is ODPolyline polyline)
            {
                for (int i = 0; i < polyline.Points.Count; i++)
                {
                    var point = polyline.Points[i];
                    // Apply translation and rotation here
                    polyline.Points[i] = new ODVec2(point.X + x, point.Y + y);
                }
            }
            // Add similar logic for other element types
        }
        #endregion
        #region Original Geometry Import Methods (Preserved)
        private List<ODElement> ImportPaths(XElement parentElement, ODSvgStyle? parentStyle = null)
        {
            var paths = new List<ODElement>();
            foreach (var pathElement in parentElement.Descendants(_ns + "path"))
            {
                var pathData = pathElement.Attribute("d")?.Value;
                if (!string.IsNullOrEmpty(pathData))
                {
                    var style = ParseStyle(pathElement, null, parentStyle);
                    var path = ParsePathData(pathData, style);
                    if (path != null)
                    {
                        ApplyCADMetadata(path, pathElement);
                        paths.Add(path);
                    }
                }
            }
            return paths;
        }
        private List<ODElement> ImportRectangles(XElement parentElement, ODSvgStyle? parentStyle = null)
        {
            var rectangles = new List<ODElement>();
            foreach (var rectElement in parentElement.Descendants(_ns + "rect"))
            {
                var x = ParseDouble(rectElement.Attribute("x")?.Value) ?? 0;
                var y = ParseDouble(rectElement.Attribute("y")?.Value) ?? 0;
                var width = ParseDouble(rectElement.Attribute("width")?.Value) ?? 0;
                var height = ParseDouble(rectElement.Attribute("height")?.Value) ?? 0;
                if (width > 0 && height > 0)
                {
                    var style = ParseStyle(rectElement, null, parentStyle);
                    var rectangle = new ODRectangle(
                        new ODVec2(x, y),
                        new ODVec2(x + width, y + height)
                    );
                    ApplyCADMetadata(rectangle, rectElement);
                    rectangles.Add(rectangle);
                }
            }
            return rectangles;
        }
        private List<ODElement> ImportLines(XElement parentElement, ODSvgStyle? parentStyle = null)
        {
            var lines = new List<ODElement>();
            foreach (var lineElement in parentElement.Descendants(_ns + "line"))
            {
                var x1 = ParseDouble(lineElement.Attribute("x1")?.Value) ?? 0;
                var y1 = ParseDouble(lineElement.Attribute("y1")?.Value) ?? 0;
                var x2 = ParseDouble(lineElement.Attribute("x2")?.Value) ?? 0;
                var y2 = ParseDouble(lineElement.Attribute("y2")?.Value) ?? 0;
                var style = ParseStyle(lineElement, null, parentStyle);
                var line = new ODLine(
                    new ODVec2(x1, y1),
                    new ODVec2(x2, y2)
                );
                ApplyCADMetadata(line, lineElement);
                lines.Add(line);
            }
            return lines;
        }
        private List<ODElement> ImportCircles(XElement parentElement, ODSvgStyle? parentStyle = null)
        {
            var circles = new List<ODElement>();
            foreach (var circleElement in parentElement.Descendants(_ns + "circle"))
            {
                var cx = ParseDouble(circleElement.Attribute("cx")?.Value) ?? 0;
                var cy = ParseDouble(circleElement.Attribute("cy")?.Value) ?? 0;
                var r = ParseDouble(circleElement.Attribute("r")?.Value) ?? 0;
                if (r > 0)
                {
                    var style = ParseStyle(circleElement, null, parentStyle);
                    var circle = new ODCircle(
                        new ODVec2(cx, cy),
                        r
                    );
                    ApplyCADMetadata(circle, circleElement);
                    circles.Add(circle);
                }
            }
            return circles;
        }
        #endregion
        #region Path Data Parsing (Original Methods)
        private ODElement ParsePathData(string pathData, ODSvgStyle style)
        {
            try
            {
                var points = new List<ODVec2>();
                var tokens = TokenizePathData(pathData);
                double currentX = 0, currentY = 0;
                double startX = 0, startY = 0;
                bool hasValidData = false;
                for (int i = 0; i < tokens.Count; i++)
                {
                    var token = tokens[i];
                    var upperToken = token.ToUpper();
                    switch (upperToken)
                    {
                        case "M": // Move To
                            if (i + 2 < tokens.Count &&
                                TryParseDouble(tokens[i + 1], out double mx) &&
                                TryParseDouble(tokens[i + 2], out double my))
                            {
                                if (token == "m") // relative
                                {
                                    currentX += mx;
                                    currentY += my;
                                }
                                else // absolute
                                {
                                    currentX = mx;
                                    currentY = my;
                                }
                                startX = currentX;
                                startY = currentY;
                                points.Add(new ODVec2(currentX, currentY));
                                i += 2;
                                hasValidData = true;
                            }
                            break;
                        case "L": // Line To
                            if (i + 2 < tokens.Count &&
                                TryParseDouble(tokens[i + 1], out double lx) &&
                                TryParseDouble(tokens[i + 2], out double ly))
                            {
                                if (token == "l") // relative
                                {
                                    currentX += lx;
                                    currentY += ly;
                                }
                                else // absolute
                                {
                                    currentX = lx;
                                    currentY = ly;
                                }
                                points.Add(new ODVec2(currentX, currentY));
                                i += 2;
                                hasValidData = true;
                            }
                            break;
                        case "H": // Horizontal Line To
                            if (i + 1 < tokens.Count &&
                                TryParseDouble(tokens[i + 1], out double hx))
                            {
                                if (token == "h") // relative
                                {
                                    currentX += hx;
                                }
                                else // absolute
                                {
                                    currentX = hx;
                                }
                                points.Add(new ODVec2(currentX, currentY));
                                i += 1;
                                hasValidData = true;
                            }
                            break;
                        case "V": // Vertical Line To
                            if (i + 1 < tokens.Count &&
                                TryParseDouble(tokens[i + 1], out double vy))
                            {
                                if (token == "v") // relative
                                {
                                    currentY += vy;
                                }
                                else // absolute
                                {
                                    currentY = vy;
                                }
                                points.Add(new ODVec2(currentX, currentY));
                                i += 1;
                                hasValidData = true;
                            }
                            break;
                        case "Z": // Close Path
                            if (points.Count > 0)
                            {
                                // Close the path by returning to start point
                                points.Add(new ODVec2(startX, startY));
                                hasValidData = true;
                            }
                            break;
                        default:
                            // Skip unknown commands and their parameters
                            if (IsCommandToken(token))
                            {
                                // Skip the command and its parameters
                                i += GetParameterCountForCommand(token);
                            }
                            break;
                    }
                }
                if (hasValidData && points.Count > 1)
                {
                    return new ODPolyline(points);
                }
            }
            catch (Exception ex)
            {
                Debug.WriteLine($"Error parsing path data: {ex.Message}");
                Debug.WriteLine($"Path data: {pathData}");
            }
            return null;
        }
        private List<string> TokenizePathData(string pathData)
        {
            var tokens = new List<string>();
            if (string.IsNullOrEmpty(pathData)) return tokens;
            var currentToken = new StringBuilder();
            bool inNumber = false;
            foreach (char c in pathData)
            {
                if (char.IsWhiteSpace(c) || c == ',')
                {
                    if (currentToken.Length > 0)
                    {
                        tokens.Add(currentToken.ToString());
                        currentToken.Clear();
                    }
                    inNumber = false;
                }
                else if (char.IsLetter(c) && c != '.' && c != '-')
                {
                    if (currentToken.Length > 0)
                    {
                        tokens.Add(currentToken.ToString());
                        currentToken.Clear();
                    }
                    currentToken.Append(c);
                    tokens.Add(currentToken.ToString());
                    currentToken.Clear();
                    inNumber = false;
                }
                else if (c == '-' && inNumber)
                {
                    // Negative sign in the middle of tokens indicates a new number
                    if (currentToken.Length > 0)
                    {
                        tokens.Add(currentToken.ToString());
                        currentToken.Clear();
                    }
                    currentToken.Append(c);
                    inNumber = true;
                }
                else
                {
                    // Number or decimal point or negative sign at start
                    currentToken.Append(c);
                    inNumber = true;
                }
            }
            // Add the last token
            if (currentToken.Length > 0)
            {
                tokens.Add(currentToken.ToString());
            }
            return tokens;
        }
        private bool TryParseDouble(string value, out double result)
        {
            // Handle culture-specific formatting
            return double.TryParse(value,
                System.Globalization.NumberStyles.Float,
                System.Globalization.CultureInfo.InvariantCulture,
                out result);
        }
        private bool IsCommandToken(string token)
        {
            if (string.IsNullOrEmpty(token)) return false;
            char firstChar = token[0];
            return "MLHVCSQTAZ".Contains(char.ToUpper(firstChar));
        }
        private int GetParameterCountForCommand(string command)
        {
            if (string.IsNullOrEmpty(command)) return 0;
            return char.ToUpper(command[0]) switch
            {
                'M' or 'L' or 'T' => 2,  // Move, Line, Smooth Quadratic
                'H' or 'V' => 1,         // Horizontal, Vertical
                'S' or 'Q' => 4,         // Smooth Curve, Quadratic
                'C' => 6,                // Curve
                'A' => 7,                // Arc
                'Z' => 0,                // Close path
                _ => 0
            };
        }
        #endregion
        #region Enhanced Style Parsing
        private ODSvgStyle ParseStyle(XElement element, string? layerId = null, ODSvgStyle? parentStyle = null)
        {
            var style = parentStyle ?? new ODSvgStyle();
            // Apply layer style if layer ID is provided
            if (layerId != null && _layers.TryGetValue(layerId, out var layer))
            {
                style.StrokeColor = layer.Color;
                style.StrokeWidth = layer.LineWeight;
                style.LineType = layer.LineType;
                style.LayerName = layer.Name;
                style.IsVisible = layer.Visible;
                style.IsLocked = layer.Locked;
            }
            // Parse element-specific style attributes
            var styleAttr = element.Attribute("style")?.Value;
            if (!string.IsNullOrEmpty(styleAttr))
            {
                var styleParts = styleAttr.Split(';');
                foreach (var part in styleParts)
                {
                    var keyValue = part.Split(':');
                    if (keyValue.Length == 2)
                    {
                        var key = keyValue[0].Trim();
                        var value = keyValue[1].Trim();
                        switch (key)
                        {
                            case "stroke":
                                style.StrokeColor = ParseColor(value);
                                break;
                            case "stroke-width":
                                if (ParseDouble(value) is double strokeWidth)
                                    style.StrokeWidth = strokeWidth;
                                break;
                            case "stroke-dasharray":
                                style.LineType = ParseLineType(value);
                                break;
                            case "fill":
                                style.FillColor = ParseColor(value);
                                break;
                        }
                    }
                }
            }
            // Parse individual attributes (override style attribute)
            var strokeAttr = element.Attribute("stroke")?.Value;
            if (!string.IsNullOrEmpty(strokeAttr))
                style.StrokeColor = ParseColor(strokeAttr);
            var strokeWidthAttr = element.Attribute("stroke-width")?.Value;
            if (!string.IsNullOrEmpty(strokeWidthAttr) && ParseDouble(strokeWidthAttr) is double sw)
                style.StrokeWidth = sw;
            var fillAttr = element.Attribute("fill")?.Value;
            if (!string.IsNullOrEmpty(fillAttr))
                style.FillColor = ParseColor(fillAttr);
            return style;
        }
        private void ApplyCADMetadata(ODElement element, XElement xmlElement)
        {
            // Extract CAD-specific attributes
            var cadType = xmlElement.Attribute(_cadNs + "type")?.Value;
            var cadLayer = xmlElement.Attribute(_cadNs + "layer-id")?.Value;
            var isBlockRef = xmlElement.Attribute(_cadNs + "blockref")?.Value == "true";
            // Store CAD metadata in your element
            // This depends on your ODElement implementation
            // You might want to add CADMetadata property to ODElement
        }
        #endregion
        #region Utility Methods (Original + Enhanced)
        private DateTime? ParseDateTime(string value)
        {
            if (string.IsNullOrEmpty(value)) return null;
            return DateTime.TryParse(value, System.Globalization.CultureInfo.InvariantCulture,
                System.Globalization.DateTimeStyles.None, out DateTime result) ? result : null;
        }
        private ODColour ParseColor(string colorValue)
        {
            if (string.IsNullOrEmpty(colorValue) || colorValue == "none")
                return ODColour.Transparent;
            // Handle rgb() format
            if (colorValue.StartsWith("rgb("))
            {
                var parts = colorValue.Substring(4, colorValue.Length - 5).Split(',');
                if (parts.Length == 3 &&
                    byte.TryParse(parts[0], out byte r) &&
                    byte.TryParse(parts[1], out byte g) &&
                    byte.TryParse(parts[2], out byte b))
                {
                    return new ODColour(r, g, b);
                }
            }
            // Handle hex colors
            if (colorValue.StartsWith("#"))
            {
                try
                {
                    return new ODColour(colorValue);
                }
                catch
                {
                    // Fall through to named colors
                }
            }
            // Handle named colors
            return colorValue.ToLower() switch
            {
                "black" => ODColour.Black,
                "red" => ODColour.Red,
                "green" => ODColour.Green,
                "blue" => ODColour.Blue,
                "white" => ODColour.White,
                _ => ODColour.Black // Default
            };
        }
        private string ParseLineType(string dashArray)
        {
            if (string.IsNullOrEmpty(dashArray) || dashArray == "none")
                return "Continuous";
            // Simple dash array parsing
            var parts = dashArray.Split(',');
            if (parts.Length >= 2 &&
                ParseDouble(parts[0]) is double dash &&
                ParseDouble(parts[1]) is double gap)
            {
                if (dash == 10 && gap == 5) return "Dashed";
                if (dash == 2 && gap == 5) return "Dotted";
                // Add more patterns as needed
            }
            return "Continuous";
        }
        private double? ParseDouble(string value)
        {
            if (string.IsNullOrEmpty(value)) return null;
            // Remove units if present
            value = value.Trim().ToLower();
            if (value.EndsWith("px")) value = value[..^2];
            else if (value.EndsWith("mm"))
            {
                value = value[..^2];
                if (double.TryParse(value, System.Globalization.NumberStyles.Any,
                    System.Globalization.CultureInfo.InvariantCulture, out double mm))
                    return mm * 3.779527559;
                return null;
            }
            // Add other unit conversions as needed
            if (double.TryParse(value, System.Globalization.NumberStyles.Any,
                System.Globalization.CultureInfo.InvariantCulture, out double result))
                return result;
            return null;
        }
        private double ParseDimension(string value)
        {
            if (string.IsNullOrEmpty(value)) return 0;
            // Remove units and parse
            value = value.Trim().ToLower();
            // Handle common units
            if (value.EndsWith("px")) value = value[..^2];
            else if (value.EndsWith("pt")) value = value[..^2];
            else if (value.EndsWith("mm"))
            {
                value = value[..^2];
                if (double.TryParse(value, System.Globalization.NumberStyles.Any,
                    System.Globalization.CultureInfo.InvariantCulture, out double mm))
                    return mm * 3.779527559; // Convert mm to pixels
            }
            else if (value.EndsWith("cm"))
            {
                value = value[..^2];
                if (double.TryParse(value, System.Globalization.NumberStyles.Any,
                    System.Globalization.CultureInfo.InvariantCulture, out double cm))
                    return cm * 37.795275591; // Convert cm to pixels
            }
            else if (value.EndsWith("in"))
            {
                value = value[..^2];
                if (double.TryParse(value, System.Globalization.NumberStyles.Any,
                    System.Globalization.CultureInfo.InvariantCulture, out double inches))
                    return inches * 96; // Convert inches to pixels
            }
            return double.TryParse(value, System.Globalization.NumberStyles.Any,
                System.Globalization.CultureInfo.InvariantCulture, out double result) ? result : 0;
        }
        private (double Width, double Height)? ParseViewBox(string viewBoxValue)
        {
            if (string.IsNullOrEmpty(viewBoxValue)) return null;
            var parts = viewBoxValue.Split(new[] { ' ', ',' }, StringSplitOptions.RemoveEmptyEntries);
            if (parts.Length >= 4 &&
                double.TryParse(parts[2], System.Globalization.NumberStyles.Any,
                    System.Globalization.CultureInfo.InvariantCulture, out double width) &&
                double.TryParse(parts[3], System.Globalization.NumberStyles.Any,
                    System.Globalization.CultureInfo.InvariantCulture, out double height))
            {
                return (width, height);
            }
            return null;
        }
        #endregion
        #region Properties and Public Methods
        public CADMetadata Metadata => _metadata;
        public IReadOnlyDictionary<string, CADLayer> Layers => _layers;
        public bool IsLoaded => _xDocument != null;
        public ODVec2 GetDimensions()
        {
            if (_xDocument == null)
                throw new InvalidOperationException("No SVG file loaded. Call LoadSvgFile first.");
            var svgElement = _xDocument.Root;
            var width = ParseDimension(svgElement.Attribute("width")?.Value);
            var height = ParseDimension(svgElement.Attribute("height")?.Value);
            // Fallback to viewBox if dimensions aren't found
            if (width == 0 || height == 0)
            {
                var viewBox = ParseViewBox(svgElement.Attribute("viewBox")?.Value);
                if (viewBox.HasValue)
                {
                    width = width == 0 ? viewBox.Value.Width : width;
                    height = height == 0 ? viewBox.Value.Height : height;
                }
            }
            Debug.WriteLine($"SVG Dimensions: Width={width}, Height={height}");
            return new ODVec2(width, height);
        }
        public void Unload()
        {
            _xDocument = null;
            _filePath = null;
            _layers.Clear();
            _blockDefinitions.Clear();
            _metadata = new CADMetadata();
        }
        #endregion
    }
    public class CADMetadata
    {
        public string? AppVersion { get; set; }
        public string? FileVersion { get; set; }
        public string? Units { get; set; }
        public double Precision { get; set; }
        public string? Application { get; set; }
        public string? Version { get; set; }
        public DateTime? Created { get; set; }
        public DateTime? Modified { get; set; }
        public string? Title { get; set; }
        public string? Creator { get; set; }
        public string? Description { get; set; }
        public Dictionary<string, string>? Properties { get; set; }
    }
}