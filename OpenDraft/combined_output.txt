

** Viewport.axaml.cs **
Path: D:\OpenDraft\OpenDraft\ODCore\Viewport.axaml.cs

using Avalonia;
using Avalonia.Controls;
using Avalonia.Input;
using Avalonia.Media;
using Avalonia.Threading;
using OpenDraft.ODCore.ODData;
using OpenDraft.ODCore.ODEditor;
using OpenDraft.ODCore.ODEditor.ODDynamics;
using OpenDraft.ODCore.ODGeometry;
using System;
using System.Collections.ObjectModel;
using System.Diagnostics;
namespace OpenDraft
{
    public partial class Viewport : UserControl
    {
        public static readonly StyledProperty<ObservableCollection<ODElement>> ElementsProperty =
            AvaloniaProperty.Register<Viewport, ObservableCollection<ODElement>>(nameof(Elements));
        public static readonly StyledProperty<ODDrawConnector> DrawConnectorProperty =
            AvaloniaProperty.Register<Viewport, ODDrawConnector>(nameof(DrawConnector));
        public static readonly StyledProperty<IODEditorInputService> InputServiceProperty =
            AvaloniaProperty.Register<Viewport, IODEditorInputService>(nameof(InputService));
        public static readonly StyledProperty<ObservableCollection<ODDynamicElement>> DynamicElementsProperty =
            AvaloniaProperty.Register<Viewport, ObservableCollection<ODDynamicElement>>(nameof(DynamicElements));
        public ObservableCollection<ODElement> Elements
        {
            get => GetValue(ElementsProperty);
            set => SetValue(ElementsProperty, value);
        }
        public ODDrawConnector DrawConnector
        {
            get => GetValue(DrawConnectorProperty);
            set => SetValue(DrawConnectorProperty, value);
        }
        public IODEditorInputService InputService
        {
            get => GetValue(InputServiceProperty);
            set => SetValue(InputServiceProperty, value);
        }
        public ObservableCollection<ODDynamicElement> DynamicElements
        {
            get => GetValue(DynamicElementsProperty);
            set => SetValue(DynamicElementsProperty, value);
        }
        private readonly ViewportCamera Camera = new();
        private bool isPanning = false;
        private Point _lastPointerDragPosition;
        private Point _mousePosition;
        private Size _lastSize;
        private bool _isInitialized = false;
        public Viewport()
        {
            InitializeComponent();
            Background = Brushes.Transparent;
            Elements ??= new ObservableCollection<ODElement>();
            DynamicElements ??= new ObservableCollection<ODDynamicElement>();
            SubscribeToCollection(Elements, OnElementsChanged);
            SubscribeToCollection(DynamicElements, OnDynamicElementsChanged);
            PointerPressed += OnPointerPressed;
            PointerReleased += OnPointerReleased;
            PointerMoved += OnPointerMoved;
            PointerWheelChanged += OnPointerWheelChanged;
            PointerEntered += OnPointerEntered;
            PointerExited += OnPointerExited;
            SetupStaticCanvas();
            SetupDynamicCanvas();
        }
        private void SubscribeToCollection<T>(ObservableCollection<T> collection, System.Collections.Specialized.NotifyCollectionChangedEventHandler handler)
        {
            if (collection == null) return;
            collection.CollectionChanged -= handler;
            collection.CollectionChanged += handler;
        }
        private void OnElementsChanged(object? sender, System.Collections.Specialized.NotifyCollectionChangedEventArgs e)
        {
            StaticCanvas?.InvalidateVisual();
        }
        private void OnDynamicElementsChanged(object? sender, System.Collections.Specialized.NotifyCollectionChangedEventArgs e)
        {
            DynamicCanvas?.InvalidateVisual();
        }
        private void SetupStaticCanvas()
        {
            StaticCanvas.OnRender = (context, bounds) =>
            {
                if (Elements == null) return;
                var matrix = Camera.GetMatrix(bounds.Height);
                using (context.PushTransform(matrix))
                {
                    foreach (var element in Elements)
                    {
                        var layer = DrawConnector.GetLayerByID(element.LayerId);
                        if (layer != null)
                            element.Draw(context, DrawConnector);
                    }
                }
            };
            StaticCanvas.InvalidateVisual();
        }
        private void SetupDynamicCanvas()
        {
            DynamicCanvas.OnRender = (context, bounds) =>
            {
                if (DynamicElements == null) return;
                ODPoint vpWorldSize = new ODPoint(bounds.Width / Camera.Scale, bounds.Height / Camera.Scale);
                ODPoint worldMousePoint = new ODPoint(GetWorldMousePosition().X, GetWorldMousePosition().Y);
                var matrix = Camera.GetMatrix(bounds.Height);
                using (context.PushTransform(matrix))
                {
                    if (DynamicElements != null)
                        foreach (ODDynamicElement element in DynamicElements)
                        {
                            ODLayer? layer = DrawConnector.GetLayerByID(element.LayerId);
                            if (layer != null) element.Draw(context, DrawConnector, Camera.Scale, vpWorldSize, worldMousePoint);
                        }
                }
            };
            var timer = new DispatcherTimer { Interval = TimeSpan.FromMilliseconds(16) };
            timer.Tick += (_, _) => DynamicCanvas?.InvalidateVisual();
            timer.Start();
        }
        protected override Size ArrangeOverride(Size finalSize)
        {
            if (!_isInitialized)
            {
                _isInitialized = true;
                Camera.Position = new Point(-finalSize.Width / 2 / Camera.Scale, -finalSize.Height / 2 / Camera.Scale);
            }
            else
            {
                Camera.Position -= new Vector(
                    (finalSize.Width - _lastSize.Width) / 2 / Camera.Scale,
                    (finalSize.Height - _lastSize.Height) / 2 / Camera.Scale);
            }
            _lastSize = finalSize;
            StaticCanvas?.InvalidateVisual();
            return base.ArrangeOverride(finalSize);
        }
        protected override void OnPropertyChanged(AvaloniaPropertyChangedEventArgs change)
        {
            base.OnPropertyChanged(change);
            if (!_isInitialized) return;
            if (change.Property == ElementsProperty)
                SubscribeToCollection(Elements, OnElementsChanged);
            else if (change.Property == DynamicElementsProperty)
                SubscribeToCollection(DynamicElements, OnDynamicElementsChanged);
            StaticCanvas?.InvalidateVisual();
            DynamicCanvas?.InvalidateVisual();
        }
        private void OnPointerPressed(object? sender, PointerPressedEventArgs e)
        {
            if (e.GetCurrentPoint(this).Properties.IsMiddleButtonPressed)
            {
                _lastPointerDragPosition = e.GetPosition(this);
                isPanning = true;
            }
        }
        private void OnPointerReleased(object? sender, PointerReleasedEventArgs e)
        {
            if (e.InitialPressMouseButton == MouseButton.Left)
            {
                var odPoint = new ODPoint(GetWorldMousePosition().X, GetWorldMousePosition().Y);
                InputService?.RaisePointProvided(odPoint);
                e.Handled = true;
            }
            if (e.InitialPressMouseButton == MouseButton.Middle)
                isPanning = false;
        }
        private void OnPointerMoved(object? sender, PointerEventArgs e)
        {
            _mousePosition = e.GetPosition(this);
            DynamicCanvas?.InvalidateVisual();
            if (!isPanning) return;
            var current = e.GetPosition(this);
            Camera.MoveBy(new Vector(-(current.X - _lastPointerDragPosition.X) / Camera.Scale,
                                     (current.Y - _lastPointerDragPosition.Y) / Camera.Scale));
            _lastPointerDragPosition = current;
            StaticCanvas?.InvalidateVisual();
        }
        private void OnPointerEntered(object? sender, PointerEventArgs e)
        {
            DrawConnector.ShowCrosshair(true);
        }
        private void OnPointerExited(object? sender, PointerEventArgs e)
        {
            DrawConnector.ShowCrosshair(false);
        }
        private void OnPointerWheelChanged(object? sender, PointerWheelEventArgs e)
        {
            var mousePos = e.GetPosition(this);
            float zoomFactor = 1.1f;
            float oldScale = Camera.Scale;
            float newScale = oldScale * (float)Math.Pow(zoomFactor, e.Delta.Y > 0 ? 1 : -1);
            Point ScreenToWorld(Point screen, float scale) =>
                new(screen.X / scale - Camera.Position.X, (Bounds.Height - screen.Y) / scale - Camera.Position.Y);
            var oldWorld = ScreenToWorld(mousePos, oldScale);
            var newWorld = ScreenToWorld(mousePos, newScale);
            Camera.Position += oldWorld - newWorld; // <--- fix here
            Camera.Scale = newScale;
            StaticCanvas?.InvalidateVisual();
            DynamicCanvas?.InvalidateVisual();
        }
        public Point GetScreenMousePosition() => _mousePosition;
        public Point GetWorldMousePosition() =>
            new Point(_mousePosition.X / Camera.Scale + Camera.Position.X,
                      (Bounds.Height - _mousePosition.Y) / Camera.Scale + Camera.Position.Y);
    }
}


** ODDrawConnector.cs **
Path: D:\OpenDraft\OpenDraft\ODCore\ODData\ODDrawConnector.cs

ï»¿using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading.Tasks;
using Avalonia.Media;
using OpenDraft.ODCore.ODEditor;
namespace OpenDraft.ODCore.ODData
{
    public class ODDrawConnector
    {
        private ODDataManager DataManager;
        private ODEditor.ODEditor? Editor;
        public ODDrawConnector(ODDataManager dm, ODEditor.ODEditor ed)
        {
            DataManager = dm;
            Editor = ed;
        }
        public ODLayer? GetLayerByName(string name) {
            return this.DataManager.LayerManager.GetLayerByName(name);
        }
        public ODLayer? GetLayerByID(ushort id) {
            return this.DataManager.LayerManager.GetLayerByID(id);
        }
        public IDashStyle ToAvaloniaDashStyle(string dashStyle)
        {
            return DataManager.LineStyleRegister.ToAvaloniaDashStyle(dashStyle);
        }
        public void ShowCrosshair(bool state)
        {
            if (Editor == null)
                return;
            if (state)
                Editor.ShowCrosshair();
            else
                Editor.HideCrosshair();
        }
    }
}


** ODCrosshair.cs **
Path: D:\OpenDraft\OpenDraft\ODCore\ODEditor\ODDynamics\ODCrosshair.cs

ï»¿using Avalonia;
using Avalonia.Media;
using OpenDraft;
using OpenDraft.ODCore.ODData;
using OpenDraft.ODCore.ODGeometry;
using System;
namespace OpenDraft.ODCore.ODEditor.ODDynamics
{
    public class ODCrosshairElement : ODDynamicElement
    {
        // Visibility
        public bool IsVisible { get; set; } = true;
        // Style properties
        private int _size = 10;
        public int Size
        {
            get => _size;
            set => _size = value;
        }
        public ODCrosshairElement()
        {
        }
        public override void Draw(DrawingContext context, ODDrawConnector connector,
            float scale, ODPoint vpWorldSize, ODPoint worldMousePosition)
        {
            if (!IsVisible)
                return;
            ODLayer? layer = connector.GetLayerByID(LayerId);
            // Get layer
            ODPoint Center = worldMousePosition;
            float cSize = Size / scale; // Centre square size
            // Get styles from registry
            Color xColour = Avalonia.Media.Color.Parse(ODSystem.GetRegistryValueAsString("style/crosshair_x_colour") ?? "Red");
            Color yColour = Avalonia.Media.Color.Parse(ODSystem.GetRegistryValueAsString("style/crosshair_y_colour") ?? "Lime");
            Color sqColour = Avalonia.Media.Color.Parse(ODSystem.GetRegistryValueAsString("style/crosshair_sq_colour") ?? "White");
            float xThickness = ODSystem.GetRegistryValueAsDecimal("style/crosshair_line_weight") ?? 1;
            Pen xPen = new Pen(new SolidColorBrush(xColour), xThickness / scale);
            Pen yPen = new Pen(new SolidColorBrush(yColour), xThickness / scale);
            Pen sqPen = new Pen(new SolidColorBrush(sqColour), xThickness / scale);
            // Centre square
            context.DrawRectangle(null, sqPen,
                new Rect(
                    new Point(Center.X - cSize / 2, Center.Y - cSize / 2),
                    new Size(cSize, cSize)
                ));
            var top = new Point(Center.X, Center.Y + vpWorldSize.Y);
            var bottom = new Point(Center.X, Center.Y - vpWorldSize.Y);
            var left = new Point(Center.X - vpWorldSize.X, Center.Y);
            var right = new Point(Center.X + vpWorldSize.X, Center.Y);
            context.DrawLine(yPen, top, new Point(Center.X, Center.Y + cSize / 2)); // Top
            context.DrawLine(xPen, left, new Point(Center.X - cSize / 2, Center.Y)); // Left
            context.DrawLine(yPen, new Point(Center.X, Center.Y - cSize / 2), bottom); // Bottom
            context.DrawLine(xPen, new Point(Center.X + cSize / 2, Center.Y), right); // Right
        }
    }
}


** ODDynamicElement.cs **
Path: D:\OpenDraft\OpenDraft\ODCore\ODEditor\ODDynamics\ODDynamicElement.cs

ï»¿using Avalonia;
using Avalonia.Media;
using OpenDraft.ODCore.ODData;
using OpenDraft.ODCore.ODGeometry;
using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading.Tasks;
namespace OpenDraft.ODCore.ODEditor.ODDynamics
{
    public class ODDynamicElement
    {
        public Guid Id { get; set; }
        public string Color { get; set; } = "#FF0000";
        public float LineWeight { get; set; } = 2.0f;
        public ushort LayerId { get; set; } = 0; // Default layer ID
        public ODDynamicElement()
        {
            Id = Guid.NewGuid();
        }
        public virtual void Draw(DrawingContext context, ODDrawConnector connector, 
            float scale, ODPoint vpWorldSize, ODPoint mousePosition)
        {
            // Base draw method, to be overridden by derived classes
        }
    }
}


** ODRubberBandLine.cs **
Path: D:\OpenDraft\OpenDraft\ODCore\ODEditor\ODDynamics\ODRubberBandLine.cs

ï»¿using Avalonia;
using Avalonia.Media;
using OpenDraft.ODCore.ODData;
using OpenDraft.ODCore.ODGeometry;
using System;
using System.Diagnostics;
namespace OpenDraft.ODCore.ODEditor.ODDynamics
{
    public class ODRubberBandLine : ODDynamicElement
    {
        public ODPoint Start { get; set; }
        public float Weight { get; set; } = 1.0f;
        public ODRubberBandLine(ODPoint start)
        {
            Start = start;
        }
        public override void Draw(DrawingContext context, ODDrawConnector connector,
            float scale, ODPoint vpWorldSize, ODPoint mousePosition)
        {
            ODLayer? layer = connector.GetLayerByID(LayerId);
            if (layer == null || !layer.IsVisible || layer.Color == null)
                return;
            Pen pen = new Pen(new SolidColorBrush(Avalonia.Media.Color.Parse(layer.Color)), 
                layer.LineWeight, connector.ToAvaloniaDashStyle(layer.LineType));
            context.DrawLine(pen, new Point(Start.X, Start.Y), new Point(mousePosition.X, mousePosition.Y));
        }
    }
}


** ODSnapIndicatorElement.cs **
Path: D:\OpenDraft\OpenDraft\ODCore\ODEditor\ODDynamics\ODSnapIndicatorElement.cs

ï»¿using Avalonia;
using Avalonia.Media;
using OpenDraft.ODCore.ODData;
using OpenDraft.ODCore.ODGeometry;
using System;
namespace OpenDraft.ODCore.ODEditor.ODDynamics
{
    public class SnapIndicatorElement : ODDynamicElement
    {
        public ODPoint Position { get; set; }
        public double Radius { get; set; } = 5.0;
        public SnapIndicatorElement(ODPoint position)
        {
            Position = position;
        }
        public override void Draw(DrawingContext context, ODDrawConnector connector, 
            float scale, ODPoint vpExtents, ODPoint worldMousePosition)
        {
            var brush = new SolidColorBrush(Colors.Yellow);
            var pen = new Pen(brush, 1.5);
            context.DrawEllipse(null, pen,
                new Point(Position.X, Position.Y),
                Radius, Radius);
        }
    }
}


** ODCircle.cs **
Path: D:\OpenDraft\OpenDraft\ODCore\ODGeometry\ODCircle.cs

ï»¿using Avalonia;
using Avalonia.Media;
using OpenDraft.ODCore.ODData;
using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading.Tasks;
namespace OpenDraft.ODCore.ODGeometry
{
    internal class ODCircle : ODElement
    {
        public ODPoint Center { get; set; }
        public double Radius { get; set; }
        public ODCircle(ODPoint center, double radius)
        {
            Center = center;
            Radius = radius;
        }
        public override void Draw(DrawingContext context, ODDrawConnector connector)
        {
            ODLayer? layer = connector.GetLayerByID(LayerId);
            if (layer != null && !layer.IsVisible)
                return;
            if (layer == null)
                return;
            // Get dash style from registry
            var dashStyle = connector.ToAvaloniaDashStyle(LineType ?? layer.LineType);
            string effectiveColour = (Colour != null) ? Colour.ToHex() : layer.Color;
            float effectiveLineWeight = LineWeight ?? layer.LineWeight;
            // Create pen
            var pen = new Pen(
                new SolidColorBrush(Color.Parse(effectiveColour)), // Brush only
                effectiveLineWeight,                               // Thickness
                dashStyle                                          // Dash style
            );
            context.DrawEllipse(null, pen, new Point(Center.X, Center.Y), Radius, Radius);
        }
    }
}


** ODElement.cs **
Path: D:\OpenDraft\OpenDraft\ODCore\ODGeometry\ODElement.cs

ï»¿using Avalonia;
using Avalonia.Media;
using OpenDraft.ODCore.ODData;
using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading.Tasks;
namespace OpenDraft.ODCore.ODGeometry
{
    public class ODElement
    {
        public Guid Id { get; set; }
        public ushort LayerId { get; set; } = 0; // Default layer ID
        public ODColour? Colour { get; set; } = null; // If null, use layer colour
        public float? LineWeight { get; set; } = null; // If null, use layer lineweight
        public string? LineType { get; set; } = null; // If null, use layer linetype
        public ODElement()
        {
            Id = Guid.NewGuid();
        }
        public virtual void Draw(DrawingContext context, ODDrawConnector connector)
        {
            // Base draw method, to be overridden by derived classes
        }
    }
}


** ODLine.cs **
Path: D:\OpenDraft\OpenDraft\ODCore\ODGeometry\ODLine.cs

ï»¿using Avalonia;
using Avalonia.Media;
using Microsoft.Win32;
using OpenDraft.ODCore.ODData;
using System;
namespace OpenDraft.ODCore.ODGeometry
{
    internal class ODLine : ODElement
    {
        public ODPoint StartPoint { get; set; }
        public ODPoint EndPoint { get; set; }
        public ODLine(ODPoint startPoint, ODPoint endPoint)
        {
            StartPoint = startPoint;
            EndPoint = endPoint;
        }
        public override void Draw(DrawingContext context, ODDrawConnector connector)
        {
            ODLayer? layer = connector.GetLayerByID(LayerId);
            if (layer != null && !layer.IsVisible)
                return;
            if (layer == null)
                return;
            // Get dash style from registry
            var dashStyle = connector.ToAvaloniaDashStyle(LineType ?? layer.LineType);
            string effectiveColour = (Colour != null) ? Colour.ToHex() : layer.Color;
            float effectiveLineWeight = LineWeight ?? layer.LineWeight;
            // Create pen
            Pen pen = new Pen(
                new SolidColorBrush(Color.Parse(effectiveColour)), // Brush only
                effectiveLineWeight,                               // Thickness
                dashStyle                                          // Dash style
            );
            context.DrawLine(pen,
                    new Point(StartPoint.X, StartPoint.Y),
                    new Point(EndPoint.X, EndPoint.Y));
        }
    }
}


** ODPolyline.cs **
Path: D:\OpenDraft\OpenDraft\ODCore\ODGeometry\ODPolyline.cs

ï»¿using Avalonia;
using Avalonia.Media;
using Microsoft.Win32;
using OpenDraft.ODCore.ODData;
using System;
using System.Collections.Generic;
using System.Linq;
namespace OpenDraft.ODCore.ODGeometry
{
    public class ODPolyline : ODElement
    {
        public List<ODPoint> Points { get; set; }
        public ODPolyline(List<ODPoint> points)
        {
            Points = points ?? new List<ODPoint>();
        }
        public override void Draw(DrawingContext context, ODDrawConnector connector)
        {
            ODLayer? layer = connector.GetLayerByID(LayerId);
            if (layer != null && !layer.IsVisible)
                return;
            if (layer == null)
                return;
            if (Points == null || Points.Count < 2)
                return;
            // Get dash style from registry
            var dashStyle = connector.ToAvaloniaDashStyle(LineType ?? layer.LineType);
            string effectiveColour = (Colour != null) ? Colour.ToHex() : layer.Color;
            float effectiveLineWeight = LineWeight ?? layer.LineWeight;
            // Create pen for the outline
            Pen pen = new Pen(
                new SolidColorBrush(Color.Parse(effectiveColour)), // Brush only
                effectiveLineWeight,                               // Thickness
                dashStyle                                          // Dash style
            );
            // Draw each segment individually
            for (int i = 1; i < Points.Count; i++)
            {
                context.DrawLine(pen,
                    new Point(Points[i - 1].X, Points[i - 1].Y),
                    new Point(Points[i].X, Points[i].Y));
            }
        }
        // Optional: Add convenience properties and methods
        public bool IsClosed => Points.Count > 2 && Points[0].Equals(Points[Points.Count - 1]);
        public double Length
        {
            get
            {
                if (Points.Count < 2) return 0;
                double length = 0;
                for (int i = 1; i < Points.Count; i++)
                {
                    length += Math.Sqrt(
                        Math.Pow(Points[i].X - Points[i - 1].X, 2) +
                        Math.Pow(Points[i].Y - Points[i - 1].Y, 2));
                }
                return length;
            }
        }
        public ODPoint StartPoint => Points?.FirstOrDefault() ?? new ODPoint(0, 0);
        public ODPoint EndPoint => Points?.LastOrDefault() ?? new ODPoint(0, 0);
        public void AddPoint(ODPoint point)
        {
            Points.Add(point);
        }
        public void InsertPoint(int index, ODPoint point)
        {
            if (index >= 0 && index <= Points.Count)
                Points.Insert(index, point);
        }
        public void RemovePoint(int index)
        {
            if (index >= 0 && index < Points.Count)
                Points.RemoveAt(index);
        }
        public ODRectangle GetBoundingBox()
        {
            if (Points == null || Points.Count == 0)
                return new ODRectangle(new ODPoint(0, 0), new ODPoint(0, 0));
            double minX = Points.Min(p => p.X);
            double maxX = Points.Max(p => p.X);
            double minY = Points.Min(p => p.Y);
            double maxY = Points.Max(p => p.Y);
            return new ODRectangle(new ODPoint(minX, minY), new ODPoint(maxX, maxY));
        }
    }
}

** ODRectangle.cs **
Path: D:\OpenDraft\OpenDraft\ODCore\ODGeometry\ODRectangle.cs

ï»¿using Avalonia;
using Avalonia.Media;
using OpenDraft.ODCore.ODData;
using System;
using System.Collections.Generic;
using System.Linq;
using System.Xml.Linq;
namespace OpenDraft.ODCore.ODGeometry
{
    public class ODRectangle : ODElement
    {
        public ODPoint TopLeft { get; set; }
        public ODPoint BottomRight { get; set; }
        public ODRectangle(ODPoint topLeft, ODPoint bottomRight)
        {
            TopLeft = topLeft;
            BottomRight = bottomRight;
        }
        // Alternative constructor from center point and dimensions
        public ODRectangle(ODPoint center, double width, double height)
        {
            var halfWidth = width / 2;
            var halfHeight = height / 2;
            TopLeft = new ODPoint(center.X - halfWidth, center.Y - halfHeight);
            BottomRight = new ODPoint(center.X + halfWidth, center.Y + halfHeight);
        }
        // Alternative constructor from corner point and dimensions
        public ODRectangle(ODPoint corner, double width, double height, bool isTopLeft = true)
        {
            if (isTopLeft)
            {
                TopLeft = corner;
                BottomRight = new ODPoint(corner.X + width, corner.Y + height);
            }
            else
            {
                BottomRight = corner;
                TopLeft = new ODPoint(corner.X - width, corner.Y - height);
            }
        }
        public override void Draw(DrawingContext context, ODDrawConnector connector)
        {
            ODLayer? layer = connector.GetLayerByID(LayerId);
            if (layer != null && !layer.IsVisible)
                return;
            if (layer == null)
                return;
            // Get dash style from registry
            var dashStyle = connector.ToAvaloniaDashStyle(LineType ?? layer.LineType);
            string effectiveColour = (Colour != null) ? Colour.ToHex() : layer.Color;
            float effectiveLineWeight = LineWeight ?? layer.LineWeight;
            // Create pen for the outline
            Pen pen = new Pen(
                new SolidColorBrush(Color.Parse(effectiveColour)), // Brush only
                effectiveLineWeight,                               // Thickness
                dashStyle                                          // Dash style
            );
            // Create rectangle geometry
            Rect rect = new Rect(
                new Point(TopLeft.X, TopLeft.Y),
                new Point(BottomRight.X, BottomRight.Y)
            );
            // Draw the rectangle
            context.DrawRectangle(pen, rect);
        }
        // Properties for convenience
        public double X => TopLeft.X;
        public double Y => TopLeft.Y;
        public double Width => Math.Abs(BottomRight.X - TopLeft.X);
        public double Height => Math.Abs(BottomRight.Y - TopLeft.Y);
        public ODPoint TopRight => new ODPoint(BottomRight.X, TopLeft.Y);
        public ODPoint BottomLeft => new ODPoint(TopLeft.X, BottomRight.Y);
        public ODPoint Center => new ODPoint(
            (TopLeft.X + BottomRight.X) / 2,
            (TopLeft.Y + BottomRight.Y) / 2
        );
        public double Area => Width * Height;
        public double Perimeter => 2 * (Width + Height);
        // Method to check if a point is inside the rectangle
        public bool ContainsPoint(ODPoint point)
        {
            var minX = Math.Min(TopLeft.X, BottomRight.X);
            var maxX = Math.Max(TopLeft.X, BottomRight.X);
            var minY = Math.Min(TopLeft.Y, BottomRight.Y);
            var maxY = Math.Max(TopLeft.Y, BottomRight.Y);
            return point.X >= minX && point.X <= maxX &&
                   point.Y >= minY && point.Y <= maxY;
        }
        // Convert to polyline (useful for some operations)
        public ODPolyline ToPolyline()
        {
            var points = new List<ODPoint>
            {
                TopLeft,
                TopRight,
                BottomRight,
                BottomLeft,
                TopLeft // Close the rectangle
            };
            return new ODPolyline(points);
        }
        // Get bounding box (for compatibility with other geometry)
        public ODRectangle GetBoundingBox()
        {
            return this; // A rectangle is its own bounding box
        }
        // SVG export support
        public XElement ToSvgElement(ODLayer layer, ODLineStyleRegistry registry)
        {
            var element = new XElement("{http://www.w3.org/2000/svg}rect",
                new XAttribute("x", TopLeft.X),
                new XAttribute("y", TopLeft.Y),
                new XAttribute("width", Width),
                new XAttribute("height", Height),
                new XAttribute("fill", "none") // No fill by default
            );
            return element;
        }
        public override string ToString()
        {
            return $"Rectangle [({X:0.##}, {Y:0.##}) {Width:0.##}x{Height:0.##}]";
        }
    }
}

** ODSymbol.cs **
Path: D:\OpenDraft\OpenDraft\ODCore\ODGeometry\ODSymbol.cs

ï»¿using Avalonia.Media;
using OpenDraft.ODCore.ODData;
using OpenDraft.ODCore.ODGeometry;
using System.Collections.Generic;
using System.Net;
namespace OpenDraft.ODCore.ODGeometry
{
    public class ODSymbolDefinition : ODElement
    {
        public string BlockName { get; set; }
        public ODPoint InsertionPoint { get; set; }
        public double Rotation { get; set; }
        public double ScaleX { get; set; } = 1.0;
        public double ScaleY { get; set; } = 1.0;
        public ODSymbolDefinition(string blockName, ODPoint insertionPoint)
        {
            BlockName = blockName;
            InsertionPoint = insertionPoint;
        }
        public override void Draw(DrawingContext context, ODDrawConnector connector)
        {
            ODLayer? layer = connector.GetLayerByID(LayerId);
            if (layer != null && !layer.IsVisible)
                return;
            if (layer == null)
                return;
            // Get dash style from registry
            var dashStyle = connector.ToAvaloniaDashStyle(LineType ?? layer.LineType);
            string effectiveColour = (Colour != null) ? Colour.ToHex() : layer.Color;
            float effectiveLineWeight = LineWeight ?? layer.LineWeight;
            // Create pen
            Pen pen = new Pen(
                new SolidColorBrush(Color.Parse(effectiveColour)), // Brush only
                effectiveLineWeight,                               // Thickness
                dashStyle                                          // Dash style
            );
            //foreach (ODElement element in GetBlockElements(BlockName))
            //{
                //element.Draw(context, lm);
            //}
        }
    }
}

** MainWindowViewModel.cs **
Path: D:\OpenDraft\OpenDraft\ViewModels\MainWindowViewModel.cs

ï»¿using CommunityToolkit.Mvvm.Input;
using OpenDraft.ODCore.ODData;
using OpenDraft.ODCore.ODEditor;
using OpenDraft.ODCore.ODGeometry;
using OpenDraft.XSVG;
using System.Collections.Generic;
using System.Collections.ObjectModel;
using System.Diagnostics;
namespace OpenDraft.ViewModels
{
    public partial class MainWindowViewModel : ViewModelBase
    {
        public ODDataManager DataManagerRoot { get; }
        public IODEditorInputService InputService { get; }
        public ODEditor EditorRoot { get; private set; }
        public ODDrawConnector DrawConnectorRoot { get; }
        public ObservableCollection<ODElement> GeometryElements => DataManager.Elements;
        public ODDataManager DataManager => DataManagerRoot;
        public ODEditor Editor => EditorRoot;
        public ODDrawConnector DrawConnector => DrawConnectorRoot;
        public MainWindowViewModel()
        {
            ODSystem.Initialise();
            // Initialize the DataManager and Editor
            DataManagerRoot = new ODDataManager();
            InputService = new ODEditorInputService();
            EditorRoot = new ODEditor(DataManager, InputService);
            DrawConnectorRoot = new ODDrawConnector(DataManager, Editor);
            // Debug XSVG Reader
            ODXsvgReader xsvgR = new ODXsvgReader("XSVG/Example XSVG/example.xsvg");
            List<ODElement> xsvgElements = xsvgR.ExtractModelSpace();
            foreach (ODElement elem in xsvgElements)
            {
                Editor.AddStaticElement(elem);
            }
            Debug.WriteLine("Setup complete");
        }
        [RelayCommand]
        private void ExecuteEditor(string command)
        {
            EditorRoot.ExecuteCommand(command);
        }
    }
}