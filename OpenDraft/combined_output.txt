

** Viewport.axaml.cs **
Path: D:\OpenDraft\OpenDraft\ODCore\Viewport.axaml.cs

using Avalonia;
using Avalonia.Controls;
using Avalonia.Input;
using Avalonia.Media;
using Avalonia.Threading;
using OpenDraft.ODCore.ODData;
using OpenDraft.ODCore.ODEditor;
using OpenDraft.ODCore.ODEditor.ODDynamics;
using OpenDraft.ODCore.ODGeometry;
using OpenDraft.ODCore.ODMath;
using System;
using System.Collections.ObjectModel;
using System.Diagnostics;
namespace OpenDraft
{
    public partial class Viewport : UserControl
    {
        public static readonly StyledProperty<ObservableCollection<ODElement>> ElementsProperty =
            AvaloniaProperty.Register<Viewport, ObservableCollection<ODElement>>(nameof(Elements));
        public static readonly StyledProperty<ODDrawConnector> DrawConnectorProperty =
            AvaloniaProperty.Register<Viewport, ODDrawConnector>(nameof(DrawConnector));
        public static readonly StyledProperty<IODEditorInputService> InputServiceProperty =
            AvaloniaProperty.Register<Viewport, IODEditorInputService>(nameof(InputService));
        public static readonly StyledProperty<ObservableCollection<ODDynamicElement>> DynamicElementsProperty =
            AvaloniaProperty.Register<Viewport, ObservableCollection<ODDynamicElement>>(nameof(DynamicElements));
        public ObservableCollection<ODElement> Elements
        {
            get => GetValue(ElementsProperty);
            set => SetValue(ElementsProperty, value);
        }
        public ODDrawConnector DrawConnector
        {
            get => GetValue(DrawConnectorProperty);
            set => SetValue(DrawConnectorProperty, value);
        }
        public IODEditorInputService InputService
        {
            get => GetValue(InputServiceProperty);
            set => SetValue(InputServiceProperty, value);
        }
        public ObservableCollection<ODDynamicElement> DynamicElements
        {
            get => GetValue(DynamicElementsProperty);
            set => SetValue(DynamicElementsProperty, value);
        }
        private readonly ViewportCamera Camera = new();
        private bool isPanning = false;
        private Point _lastPointerDragPosition;
        private Point _mousePosition;
        private Size _lastSize;
        private bool _isInitialized = false;
        public Viewport()
        {
            InitializeComponent();
            Background = Brushes.Transparent;
            Elements ??= new ObservableCollection<ODElement>();
            DynamicElements ??= new ObservableCollection<ODDynamicElement>();
            SubscribeToCollection(Elements, OnElementsChanged);
            SubscribeToCollection(DynamicElements, OnDynamicElementsChanged);
            PointerPressed += OnPointerPressed;
            PointerReleased += OnPointerReleased;
            PointerMoved += OnPointerMoved;
            PointerWheelChanged += OnPointerWheelChanged;
            PointerEntered += OnPointerEntered;
            PointerExited += OnPointerExited;
            SetupStaticCanvas();
            SetupDynamicCanvas();
        }
        private void SubscribeToCollection<T>(ObservableCollection<T> collection, System.Collections.Specialized.NotifyCollectionChangedEventHandler handler)
        {
            if (collection == null) return;
            collection.CollectionChanged -= handler;
            collection.CollectionChanged += handler;
        }
        private void OnElementsChanged(object? sender, System.Collections.Specialized.NotifyCollectionChangedEventArgs e)
        {
            StaticCanvas?.InvalidateVisual();
        }
        private void OnDynamicElementsChanged(object? sender, System.Collections.Specialized.NotifyCollectionChangedEventArgs e)
        {
            DynamicCanvas?.InvalidateVisual();
        }
        private void SetupStaticCanvas()
        {
            StaticCanvas.OnRender = (context, bounds) =>
            {
                if (Elements == null) return;
                var matrix = Camera.GetMatrix(bounds.Height);
                using (context.PushTransform(matrix))
                {
                    foreach (var element in Elements)
                    {
                        var layer = DrawConnector.GetLayerByID(element.LayerId);
                        if (layer != null)
                            element.Draw(context, DrawConnector);
                    }
                }
            };
            StaticCanvas.InvalidateVisual();
        }
        private void SetupDynamicCanvas()
        {
            DynamicCanvas.OnRender = (context, bounds) =>
            {
                if (DynamicElements == null) return;
                ODVec2 vpWorldSize = new ODVec2(bounds.Width / Camera.Scale, bounds.Height / Camera.Scale);
                ODVec2 worldMousePoint = new ODVec2(GetWorldMousePosition().X, GetWorldMousePosition().Y);
                var matrix = Camera.GetMatrix(bounds.Height);
                using (context.PushTransform(matrix))
                {
                    if (DynamicElements != null)
                        foreach (ODDynamicElement element in DynamicElements)
                        {
                            ODLayer? layer = DrawConnector.GetLayerByID(element.LayerId);
                            if (layer != null) element.Draw(context, DrawConnector, Camera.Scale, vpWorldSize, worldMousePoint);
                        }
                }
            };
            var timer = new DispatcherTimer { Interval = TimeSpan.FromMilliseconds(16) };
            timer.Tick += (_, _) => DynamicCanvas?.InvalidateVisual();
            timer.Start();
        }
        protected override Size ArrangeOverride(Size finalSize)
        {
            if (!_isInitialized)
            {
                _isInitialized = true;
                Camera.Position = new Point(-finalSize.Width / 2 / Camera.Scale, -finalSize.Height / 2 / Camera.Scale);
            }
            else
            {
                Camera.Position -= new Vector(
                    (finalSize.Width - _lastSize.Width) / 2 / Camera.Scale,
                    (finalSize.Height - _lastSize.Height) / 2 / Camera.Scale);
            }
            _lastSize = finalSize;
            StaticCanvas?.InvalidateVisual();
            return base.ArrangeOverride(finalSize);
        }
        protected override void OnPropertyChanged(AvaloniaPropertyChangedEventArgs change)
        {
            base.OnPropertyChanged(change);
            if (!_isInitialized) return;
            if (change.Property == ElementsProperty)
                SubscribeToCollection(Elements, OnElementsChanged);
            else if (change.Property == DynamicElementsProperty)
                SubscribeToCollection(DynamicElements, OnDynamicElementsChanged);
            StaticCanvas?.InvalidateVisual();
            DynamicCanvas?.InvalidateVisual();
        }
        private void OnPointerPressed(object? sender, PointerPressedEventArgs e)
        {
            if (e.GetCurrentPoint(this).Properties.IsMiddleButtonPressed)
            {
                _lastPointerDragPosition = e.GetPosition(this);
                isPanning = true;
            }
        }
        private void OnPointerReleased(object? sender, PointerReleasedEventArgs e)
        {
            if (e.InitialPressMouseButton == MouseButton.Left)
            {
                var ODVec2 = new ODVec2(GetWorldMousePosition().X, GetWorldMousePosition().Y);
                InputService?.RaisePointProvided(ODVec2);
                e.Handled = true;
            }
            if (e.InitialPressMouseButton == MouseButton.Middle)
                isPanning = false;
        }
        private void OnPointerMoved(object? sender, PointerEventArgs e)
        {
            _mousePosition = e.GetPosition(this);
            DynamicCanvas?.InvalidateVisual();
            if (!isPanning) return;
            var current = e.GetPosition(this);
            Camera.MoveBy(new Vector(-(current.X - _lastPointerDragPosition.X) / Camera.Scale,
                                     (current.Y - _lastPointerDragPosition.Y) / Camera.Scale));
            _lastPointerDragPosition = current;
            StaticCanvas?.InvalidateVisual();
        }
        private void OnPointerEntered(object? sender, PointerEventArgs e)
        {
            InputService?.RaiseViewportEntered();
        }
        private void OnPointerExited(object? sender, PointerEventArgs e)
        {
            InputService?.RaiseViewportExited();
        }
        private void OnPointerWheelChanged(object? sender, PointerWheelEventArgs e)
        {
            var mousePos = e.GetPosition(this);
            double zoomFactor = 1.1f;
            double oldScale = Camera.Scale;
            double newScale = oldScale * Math.Pow(zoomFactor, e.Delta.Y > 0 ? 1 : -1);
            Point ScreenToWorld(Point screen, double scale) =>
                new(screen.X / scale - Camera.Position.X, (Bounds.Height - screen.Y) / scale - Camera.Position.Y);
            var oldWorld = ScreenToWorld(mousePos, oldScale);
            var newWorld = ScreenToWorld(mousePos, newScale);
            Camera.Position += oldWorld - newWorld; // <--- fix here
            Camera.Scale = newScale;
            StaticCanvas?.InvalidateVisual();
            DynamicCanvas?.InvalidateVisual();
        }
        public Point GetScreenMousePosition() => _mousePosition;
        public ODVec2 GetWorldMousePosition()
        {
            double x = (_mousePosition.X / Camera.Scale + Camera.Position.X);
            double y = ((Bounds.Height - _mousePosition.Y) / Camera.Scale) + Camera.Position.Y;
            return new ODVec2(x,y);
        }
    }
}


** ODDataManager.cs **
Path: D:\OpenDraft\OpenDraft\ODCore\ODData\ODDataManager.cs

ï»¿using OpenDraft.ODCore.ODGeometry;
using System;
using System.Collections.ObjectModel;
namespace OpenDraft.ODCore.ODData
{
    public class ODDataManager
    {
        public ObservableCollection<ODGeometry.ODElement> Elements { get; } = new();
        public ODLayerManager LayerManager { get; } = new ODLayerManager();
        public ODLineStyleRegistry LineStyleRegister { get; } = new ODLineStyleRegistry();
        public ODSymbolTable SymbolTableRegister = new ODSymbolTable();
        public ODDataManager()
        {
        }
        public void AddElement(ODElement element)
        {
            if (element == null)
                throw new ArgumentNullException(nameof(element));
            if (Elements.Contains(element))
                return;
            element.LayerId = LayerManager.GetActiveLayer();
            Elements.Add(element);
        }
    }
}


** ODSelectionManager.cs **
Path: D:\OpenDraft\OpenDraft\ODCore\ODData\ODSelectionManager.cs

ï»¿using Avalonia.Controls;
using OpenDraft.ODCore.ODGeometry;
using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading.Tasks;
namespace OpenDraft.ODCore.ODData
{
    public class ODSelectionSet
    {
        public IReadOnlyCollection<ODElement> SelectedElements { get; }
        public ODSelectionSet()
        {
            SelectedElements = new List<ODElement>().AsReadOnly();
        }
        public ODSelectionSet(IEnumerable<ODElement> elements)
        {
            SelectedElements = elements?.ToList().AsReadOnly() ?? new List<ODElement>().AsReadOnly();
        }
        public bool IsEmpty => SelectedElements.Count == 0;
        public int Count => SelectedElements.Count;
        // Helper methods for common operations
        public ODSelectionSet AddElement(ODElement element)
        {
            if (element == null) return this;
            var newElements = SelectedElements.ToList();
            if (!newElements.Contains(element))
            {
                newElements.Add(element);
            }
            return new ODSelectionSet(newElements);
        }
        public ODSelectionSet AddElements(IEnumerable<ODElement> elements)
        {
            var elementList = elements?.ToList() ?? new List<ODElement>();
            if (elementList.Count == 0) return this;
            var newElements = SelectedElements.ToList();
            foreach (var element in elementList)
            {
                if (element != null && !newElements.Contains(element))
                {
                    newElements.Add(element);
                }
            }
            return new ODSelectionSet(newElements);
        }
        public ODSelectionSet RemoveElement(ODElement element)
        {
            if (element == null) return this;
            var newElements = SelectedElements.ToList();
            newElements.Remove(element);
            return new ODSelectionSet(newElements);
        }
        public ODSelectionSet Clear()
        {
            return new ODSelectionSet();
        }
        public bool Contains(ODElement element)
        {
            return SelectedElements.Contains(element);
        }
    }
    public class ODSelectionManager
    {
        private readonly ODDataManager _dataManager;        
        private ODSelectionSet _activeSelection;
        public ODSelectionManager(ODDataManager dataManager)
        {
            _dataManager = dataManager;
            _activeSelection = new ODSelectionSet();
        }
        public ODSelectionSet GetActiveSelectionSet()
        {
            return _activeSelection;
        }
        public void UpdateSelectionSet(ODSelectionSet selectionSet)
        {
            _activeSelection = selectionSet;
        }
    }
}

** ODEditor.cs **
Path: D:\OpenDraft\OpenDraft\ODCore\ODEditor\ODEditor.cs

ï»¿using Avalonia.Input;
using Avalonia.Threading;
using OpenDraft.ODCore.ODData;
using OpenDraft.ODCore.ODEditor.ODCommands;
using OpenDraft.ODCore.ODEditor.ODDynamics;
using OpenDraft.ODCore.ODGeometry;
using System;
using System.Collections.Generic;
using System.Collections.ObjectModel;
using System.Diagnostics;
using System.Threading;
using System.Threading.Tasks;
namespace OpenDraft.ODCore.ODEditor
{
    public class ODEditor : IDisposable
    {
        private readonly ODDataManager _dataManager;
        private readonly ODCommandRegistry _commandRegistry;
        private readonly IODEditorInputService _inputService;
        private readonly ODSelectionManager _selectionManager;
        public ObservableCollection<ODDynamicElement> DynamicElements { get; } = new();
        private ODEditorContext? _currentContext;
        private IODEditorCommand? _currentCommand;
        public event EventHandler<MessageEventArgs>? ShowMessageRequested;
        public event EventHandler<MessageEventArgs>? StatusMessageChanged;
        ODCrosshairElement ch = new ODCrosshairElement();
        public ODEditor(ODDataManager dataManager, IODEditorInputService inputService)
        {
            _dataManager = dataManager;
            _inputService = inputService;
            _commandRegistry = new ODCommandRegistry();
            _commandRegistry.RegisterAssembly(typeof(ODEditor).Assembly);
            // Subscribe to input events
            _inputService.KeyPressed += OnKeyPressed;
            _inputService.CancelRequested += OnCancelRequested;
            // Subscribe to viewport focus events
            _inputService.ViewportEntered += OnViewportEntered;
            _inputService.ViewportExited += OnViewportExited;
            DynamicElements.Add(ch);
        }
        // Add event handlers
        private void OnViewportEntered()
        {
            ShowCrosshair();
        }
        private void OnViewportExited()
        {
            HideCrosshair();
        }
        /* DYNAMIC ELEMENTS MANAGEMENT */
        public void restoreDefaultDynamicElements()
        {
            DynamicElements.Clear();
            // Future: Add default dynamic elements if any <<<< TODO IMPLEMENT <<<<
            DynamicElements.Add(ch);
        }
        public void ClearDynamicElements()
        {
            DynamicElements.Clear();
            DynamicElements.Add(ch);
        }
        // ADD THIS: Method to add dynamic elements
        public void AddDynamicElement(ODDynamicElement element)
        {
            Debug.WriteLine("AddDynamicElement: " + element.GetType().Name);
            DynamicElements.Add(element);
        }
        // ADD THIS: Method to remove specific dynamic element
        public void RemoveDynamicElement(ODDynamicElement element)
        {
            DynamicElements.Remove(element);
        }
        public void AddStaticElement(ODElement element)
        {
            _dataManager.AddElement(element);
        }
        /* COMMAND EXECUTION AND INPUT HANDLING  */
        private void OnKeyPressed(Key key)
        {
            // Handle specific keys we care about
            switch (key)
            {
                case Key.Escape:
                    CancelCurrentCommand();
                    break;
                    // Future: handle Enter, Space, etc.
            }
        }
        private void OnCancelRequested()
        {
            CancelCurrentCommand();
        }
        public void CancelCurrentCommand()
        {
            restoreDefaultDynamicElements();
            _currentContext?.Cancel();
            _currentContext = null;
            _currentCommand = null;
            SetStatus("Command cancelled");
        }
        public void ExecuteCommand(string commandName)
        {
            Debug.WriteLine($"ExecuteCommand: {commandName}");
            CancelCurrentCommand();
            var command = _commandRegistry.CreateCommand(commandName);
            if (command == null)
            {
                SetStatus($"Unknown command: {commandName}");
                return;
            }
            _currentCommand = command;
            _currentContext = new ODEditorContext(this, _dataManager, _inputService);
            async Task RunCommandAsync()
            {
                try
                {
                    await command.ExecuteAsync(_currentContext);
                }
                catch (Exception ex)
                {
                    SetStatus($"Error in {commandName}: {ex.Message}");
                    Debug.WriteLine($"Command error: {ex.Message}");
                }
                finally
                {
                    if (_currentCommand == command)
                    {
                        CancelCurrentCommand();
                    }
                }
            }
            _ = RunCommandAsync();
        }
        public void SetStatus(string message)
        {
            Debug.WriteLine("SetStatus: " + message);
            Dispatcher.UIThread.Post(() =>
            {
                StatusMessageChanged?.Invoke(this, new MessageEventArgs(message));
            });
        }
        public void ShowMessage(string message)
        {
            Debug.WriteLine("ShowMessage: " + message);
            Dispatcher.UIThread.Post(() =>
            {
                ShowMessageRequested?.Invoke(this, new MessageEventArgs(message));
            });
        }
        public void Dispose()
        {
            _inputService.KeyPressed -= OnKeyPressed;
            _inputService.CancelRequested -= OnCancelRequested;
            CancelCurrentCommand();
        }
        public void HideCrosshair()
        {
            ch.IsVisible = false;
        }
        public void ShowCrosshair()
        {
            ch.IsVisible = true;
        }
    }
    public class MessageEventArgs : EventArgs
    {
        public string Message { get; }
        public MessageEventArgs(string message) => Message = message;
    }
    public class BoolEventArgs : EventArgs
    {
        public bool Value { get; }
        public BoolEventArgs(bool value) => Value = value;
    }
}

** ODCircle.cs **
Path: D:\OpenDraft\OpenDraft\ODCore\ODGeometry\ODCircle.cs

ï»¿using Avalonia;
using Avalonia.Media;
using OpenDraft.ODCore.ODData;
using OpenDraft.ODCore.ODEditor;
using OpenDraft.ODCore.ODMath;
using System;
using System.Net;
namespace OpenDraft.ODCore.ODGeometry
{
    internal class ODCircle : ODElement
    {
        public ODVec2 Center { get; set; }
        public double Radius { get; set; }
        public ODCircle(ODVec2 center, double radius)
        {
            Center = center;
            Radius = radius;
        }
        public override void Draw(DrawingContext context, ODDrawConnector connector)
        {
            ODLayer? layer = connector.GetLayerByID(LayerId);
            if (layer != null && !layer.IsVisible)
                return;
            if (layer == null)
                return;
            // Get dash style from registry
            var dashStyle = connector.ToAvaloniaDashStyle(LineType ?? layer.LineType);
            ODColour effectiveColour = (Colour != null) ? Colour : layer.Color;
            double effectiveLineWeight = LineWeight ?? layer.LineWeight;
            // Create pen
            var pen = new Pen(
                new SolidColorBrush(effectiveColour.ToAvaloniaColor()), // Brush only
                effectiveLineWeight,                                    // Thickness
                dashStyle                                               // Dash style
            );
            context.DrawEllipse(null, pen, new Point(Center.X, Center.Y), Radius, Radius);
            var bbpen = new Pen(new SolidColorBrush(Colors.Yellow, 1));
            ODBoundingBox bb = GetBoundingBox();
            var rect = new Rect(bb.GetOrigin.X,
                                bb.GetOrigin.Y,
                                bb.Width,
                                bb.Height);
            context.DrawRectangle(bbpen, rect);
        }
        public override ODBoundingBox GetBoundingBox()
        {
            // Find min/max for each axis
            double minX = Center.X - Radius;
            double minY = Center.Y - Radius;
            double maxX = Center.X + Radius;
            double maxY = Center.Y + Radius;
            // Construct bounding box
            ODVec2 bottomLeft = new ODVec2(minX, minY);
            ODVec2 topRight = new ODVec2(maxX, maxY);
            return new ODBoundingBox(bottomLeft, topRight);
        }
        public override bool HitTest(ODVec2 point)
        {
            return false;
        }
    }
}


** ODElement.cs **
Path: D:\OpenDraft\OpenDraft\ODCore\ODGeometry\ODElement.cs

ï»¿using Avalonia;
using Avalonia.Media;
using OpenDraft.ODCore.ODData;
using OpenDraft.ODCore.ODEditor;
using OpenDraft.ODCore.ODMath;
using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading.Tasks;
namespace OpenDraft.ODCore.ODGeometry
{
    public abstract class ODElement
    {
        public Guid Id { get; set; }
        public ushort LayerId { get; set; } = 0; // Default layer ID
        public ODColour? Colour { get; set; } = null; // If null, use layer colour
        public double? LineWeight { get; set; } = null; // If null, use layer lineweight
        public string? LineType { get; set; } = null; // If null, use layer linetype
        public ODElement()
        {
            Id = Guid.NewGuid();
        }
        public abstract void Draw(DrawingContext context, ODDrawConnector connector);
        public abstract ODBoundingBox GetBoundingBox();
        public abstract bool HitTest(ODVec2 point);
    }
}


** ODLine.cs **
Path: D:\OpenDraft\OpenDraft\ODCore\ODGeometry\ODLine.cs

ï»¿using Avalonia;
using Avalonia.Media;
using Microsoft.Win32;
using OpenDraft.ODCore.ODData;
using OpenDraft.ODCore.ODEditor;
using OpenDraft.ODCore.ODMath;
using System;
namespace OpenDraft.ODCore.ODGeometry
{
    internal class ODLine : ODElement
    {
        public ODVec2 StartPoint { get; set; }
        public ODVec2 EndPoint { get; set; }
        public ODLine(ODVec2 startPoint, ODVec2 endPoint)
        {
            StartPoint = startPoint;
            EndPoint = endPoint;
        }
        public override void Draw(DrawingContext context, ODDrawConnector connector)
        {
            ODLayer? layer = connector.GetLayerByID(LayerId);
            if (layer != null && !layer.IsVisible)
                return;
            if (layer == null)
                return;
            // Get dash style from registry
            IDashStyle dashStyle = connector.ToAvaloniaDashStyle(LineType ?? layer.LineType);
            ODColour effectiveColour = (Colour != null) ? Colour : layer.Color;
            double effectiveLineWeight = LineWeight ?? layer.LineWeight;
            // Create pen
            var pen = new Pen(
                new SolidColorBrush(effectiveColour.ToAvaloniaColor()), // Brush only
                effectiveLineWeight,                                    // Thickness
                dashStyle                                               // Dash style
            );
            context.DrawLine(pen,
                    new Point(StartPoint.X, StartPoint.Y),
                    new Point(EndPoint.X, EndPoint.Y));
            var bbpen = new Pen(new SolidColorBrush(Colors.Yellow, 1));
            ODBoundingBox bb = GetBoundingBox();
            var rect = new Rect(bb.GetOrigin.X,
                                bb.GetOrigin.Y,
                                bb.Width,
                                bb.Height);
            context.DrawRectangle(bbpen, rect);
        }
        public override ODBoundingBox GetBoundingBox()
        {
            // Find min/max for each axis
            double minX = Math.Min(StartPoint.X, EndPoint.X);
            double minY = Math.Min(StartPoint.Y, EndPoint.Y);
            double maxX = Math.Max(StartPoint.X, EndPoint.X);
            double maxY = Math.Max(StartPoint.Y, EndPoint.Y);
            // Construct bounding box
            ODVec2 bottomLeft = new ODVec2(minX, minY);
            ODVec2 topRight = new ODVec2(maxX, maxY);
            return new ODBoundingBox(bottomLeft, topRight);
        }
        public override bool HitTest(ODVec2 point)
        {
            return false;
        }
    }
}


** ODPoint.cs **
Path: D:\OpenDraft\OpenDraft\ODCore\ODGeometry\ODPoint.cs

ï»¿using Avalonia.Media;
using OpenDraft.ODCore.ODData;
using OpenDraft.ODCore.ODEditor;
using OpenDraft.ODCore.ODMath;
using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading.Tasks;
namespace OpenDraft.ODCore.ODGeometry
{
    public class ODPoint : ODElement
    {
        public double X { get; set; }
        public double Y { get; set; }
        public ODPoint(double x, double y)
        {
            X = x;
            Y = y;
        }
        public ODPoint(float x, float y)
        {
            X = x;
            Y = y;
        }
        public override void Draw(DrawingContext context, ODDrawConnector connector)
        {
            // To Do
        }
        public override ODBoundingBox GetBoundingBox()
        {
            return new ODBoundingBox(new ODVec2(0, 0), new ODVec2(0, 0));
        }
        public override bool HitTest(ODVec2 point)
        {
            return false;
        }
    }
}


** ODPolyline.cs **
Path: D:\OpenDraft\OpenDraft\ODCore\ODGeometry\ODPolyline.cs

ï»¿using Avalonia;
using Avalonia.Media;
using Microsoft.Win32;
using OpenDraft.ODCore.ODData;
using System;
using System.Collections.Generic;
using OpenDraft.ODCore.ODMath;
using System.Linq;
using OpenDraft.ODCore.ODEditor;
namespace OpenDraft.ODCore.ODGeometry
{
    public class ODPolyline : ODElement
    {
        public List<ODVec2> Points { get; set; }
        public ODPolyline(List<ODVec2> points)
        {
            Points = points ?? new List<ODVec2>();
        }
        public override void Draw(DrawingContext context, ODDrawConnector connector)
        {
            ODLayer? layer = connector.GetLayerByID(LayerId);
            if (layer != null && !layer.IsVisible)
                return;
            if (layer == null)
                return;
            if (Points == null || Points.Count < 2)
                return;
            // Get dash style from registry
            var dashStyle = connector.ToAvaloniaDashStyle(LineType ?? layer.LineType);
            ODColour effectiveColour = (Colour != null) ? Colour : layer.Color;
            double effectiveLineWeight = LineWeight ?? layer.LineWeight;
            // Create pen
            var pen = new Pen(
                new SolidColorBrush(effectiveColour.ToAvaloniaColor()), // Brush only
                effectiveLineWeight,                                    // Thickness
                dashStyle                                               // Dash style
            );
            // Draw each segment individually
            for (int i = 1; i < Points.Count; i++)
            {
                context.DrawLine(pen,
                    new Point(Points[i - 1].X, Points[i - 1].Y),
                    new Point(Points[i].X, Points[i].Y));
            }
        }
        // Optional: Add convenience properties and methods
        public bool IsClosed => Points.Count > 2 && Points[0].Equals(Points[Points.Count - 1]);
        public double Length
        {
            get
            {
                if (Points.Count < 2) return 0;
                double length = 0;
                for (int i = 1; i < Points.Count; i++)
                {
                    length += Math.Sqrt(
                        Math.Pow(Points[i].X - Points[i - 1].X, 2) +
                        Math.Pow(Points[i].Y - Points[i - 1].Y, 2));
                }
                return length;
            }
        }
        public ODVec2 StartPoint => Points?.FirstOrDefault() ?? new ODVec2(0, 0);
        public ODVec2 EndPoint => Points?.LastOrDefault() ?? new ODVec2(0, 0);
        public void AddPoint(ODVec2 point)
        {
            Points.Add(point);
        }
        public void InsertPoint(int index, ODVec2 point)
        {
            if (index >= 0 && index <= Points.Count)
                Points.Insert(index, point);
        }
        public void RemovePoint(int index)
        {
            if (index >= 0 && index < Points.Count)
                Points.RemoveAt(index);
        }
        public override ODBoundingBox GetBoundingBox()
        {
            if (Points == null || Points.Count == 0)
                return new ODBoundingBox(new ODVec2(0, 0), new ODVec2(0, 0));
            double minX = Points.Min(p => p.X);
            double maxX = Points.Max(p => p.X);
            double minY = Points.Min(p => p.Y);
            double maxY = Points.Max(p => p.Y);
            return new ODBoundingBox(new ODVec2(minX, minY), new ODVec2(maxX, maxY));
        }
        public override bool HitTest(ODVec2 point)
        {
            return false;
        }
    }
}

** ODRectangle.cs **
Path: D:\OpenDraft\OpenDraft\ODCore\ODGeometry\ODRectangle.cs

ï»¿using Avalonia;
using Avalonia.Media;
using OpenDraft.ODCore.ODData;
using System;
using System.Collections.Generic;
using OpenDraft.ODCore.ODMath;
using System.Linq;
using System.Xml.Linq;
using OpenDraft.ODCore.ODEditor;
namespace OpenDraft.ODCore.ODGeometry
{
    public class ODRectangle : ODElement
    {
        public ODVec2 TopLeft { get; set; }
        public ODVec2 BottomRight { get; set; }
        public ODRectangle(ODVec2 topLeft, ODVec2 bottomRight)
        {
            TopLeft = topLeft;
            BottomRight = bottomRight;
        }
        // Alternative constructor from center point and dimensions
        public ODRectangle(ODVec2 center, double width, double height)
        {
            double halfWidth = width / 2;
            double halfHeight = height / 2;
            TopLeft = new ODVec2(center.X - halfWidth, center.Y - halfHeight);
            BottomRight = new ODVec2(center.X + halfWidth, center.Y + halfHeight);
        }
        // Alternative constructor from corner point and dimensions
        public ODRectangle(ODVec2 corner, double width, double height, bool isTopLeft = true)
        {
            if (isTopLeft)
            {
                TopLeft = corner;
                BottomRight = new ODVec2(corner.X + width, corner.Y + height);
            }
            else
            {
                BottomRight = corner;
                TopLeft = new ODVec2(corner.X - width, corner.Y - height);
            }
        }
        public override void Draw(DrawingContext context, ODDrawConnector connector)
        {
            ODLayer? layer = connector.GetLayerByID(LayerId);
            if (layer != null && !layer.IsVisible)
                return;
            if (layer == null)
                return;
            // Get dash style from registry
            var dashStyle = connector.ToAvaloniaDashStyle(LineType ?? layer.LineType);
            ODColour effectiveColour = (Colour != null) ? Colour : layer.Color;
            double effectiveLineWeight = LineWeight ?? layer.LineWeight;
            // Create pen
            var pen = new Pen(
                new SolidColorBrush(effectiveColour.ToAvaloniaColor()), // Brush only
                effectiveLineWeight,                                    // Thickness
                dashStyle                                               // Dash style
            );
            // Create rectangle geometry
            Rect rect = new Rect(
                new Point(TopLeft.X, TopLeft.Y),
                new Point(BottomRight.X, BottomRight.Y)
            );
            // Draw the rectangle
            context.DrawRectangle(pen, rect);
        }
        // Properties for convenience
        public double X => TopLeft.X;
        public double Y => TopLeft.Y;
        public double Width => Math.Abs(BottomRight.X - TopLeft.X);
        public double Height => Math.Abs(BottomRight.Y - TopLeft.Y);
        public ODVec2 TopRight => new ODVec2(BottomRight.X, TopLeft.Y);
        public ODVec2 BottomLeft => new ODVec2(TopLeft.X, BottomRight.Y);
        public ODVec2 Center => new ODVec2(
            (TopLeft.X + BottomRight.X) / 2,
            (TopLeft.Y + BottomRight.Y) / 2
        );
        public double Area => Width * Height;
        public double Perimeter => 2 * (Width + Height);
        // Method to check if a point is inside the rectangle
        public bool ContainsPoint(ODVec2 point)
        {
            var minX = Math.Min(TopLeft.X, BottomRight.X);
            var maxX = Math.Max(TopLeft.X, BottomRight.X);
            var minY = Math.Min(TopLeft.Y, BottomRight.Y);
            var maxY = Math.Max(TopLeft.Y, BottomRight.Y);
            return point.X >= minX && point.X <= maxX &&
                   point.Y >= minY && point.Y <= maxY;
        }
        // Convert to polyline (useful for some operations)
        public ODPolyline ToPolyline()
        {
            var points = new List<ODVec2>
            {
                TopLeft,
                TopRight,
                BottomRight,
                BottomLeft,
                TopLeft // Close the rectangle
            };
            return new ODPolyline(points);
        }
        // Get bounding box (for compatibility with other geometry)
        public override ODBoundingBox GetBoundingBox()
        {
            // Construct bounding box
            ODVec2 bottomLeft = new ODVec2(BottomLeft.X, BottomLeft.Y);
            ODVec2 topRight = new ODVec2(TopRight.X, TopRight.Y);
            return new ODBoundingBox(bottomLeft, topRight);
        }
        public override bool HitTest(ODVec2 point)
        {
            return false;
        }
        // SVG export support
        public XElement ToSvgElement(ODLayer layer, ODLineStyleRegistry registry)
        {
            var element = new XElement("{http://www.w3.org/2000/svg}rect",
                new XAttribute("x", TopLeft.X),
                new XAttribute("y", TopLeft.Y),
                new XAttribute("width", Width),
                new XAttribute("height", Height),
                new XAttribute("fill", "none") // No fill by default
            );
            return element;
        }
        public override string ToString()
        {
            return $"Rectangle [({X:0.##}, {Y:0.##}) {Width:0.##}x{Height:0.##}]";
        }
    }
}

** ODSymbol.cs **
Path: D:\OpenDraft\OpenDraft\ODCore\ODGeometry\ODSymbol.cs

ï»¿using Avalonia;
using Avalonia.Media;
using OpenDraft.ODCore.ODData;
using OpenDraft.ODCore.ODEditor;
using OpenDraft.ODCore.ODMath;
using System;
namespace OpenDraft.ODCore.ODGeometry
{
    public class ODSymbol : ODElement
    {
        public string SymbolName { get; set; }
        public ODVec2 InsertionPoint { get; set; }
        public double Rotation { get; set; }
        public double Scale { get; set; } = 1.0;
        public ODSymbol(string symbolName, ODVec2 insertionPoint)
        {
            SymbolName = symbolName;
            InsertionPoint = insertionPoint;
        }
        private Matrix CreateSymbolMatrix()
        {
            // Start with identity matrix
            var matrix = Matrix.Identity;
            // Apply scaling
            if (Scale != 1.0)
            {
                matrix = matrix * Matrix.CreateScale(Scale, Scale);
            }
            // Apply rotation (convert degrees to radians)
            if (Rotation != 0.0)
            {
                double radians = Rotation * Math.PI / 180.0;
                matrix = matrix * Matrix.CreateRotation(radians);
            }
            // Apply translation
            matrix = matrix * Matrix.CreateTranslation(new Vector(InsertionPoint.X, InsertionPoint.Y));
            return matrix;
        }
        public override void Draw(DrawingContext context, ODDrawConnector connector)
        {
            ODLayer? layer = connector.GetLayerByID(LayerId);
            if (layer != null && !layer.IsVisible)
                return;
            if (layer == null)
                return;
            // Get dash style from registry
            var dashStyle = connector.ToAvaloniaDashStyle(LineType ?? layer.LineType);
            ODColour effectiveColour = (Colour != null) ? Colour : layer.Color;
            double effectiveLineWeight = LineWeight ?? layer.LineWeight;
            // Create pen
            var pen = new Pen(
                new SolidColorBrush(effectiveColour.ToAvaloniaColor()), // Brush only
                effectiveLineWeight,                                    // Thickness
                dashStyle                                               // Dash style
            );
            ODSymbolDefinition? symbolDefition = connector.GetSymbolDefinition(SymbolName);
            if (symbolDefition == null)
                return;
            using (context.PushTransform(CreateSymbolMatrix()))
            {
                foreach (ODElement element in symbolDefition.Elements)
                {
                    element.Draw(context, connector);
                }
            }
        }
        public override ODBoundingBox GetBoundingBox()
        {
            return new ODBoundingBox(new ODVec2(0, 0), new ODVec2(0, 0));
        }
        public override bool HitTest(ODVec2 point)
        {
            return false;
        }
    }
}

** ODSymbolDefinition.cs **
Path: D:\OpenDraft\OpenDraft\ODCore\ODGeometry\ODSymbolDefinition.cs

ï»¿using Avalonia.Media;
using OpenDraft.ODCore.ODEditor;
using OpenDraft.ODCore.ODGeometry;
using OpenDraft.ODCore.ODMath;
using System.Collections.Generic;
namespace OpenDraft.ODCore.ODGeometry
{
    public class ODSymbolDefinition
    {
        public string Name { get; set; }
        public List<ODElement> Elements { get; set; } = new List<ODElement>();
        public ODSymbolDefinition(string name)
        {
            Name = name;
        }
    }
}

** MainWindowViewModel.cs **
Path: D:\OpenDraft\OpenDraft\ViewModels\MainWindowViewModel.cs

ï»¿using CommunityToolkit.Mvvm.Input;
using OpenDraft.ODCore.ODData;
using OpenDraft.ODCore.ODEditor;
using OpenDraft.ODCore.ODGeometry;
using OpenDraft.ODCore.ODMath;
using OpenDraft.ODCore.ODSystem;
using OpenDraft.XSVG;
using System.Collections.Generic;
using System.Collections.ObjectModel;
using System.Diagnostics;
namespace OpenDraft.ViewModels
{
    public partial class MainWindowViewModel : ViewModelBase
    {
        public ODDataManager DataManagerRoot { get; }
        public IODEditorInputService InputService { get; }
        public ODEditor EditorRoot { get; private set; }
        public ODDrawConnector DrawConnectorRoot { get; }
        public ObservableCollection<ODElement> GeometryElements => DataManager.Elements;
        public ODDataManager DataManager => DataManagerRoot;
        public ODEditor Editor => EditorRoot;
        public ODSymbolTable SymbolTable { get; private set; }
        public ODDrawConnector DrawConnector => DrawConnectorRoot;
        public MainWindowViewModel()
        {
            ODSystem.Initialise();
            // Initialize the DataManager and Editor
            DataManagerRoot = new ODDataManager();
            InputService = new ODEditorInputService();
            EditorRoot = new ODEditor(DataManager, InputService);
            SymbolTable = new ODSymbolTable();
            DrawConnectorRoot = new ODDrawConnector(DataManager, Editor, SymbolTable);
            // Debug XSVG Reader
            /*ODXsvgReader xsvgR = new ODXsvgReader("XSVG/Example XSVG/example.xsvg");
            List<ODElement> xsvgElements = xsvgR.ExtractModelSpace();
            foreach (ODElement elem in xsvgElements)
            {
                Editor.AddStaticElement(elem);
            }*/
            /* Create test layer */
            DataManager.LayerManager.AddLayer("New Layer");
            ODLayer? lay = DataManager.LayerManager.GetLayerByName("New Layer");
            DataManager.LayerManager.SetActiveLayer("New Layer");
            lay!.Color = new ODColour("#00FF00");
            lay!.LineWeight = 2.0f;
            Debug.WriteLine("Setup complete");
            // Test Symbols
            ODSymbolDefinition symDef = new ODSymbolDefinition("MySymbol");
            ODLine L1 = new ODLine(new ODVec2(0, 0), new ODVec2(50, 50));
            ODLine L2 = new ODLine(new ODVec2(0, 50), new ODVec2(50, 0));
            symDef.Elements.Add(L1);
            symDef.Elements.Add(L2);
            SymbolTable.AddSymbol(symDef);
            ODSymbol S1 = new ODSymbol("MySymbol", new ODVec2(100, -10));
            ODSymbol S2 = new ODSymbol("MySymbol", new ODVec2(20, -10));
            DataManager.AddElement(S1);
            DataManager.AddElement(S2);
        }
        [RelayCommand]
        private void ExecuteEditor(string command)
        {
            EditorRoot.ExecuteCommand(command);
        }
    }
}

** ODSvgReader.cs **
Path: D:\OpenDraft\OpenDraft\XSVG\ODSvgReader.cs

ï»¿using OpenDraft.ODCore.ODData;
using OpenDraft.ODCore.ODGeometry;
using OpenDraft.ODCore.ODMath;
using System;
using System.Collections.Generic;
using System.Diagnostics;
using System.Text;
using System.Xml.Linq;
namespace OpenDraft.XSVG
{
    internal struct ODSvgStyle
    {
        public ODColour StrokeColor;
        public ODColour FillColor;
        public double StrokeWidth;
        public string LineType;
        public string LayerName;
        public bool IsVisible;
        public bool IsLocked;
    }
    public class CADLayer
    {
        public string Id { get; set; }
        public string Name { get; set; }
        public ODColour Color { get; set; }
        public bool Visible { get; set; }
        public bool Locked { get; set; }
        public double LineWeight { get; set; }
        public string LineType { get; set; }
    }
    public class ODSvgReader
    {
        private string? _filePath;
        private XDocument? _xDocument;
        private XNamespace _ns = "http://www.w3.org/2000/svg";
        private XNamespace _cadNs = "http://your-cad-app.org/cad/1.0";
        private XNamespace _dcNs = "http://purl.org/dc/elements/1.1/";
        private Dictionary<string, CADLayer> _layers = new Dictionary<string, CADLayer>();
        private Dictionary<string, XElement> _blockDefinitions = new Dictionary<string, XElement>();
        private CADMetadata _metadata = new CADMetadata();
        public void LoadSvgFile(string filePath)
        {
            _filePath = filePath;
            if (!System.IO.File.Exists(filePath))
                throw new System.IO.FileNotFoundException("SVG file not found", filePath);
            string fileContentsRaw = System.IO.File.ReadAllText(filePath);
            _xDocument = XDocument.Parse(fileContentsRaw);
            // Parse CAD-specific metadata and definitions
            ParseCADMetadata();
            ParseLayerDefinitions();
            ParseBlockDefinitions();
        }
        #region CAD Metadata Parsing
        private void ParseCADMetadata()
        {
            if (_xDocument?.Root == null) return;
            // Parse root CAD attributes
            _metadata.AppVersion = _xDocument.Root.Attribute(_cadNs + "app-version")?.Value;
            _metadata.FileVersion = _xDocument.Root.Attribute(_cadNs + "file-version")?.Value;
            _metadata.Units = _xDocument.Root.Attribute(_cadNs + "units")?.Value;
            _metadata.Precision = ParseDouble(_xDocument.Root.Attribute(_cadNs + "precision")?.Value) ?? 0.001;
            // Parse metadata section
            var metadataElement = _xDocument.Root.Element("metadata");
            if (metadataElement != null)
            {
                _metadata.Application = metadataElement.Element(_cadNs + "application")?.Value;
                _metadata.Version = metadataElement.Element(_cadNs + "version")?.Value;
                _metadata.Created = ParseDateTime(metadataElement.Element(_cadNs + "created")?.Value);
                _metadata.Modified = ParseDateTime(metadataElement.Element(_cadNs + "modified")?.Value);
                // Parse Dublin Core metadata
                _metadata.Title = metadataElement.Element(_dcNs + "title")?.Value;
                _metadata.Creator = metadataElement.Element(_dcNs + "creator")?.Value;
                _metadata.Description = metadataElement.Element(_dcNs + "description")?.Value;
                // Parse custom properties
                var propertiesElement = metadataElement.Element(_cadNs + "properties");
                if (propertiesElement != null)
                {
                    _metadata.Properties = new Dictionary<string, string>();
                    foreach (var propElement in propertiesElement.Elements(_cadNs + "property"))
                    {
                        var name = propElement.Attribute("name")?.Value;
                        var value = propElement.Attribute("value")?.Value;
                        if (name != null)
                        {
                            _metadata.Properties[name] = value ?? string.Empty;
                        }
                    }
                }
            }
        }
        private void ParseLayerDefinitions()
        {
            var layersElement = _xDocument?.Root?
                .Element("defs")?
                .Element(_cadNs + "layers");
            if (layersElement == null) return;
            foreach (var layerElement in layersElement.Elements(_cadNs + "layer"))
            {
                var layer = new CADLayer
                {
                    Id = layerElement.Attribute("id")?.Value,
                    Name = layerElement.Attribute("name")?.Value,
                    Color = ParseColor(layerElement.Attribute("color")?.Value),
                    Visible = layerElement.Attribute("visible")?.Value == "true",
                    Locked = layerElement.Attribute("locked")?.Value == "true",
                    LineWeight = ParseDouble(layerElement.Attribute("lineweight")?.Value) ?? 0.25,
                    LineType = layerElement.Attribute("linetype")?.Value ?? "continuous"
                };
                if (layer.Id != null)
                {
                    _layers[layer.Id] = layer;
                }
            }
        }
        private void ParseBlockDefinitions()
        {
            var defsElement = _xDocument?.Root?.Element("defs");
            if (defsElement == null) return;
            foreach (var symbolElement in defsElement.Elements(_ns + "symbol"))
            {
                var id = symbolElement.Attribute("id")?.Value;
                if (id != null)
                {
                    _blockDefinitions[id] = symbolElement;
                }
            }
        }
        #endregion
        #region Geometry Import
        public List<ODElement> ImportGeometry()
        {
            if (_xDocument == null)
                throw new InvalidOperationException("No SVG file loaded. Call LoadSvgFile first.");
            var geometries = new List<ODElement>();
            var svgElement = _xDocument.Root;
            // Process groups (layers) first
            geometries.AddRange(ProcessGroups(svgElement));
            // Import individual elements not in groups
            geometries.AddRange(ImportPaths(svgElement));
            geometries.AddRange(ImportRectangles(svgElement));
            geometries.AddRange(ImportLines(svgElement));
            geometries.AddRange(ImportCircles(svgElement));
            geometries.AddRange(ImportBlockReferences(svgElement));
            Debug.WriteLine($"Imported {geometries.Count} geometry objects from {_layers.Count} layers");
            return geometries;
        }
        private List<ODElement> ProcessGroups(XElement parentElement)
        {
            var elements = new List<ODElement>();
            foreach (var groupElement in parentElement.Elements(_ns + "g"))
            {
                var layerId = groupElement.Attribute(_cadNs + "layer-id")?.Value;
                var style = ParseStyle(groupElement, layerId);
                // Process elements within the group
                elements.AddRange(ImportPaths(groupElement, style));
                elements.AddRange(ImportRectangles(groupElement, style));
                elements.AddRange(ImportLines(groupElement, style));
                elements.AddRange(ImportCircles(groupElement, style));
                elements.AddRange(ImportBlockReferences(groupElement, style));
                elements.AddRange(ProcessGroups(groupElement)); // Recursive for nested groups
            }
            return elements;
        }
        private List<ODElement> ImportBlockReferences(XElement parentElement, ODSvgStyle? parentStyle = null)
        {
            var blocks = new List<ODElement>();
            foreach (var useElement in parentElement.Descendants(_ns + "use"))
            {
                var href = useElement.Attribute(XNamespace.Get("http://www.w3.org/1999/xlink") + "href")?.Value;
                if (!string.IsNullOrEmpty(href) && href.StartsWith("#"))
                {
                    var blockId = href.Substring(1);
                    if (_blockDefinitions.TryGetValue(blockId, out var blockDefinition))
                    {
                        var style = ParseStyle(useElement, null, parentStyle);
                        var x = ParseDouble(useElement.Attribute("x")?.Value) ?? 0;
                        var y = ParseDouble(useElement.Attribute("y")?.Value) ?? 0;
                        // Parse transformation
                        var transform = useElement.Attribute("transform")?.Value;
                        var rotation = ParseDouble(useElement.Attribute(_cadNs + "rotation")?.Value) ?? 0;
                        var blockElements = ParseBlockDefinition(blockDefinition, x, y, rotation, style);
                        foreach (var element in blockElements)
                        {
                            ApplyCADMetadata(element, useElement);
                            blocks.Add(element);
                        }
                    }
                }
            }
            return blocks;
        }
        private List<ODElement> ParseBlockDefinition(XElement blockDefinition, double x, double y, double rotation, ODSvgStyle style)
        {
            var elements = new List<ODElement>();
            // Process paths in block definition
            foreach (var pathElement in blockDefinition.Descendants(_ns + "path"))
            {
                var pathData = pathElement.Attribute("d")?.Value;
                if (!string.IsNullOrEmpty(pathData))
                {
                    var path = ParsePathData(pathData, style);
                    if (path != null)
                    {
                        // Apply block transformation
                        ApplyTransformation(path, x, y, rotation);
                        elements.Add(path);
                    }
                }
            }
            // Process rectangles in block definition
            foreach (var rectElement in blockDefinition.Descendants(_ns + "rect"))
            {
                var rectX = ParseDouble(rectElement.Attribute("x")?.Value) ?? 0;
                var rectY = ParseDouble(rectElement.Attribute("y")?.Value) ?? 0;
                var width = ParseDouble(rectElement.Attribute("width")?.Value) ?? 0;
                var height = ParseDouble(rectElement.Attribute("height")?.Value) ?? 0;
                var rectangle = new ODRectangle(
                    new ODVec2(rectX + x, rectY + y),
                    new ODVec2(rectX + x + width, rectY + y + height)
                );
                ApplyTransformation(rectangle, x, y, rotation);
                elements.Add(rectangle);
            }
            return elements;
        }
        private void ApplyTransformation(ODElement element, double x, double y, double rotation)
        {
            // This is a simplified transformation - you'll need to implement
            // proper transformation logic based on your ODElement hierarchy
            if (element is ODPolyline polyline)
            {
                for (int i = 0; i < polyline.Points.Count; i++)
                {
                    var point = polyline.Points[i];
                    // Apply translation and rotation here
                    polyline.Points[i] = new ODVec2(point.X + x, point.Y + y);
                }
            }
            // Add similar logic for other element types
        }
        #endregion
        #region Original Geometry Import Methods (Preserved)
        private List<ODElement> ImportPaths(XElement parentElement, ODSvgStyle? parentStyle = null)
        {
            var paths = new List<ODElement>();
            foreach (var pathElement in parentElement.Descendants(_ns + "path"))
            {
                var pathData = pathElement.Attribute("d")?.Value;
                if (!string.IsNullOrEmpty(pathData))
                {
                    var style = ParseStyle(pathElement, null, parentStyle);
                    var path = ParsePathData(pathData, style);
                    if (path != null)
                    {
                        ApplyCADMetadata(path, pathElement);
                        paths.Add(path);
                    }
                }
            }
            return paths;
        }
        private List<ODElement> ImportRectangles(XElement parentElement, ODSvgStyle? parentStyle = null)
        {
            var rectangles = new List<ODElement>();
            foreach (var rectElement in parentElement.Descendants(_ns + "rect"))
            {
                var x = ParseDouble(rectElement.Attribute("x")?.Value) ?? 0;
                var y = ParseDouble(rectElement.Attribute("y")?.Value) ?? 0;
                var width = ParseDouble(rectElement.Attribute("width")?.Value) ?? 0;
                var height = ParseDouble(rectElement.Attribute("height")?.Value) ?? 0;
                if (width > 0 && height > 0)
                {
                    var style = ParseStyle(rectElement, null, parentStyle);
                    var rectangle = new ODRectangle(
                        new ODVec2(x, y),
                        new ODVec2(x + width, y + height)
                    );
                    ApplyCADMetadata(rectangle, rectElement);
                    rectangles.Add(rectangle);
                }
            }
            return rectangles;
        }
        private List<ODElement> ImportLines(XElement parentElement, ODSvgStyle? parentStyle = null)
        {
            var lines = new List<ODElement>();
            foreach (var lineElement in parentElement.Descendants(_ns + "line"))
            {
                var x1 = ParseDouble(lineElement.Attribute("x1")?.Value) ?? 0;
                var y1 = ParseDouble(lineElement.Attribute("y1")?.Value) ?? 0;
                var x2 = ParseDouble(lineElement.Attribute("x2")?.Value) ?? 0;
                var y2 = ParseDouble(lineElement.Attribute("y2")?.Value) ?? 0;
                var style = ParseStyle(lineElement, null, parentStyle);
                var line = new ODLine(
                    new ODVec2(x1, y1),
                    new ODVec2(x2, y2)
                );
                ApplyCADMetadata(line, lineElement);
                lines.Add(line);
            }
            return lines;
        }
        private List<ODElement> ImportCircles(XElement parentElement, ODSvgStyle? parentStyle = null)
        {
            var circles = new List<ODElement>();
            foreach (var circleElement in parentElement.Descendants(_ns + "circle"))
            {
                var cx = ParseDouble(circleElement.Attribute("cx")?.Value) ?? 0;
                var cy = ParseDouble(circleElement.Attribute("cy")?.Value) ?? 0;
                var r = ParseDouble(circleElement.Attribute("r")?.Value) ?? 0;
                if (r > 0)
                {
                    var style = ParseStyle(circleElement, null, parentStyle);
                    var circle = new ODCircle(
                        new ODVec2(cx, cy),
                        r
                    );
                    ApplyCADMetadata(circle, circleElement);
                    circles.Add(circle);
                }
            }
            return circles;
        }
        #endregion
        #region Path Data Parsing (Original Methods)
        private ODElement ParsePathData(string pathData, ODSvgStyle style)
        {
            try
            {
                var points = new List<ODVec2>();
                var tokens = TokenizePathData(pathData);
                double currentX = 0, currentY = 0;
                double startX = 0, startY = 0;
                bool hasValidData = false;
                for (int i = 0; i < tokens.Count; i++)
                {
                    var token = tokens[i];
                    var upperToken = token.ToUpper();
                    switch (upperToken)
                    {
                        case "M": // Move To
                            if (i + 2 < tokens.Count &&
                                TryParseDouble(tokens[i + 1], out double mx) &&
                                TryParseDouble(tokens[i + 2], out double my))
                            {
                                if (token == "m") // relative
                                {
                                    currentX += mx;
                                    currentY += my;
                                }
                                else // absolute
                                {
                                    currentX = mx;
                                    currentY = my;
                                }
                                startX = currentX;
                                startY = currentY;
                                points.Add(new ODVec2(currentX, currentY));
                                i += 2;
                                hasValidData = true;
                            }
                            break;
                        case "L": // Line To
                            if (i + 2 < tokens.Count &&
                                TryParseDouble(tokens[i + 1], out double lx) &&
                                TryParseDouble(tokens[i + 2], out double ly))
                            {
                                if (token == "l") // relative
                                {
                                    currentX += lx;
                                    currentY += ly;
                                }
                                else // absolute
                                {
                                    currentX = lx;
                                    currentY = ly;
                                }
                                points.Add(new ODVec2(currentX, currentY));
                                i += 2;
                                hasValidData = true;
                            }
                            break;
                        case "H": // Horizontal Line To
                            if (i + 1 < tokens.Count &&
                                TryParseDouble(tokens[i + 1], out double hx))
                            {
                                if (token == "h") // relative
                                {
                                    currentX += hx;
                                }
                                else // absolute
                                {
                                    currentX = hx;
                                }
                                points.Add(new ODVec2(currentX, currentY));
                                i += 1;
                                hasValidData = true;
                            }
                            break;
                        case "V": // Vertical Line To
                            if (i + 1 < tokens.Count &&
                                TryParseDouble(tokens[i + 1], out double vy))
                            {
                                if (token == "v") // relative
                                {
                                    currentY += vy;
                                }
                                else // absolute
                                {
                                    currentY = vy;
                                }
                                points.Add(new ODVec2(currentX, currentY));
                                i += 1;
                                hasValidData = true;
                            }
                            break;
                        case "Z": // Close Path
                            if (points.Count > 0)
                            {
                                // Close the path by returning to start point
                                points.Add(new ODVec2(startX, startY));
                                hasValidData = true;
                            }
                            break;
                        default:
                            // Skip unknown commands and their parameters
                            if (IsCommandToken(token))
                            {
                                // Skip the command and its parameters
                                i += GetParameterCountForCommand(token);
                            }
                            break;
                    }
                }
                if (hasValidData && points.Count > 1)
                {
                    return new ODPolyline(points);
                }
            }
            catch (Exception ex)
            {
                Debug.WriteLine($"Error parsing path data: {ex.Message}");
                Debug.WriteLine($"Path data: {pathData}");
            }
            return null;
        }
        private List<string> TokenizePathData(string pathData)
        {
            var tokens = new List<string>();
            if (string.IsNullOrEmpty(pathData)) return tokens;
            var currentToken = new StringBuilder();
            bool inNumber = false;
            foreach (char c in pathData)
            {
                if (char.IsWhiteSpace(c) || c == ',')
                {
                    if (currentToken.Length > 0)
                    {
                        tokens.Add(currentToken.ToString());
                        currentToken.Clear();
                    }
                    inNumber = false;
                }
                else if (char.IsLetter(c) && c != '.' && c != '-')
                {
                    if (currentToken.Length > 0)
                    {
                        tokens.Add(currentToken.ToString());
                        currentToken.Clear();
                    }
                    currentToken.Append(c);
                    tokens.Add(currentToken.ToString());
                    currentToken.Clear();
                    inNumber = false;
                }
                else if (c == '-' && inNumber)
                {
                    // Negative sign in the middle of tokens indicates a new number
                    if (currentToken.Length > 0)
                    {
                        tokens.Add(currentToken.ToString());
                        currentToken.Clear();
                    }
                    currentToken.Append(c);
                    inNumber = true;
                }
                else
                {
                    // Number or decimal point or negative sign at start
                    currentToken.Append(c);
                    inNumber = true;
                }
            }
            // Add the last token
            if (currentToken.Length > 0)
            {
                tokens.Add(currentToken.ToString());
            }
            return tokens;
        }
        private bool TryParseDouble(string value, out double result)
        {
            // Handle culture-specific formatting
            return double.TryParse(value,
                System.Globalization.NumberStyles.Float,
                System.Globalization.CultureInfo.InvariantCulture,
                out result);
        }
        private bool IsCommandToken(string token)
        {
            if (string.IsNullOrEmpty(token)) return false;
            char firstChar = token[0];
            return "MLHVCSQTAZ".Contains(char.ToUpper(firstChar));
        }
        private int GetParameterCountForCommand(string command)
        {
            if (string.IsNullOrEmpty(command)) return 0;
            return char.ToUpper(command[0]) switch
            {
                'M' or 'L' or 'T' => 2,  // Move, Line, Smooth Quadratic
                'H' or 'V' => 1,         // Horizontal, Vertical
                'S' or 'Q' => 4,         // Smooth Curve, Quadratic
                'C' => 6,                // Curve
                'A' => 7,                // Arc
                'Z' => 0,                // Close path
                _ => 0
            };
        }
        #endregion
        #region Enhanced Style Parsing
        private ODSvgStyle ParseStyle(XElement element, string? layerId = null, ODSvgStyle? parentStyle = null)
        {
            var style = parentStyle ?? new ODSvgStyle();
            // Apply layer style if layer ID is provided
            if (layerId != null && _layers.TryGetValue(layerId, out var layer))
            {
                style.StrokeColor = layer.Color;
                style.StrokeWidth = layer.LineWeight;
                style.LineType = layer.LineType;
                style.LayerName = layer.Name;
                style.IsVisible = layer.Visible;
                style.IsLocked = layer.Locked;
            }
            // Parse element-specific style attributes
            var styleAttr = element.Attribute("style")?.Value;
            if (!string.IsNullOrEmpty(styleAttr))
            {
                var styleParts = styleAttr.Split(';');
                foreach (var part in styleParts)
                {
                    var keyValue = part.Split(':');
                    if (keyValue.Length == 2)
                    {
                        var key = keyValue[0].Trim();
                        var value = keyValue[1].Trim();
                        switch (key)
                        {
                            case "stroke":
                                style.StrokeColor = ParseColor(value);
                                break;
                            case "stroke-width":
                                if (ParseDouble(value) is double strokeWidth)
                                    style.StrokeWidth = strokeWidth;
                                break;
                            case "stroke-dasharray":
                                style.LineType = ParseLineType(value);
                                break;
                            case "fill":
                                style.FillColor = ParseColor(value);
                                break;
                        }
                    }
                }
            }
            // Parse individual attributes (override style attribute)
            var strokeAttr = element.Attribute("stroke")?.Value;
            if (!string.IsNullOrEmpty(strokeAttr))
                style.StrokeColor = ParseColor(strokeAttr);
            var strokeWidthAttr = element.Attribute("stroke-width")?.Value;
            if (!string.IsNullOrEmpty(strokeWidthAttr) && ParseDouble(strokeWidthAttr) is double sw)
                style.StrokeWidth = sw;
            var fillAttr = element.Attribute("fill")?.Value;
            if (!string.IsNullOrEmpty(fillAttr))
                style.FillColor = ParseColor(fillAttr);
            return style;
        }
        private void ApplyCADMetadata(ODElement element, XElement xmlElement)
        {
            // Extract CAD-specific attributes
            var cadType = xmlElement.Attribute(_cadNs + "type")?.Value;
            var cadLayer = xmlElement.Attribute(_cadNs + "layer-id")?.Value;
            var isBlockRef = xmlElement.Attribute(_cadNs + "blockref")?.Value == "true";
            // Store CAD metadata in your element
            // This depends on your ODElement implementation
            // You might want to add CADMetadata property to ODElement
        }
        #endregion
        #region Utility Methods (Original + Enhanced)
        private DateTime? ParseDateTime(string value)
        {
            if (string.IsNullOrEmpty(value)) return null;
            return DateTime.TryParse(value, System.Globalization.CultureInfo.InvariantCulture,
                System.Globalization.DateTimeStyles.None, out DateTime result) ? result : null;
        }
        private ODColour ParseColor(string colorValue)
        {
            if (string.IsNullOrEmpty(colorValue) || colorValue == "none")
                return ODColour.Transparent;
            // Handle rgb() format
            if (colorValue.StartsWith("rgb("))
            {
                var parts = colorValue.Substring(4, colorValue.Length - 5).Split(',');
                if (parts.Length == 3 &&
                    byte.TryParse(parts[0], out byte r) &&
                    byte.TryParse(parts[1], out byte g) &&
                    byte.TryParse(parts[2], out byte b))
                {
                    return new ODColour(r, g, b);
                }
            }
            // Handle hex colors
            if (colorValue.StartsWith("#"))
            {
                try
                {
                    return new ODColour(colorValue);
                }
                catch
                {
                    // Fall through to named colors
                }
            }
            // Handle named colors
            return colorValue.ToLower() switch
            {
                "black" => ODColour.Black,
                "red" => ODColour.Red,
                "green" => ODColour.Green,
                "blue" => ODColour.Blue,
                "white" => ODColour.White,
                _ => ODColour.Black // Default
            };
        }
        private string ParseLineType(string dashArray)
        {
            if (string.IsNullOrEmpty(dashArray) || dashArray == "none")
                return "Continuous";
            // Simple dash array parsing
            var parts = dashArray.Split(',');
            if (parts.Length >= 2 &&
                ParseDouble(parts[0]) is double dash &&
                ParseDouble(parts[1]) is double gap)
            {
                if (dash == 10 && gap == 5) return "Dashed";
                if (dash == 2 && gap == 5) return "Dotted";
                // Add more patterns as needed
            }
            return "Continuous";
        }
        private double? ParseDouble(string value)
        {
            if (string.IsNullOrEmpty(value)) return null;
            // Remove units if present
            value = value.Trim().ToLower();
            if (value.EndsWith("px")) value = value[..^2];
            else if (value.EndsWith("mm"))
            {
                value = value[..^2];
                if (double.TryParse(value, System.Globalization.NumberStyles.Any,
                    System.Globalization.CultureInfo.InvariantCulture, out double mm))
                    return mm * 3.779527559;
                return null;
            }
            // Add other unit conversions as needed
            if (double.TryParse(value, System.Globalization.NumberStyles.Any,
                System.Globalization.CultureInfo.InvariantCulture, out double result))
                return result;
            return null;
        }
        private double ParseDimension(string value)
        {
            if (string.IsNullOrEmpty(value)) return 0;
            // Remove units and parse
            value = value.Trim().ToLower();
            // Handle common units
            if (value.EndsWith("px")) value = value[..^2];
            else if (value.EndsWith("pt")) value = value[..^2];
            else if (value.EndsWith("mm"))
            {
                value = value[..^2];
                if (double.TryParse(value, System.Globalization.NumberStyles.Any,
                    System.Globalization.CultureInfo.InvariantCulture, out double mm))
                    return mm * 3.779527559; // Convert mm to pixels
            }
            else if (value.EndsWith("cm"))
            {
                value = value[..^2];
                if (double.TryParse(value, System.Globalization.NumberStyles.Any,
                    System.Globalization.CultureInfo.InvariantCulture, out double cm))
                    return cm * 37.795275591; // Convert cm to pixels
            }
            else if (value.EndsWith("in"))
            {
                value = value[..^2];
                if (double.TryParse(value, System.Globalization.NumberStyles.Any,
                    System.Globalization.CultureInfo.InvariantCulture, out double inches))
                    return inches * 96; // Convert inches to pixels
            }
            return double.TryParse(value, System.Globalization.NumberStyles.Any,
                System.Globalization.CultureInfo.InvariantCulture, out double result) ? result : 0;
        }
        private (double Width, double Height)? ParseViewBox(string viewBoxValue)
        {
            if (string.IsNullOrEmpty(viewBoxValue)) return null;
            var parts = viewBoxValue.Split(new[] { ' ', ',' }, StringSplitOptions.RemoveEmptyEntries);
            if (parts.Length >= 4 &&
                double.TryParse(parts[2], System.Globalization.NumberStyles.Any,
                    System.Globalization.CultureInfo.InvariantCulture, out double width) &&
                double.TryParse(parts[3], System.Globalization.NumberStyles.Any,
                    System.Globalization.CultureInfo.InvariantCulture, out double height))
            {
                return (width, height);
            }
            return null;
        }
        #endregion
        #region Properties and Public Methods
        public CADMetadata Metadata => _metadata;
        public IReadOnlyDictionary<string, CADLayer> Layers => _layers;
        public bool IsLoaded => _xDocument != null;
        public ODVec2 GetDimensions()
        {
            if (_xDocument == null)
                throw new InvalidOperationException("No SVG file loaded. Call LoadSvgFile first.");
            var svgElement = _xDocument.Root;
            var width = ParseDimension(svgElement.Attribute("width")?.Value);
            var height = ParseDimension(svgElement.Attribute("height")?.Value);
            // Fallback to viewBox if dimensions aren't found
            if (width == 0 || height == 0)
            {
                var viewBox = ParseViewBox(svgElement.Attribute("viewBox")?.Value);
                if (viewBox.HasValue)
                {
                    width = width == 0 ? viewBox.Value.Width : width;
                    height = height == 0 ? viewBox.Value.Height : height;
                }
            }
            Debug.WriteLine($"SVG Dimensions: Width={width}, Height={height}");
            return new ODVec2(width, height);
        }
        public void Unload()
        {
            _xDocument = null;
            _filePath = null;
            _layers.Clear();
            _blockDefinitions.Clear();
            _metadata = new CADMetadata();
        }
        #endregion
    }
    public class CADMetadata
    {
        public string? AppVersion { get; set; }
        public string? FileVersion { get; set; }
        public string? Units { get; set; }
        public double Precision { get; set; }
        public string? Application { get; set; }
        public string? Version { get; set; }
        public DateTime? Created { get; set; }
        public DateTime? Modified { get; set; }
        public string? Title { get; set; }
        public string? Creator { get; set; }
        public string? Description { get; set; }
        public Dictionary<string, string>? Properties { get; set; }
    }
}

** ODXsvgReader.cs **
Path: D:\OpenDraft\OpenDraft\XSVG\ODXsvgReader.cs

ï»¿using OpenDraft.ODCore.ODGeometry;
using System;
using System.Collections.Generic;
using System.Diagnostics;
using System.IO;
using System.IO.Compression;
using System.Linq;
namespace OpenDraft.XSVG
{
    internal class ODXsvgReader
    {
        private static readonly List<string> _tempDirectories = new List<string>();
        private readonly string _filePath;
        private readonly string _tempPath;
        private bool _isValid = false;
        public static void CleanupAllTempFiles()
        {
            Debug.WriteLine($"Cleaning up {_tempDirectories.Count} temporary directories...");
            foreach (string dir in _tempDirectories.ToList())
            {
                try
                {
                    if (Directory.Exists(dir))
                    {
                        Directory.Delete(dir, true);
                        Debug.WriteLine($"Cleaned up temp directory: {dir}");
                    }
                    _tempDirectories.Remove(dir);
                }
                catch (Exception ex)
                {
                    Debug.WriteLine($"Failed to delete temp directory {dir}: {ex.Message}");
                }
            }
            Debug.WriteLine("Cleanup completed.");
        }
        public static bool IsValidXSVGFile(string filePath)
        {
            if (string.IsNullOrEmpty(filePath))
                return false;
            if (!File.Exists(filePath))
            {
                Debug.WriteLine($"File does not exist: {filePath}");
                return false;
            }
            try
            {
                FileInfo fileInfo = new FileInfo(filePath);
                if (fileInfo.Length == 0)
                {
                    Debug.WriteLine($"File is empty: {filePath}");
                    return false;
                }
                // Check file signature (first 4 bytes of ZIP file)
                byte[] zipSignature = new byte[] { 0x50, 0x4B, 0x03, 0x04 };
                byte[] fileSignature = new byte[4];
                using (FileStream fs = new FileStream(filePath, FileMode.Open, FileAccess.Read))
                {
                    if (fs.Read(fileSignature, 0, 4) != 4)
                    {
                        Debug.WriteLine($"Cannot read file signature: {filePath}");
                        return false;
                    }
                }
                if (!fileSignature.SequenceEqual(zipSignature))
                {
                    Debug.WriteLine($"File is not a ZIP file (invalid signature): {filePath}");
                    return false;
                }
                return true;
            }
            catch (Exception ex)
            {
                Debug.WriteLine($"File validation failed for {filePath}: {ex.Message}");
                return false;
            }
        }
        public ODXsvgReader(string filePath)
        {
            _filePath = filePath ?? throw new ArgumentNullException(nameof(filePath));
            Debug.WriteLine($"Attempting to open XSVG file: {_filePath}");
            // Step 1: Check if file exists
            if (!File.Exists(_filePath))
            {
                throw new FileNotFoundException($"XSVG file not found: {_filePath}");
            }
            // Step 2: Check file size
            FileInfo fileInfo = new FileInfo(_filePath);
            if (fileInfo.Length == 0)
            {
                throw new InvalidDataException($"XSVG file is empty: {_filePath}");
            }
            // Step 3: Create temp directory
            _tempPath = Path.Combine(Path.GetTempPath(), "OpenDraft2D", Guid.NewGuid().ToString());
            Directory.CreateDirectory(_tempPath);
            _tempDirectories.Add(_tempPath);
            Debug.WriteLine($"Created temp directory: {_tempPath}");
            try
            {
                // Step 4: Extract
                Debug.WriteLine("Extracting ZIP contents...");
                ZipFile.ExtractToDirectory(_filePath, _tempPath);
                // Step 5: Validate XSVG structure
                Debug.WriteLine("Validating XSVG structure...");
                ValidateXSVGStructure();
                _isValid = true;
                Debug.WriteLine($"XSVGReader successfully loaded: {_filePath}");
            }
            catch (Exception ex)
            {
                Debug.WriteLine($"Failed to process XSVG file: {ex.Message}");
                CleanupThisTempDirectory();
                throw new IOException($"Failed to read XSVG file '{_filePath}': {ex.Message}", ex);
            }
        }
        public List<ODElement> ExtractModelSpace()
        {
            Debug.WriteLine("Begining parsing of files...");
            ODSvgReader svgR = new ODSvgReader();
            svgR.LoadSvgFile(GetFullPath("mod/ms.svg"));
            return svgR.ImportGeometry();
        }
        private void ValidateXSVGStructure()
        {
            // Check for required XSVG directories and files
            string[] requiredDirs = { "lay", "meta", "mod", "res" };
            string[] requiredFiles = { "manifest.json", "meta/meta.json", "mod/ms.svg" };
            foreach (string dir in requiredDirs)
            {
                string dirPath = Path.Combine(_tempPath, dir);
                if (!Directory.Exists(dirPath))
                {
                    throw new InvalidDataException($"Required directory '{dir}' not found in XSVG file");
                }
            }
            foreach (string file in requiredFiles)
            {
                string filePath = Path.Combine(_tempPath, file);
                if (!File.Exists(filePath))
                {
                    throw new InvalidDataException($"Required file '{file}' not found in XSVG file");
                }
            }
            Debug.WriteLine("XSVG structure validation passed");
        }
        public string TempPath
        {
            get
            {
                if (!_isValid) throw new InvalidOperationException("XSVGReader is not in a valid state");
                return _tempPath;
            }
        }
        public string FilePath => _filePath;
        public bool IsValid => _isValid;
        public string GetFullPath(string relativePath)
        {
            if (!_isValid)
                throw new InvalidOperationException("XSVGReader is not in a valid state");
            string fullPath = Path.Combine(_tempPath, relativePath);
            if (!File.Exists(fullPath) && !Directory.Exists(fullPath))
                throw new FileNotFoundException($"Path '{relativePath}' not found in XSVG file");
            return fullPath;
        }
        public bool PathExists(string relativePath)
        {
            if (!_isValid) return false;
            string fullPath = Path.Combine(_tempPath, relativePath);
            return File.Exists(fullPath) || Directory.Exists(fullPath);
        }
        public string ReadManifest()
        {
            return File.ReadAllText(GetFullPath("manifest.json"));
        }
        public string ReadMetaJson()
        {
            return File.ReadAllText(GetFullPath("meta.json"));
        }
        public string[] GetLayerFiles()
        {
            if (!_isValid) return Array.Empty<string>();
            string layDir = Path.Combine(_tempPath, "lay");
            return Directory.Exists(layDir)
                ? Directory.GetFiles(layDir)
                : Array.Empty<string>();
        }
        public string[] GetResourceFiles()
        {
            if (!_isValid) return Array.Empty<string>();
            string resDir = Path.Combine(_tempPath, "res");
            return Directory.Exists(resDir)
                ? Directory.GetFiles(resDir)
                : Array.Empty<string>();
        }
        public string GetModelSvg()
        {
            return File.ReadAllText(GetFullPath("mod/ms.svg"));
        }
        private void CleanupThisTempDirectory()
        {
            try
            {
                if (!string.IsNullOrEmpty(_tempPath) && Directory.Exists(_tempPath))
                {
                    Directory.Delete(_tempPath, true);
                    _tempDirectories.Remove(_tempPath);
                    Debug.WriteLine($"Cleaned up temp directory: {_tempPath}");
                }
            }
            catch (Exception ex)
            {
                Debug.WriteLine($"Warning: Failed to clean up temp directory {_tempPath}: {ex.Message}");
            }
        }
        // Optional: Method to clean up this specific instance if needed before app closure
        public void Cleanup()
        {
            CleanupThisTempDirectory();
        }
    }
}