

** App.axaml **
Path: .\App.axaml

<Application xmlns="https://github.com/avaloniaui"
             xmlns:x="http://schemas.microsoft.com/winfx/2006/xaml"
             x:Class="OpenDraft.App"
             xmlns:local="using:OpenDraft"
             RequestedThemeVariant="Default">
             <!-- "Default" ThemeVariant follows system theme variant. "Dark" or "Light" are other available options. -->

    <Application.DataTemplates>
        <local:ViewLocator/>
    </Application.DataTemplates>
  
    <Application.Styles>
        <FluentTheme />
    </Application.Styles>
</Application>




** App.axaml.cs **
Path: .\App.axaml.cs

using System.Linq;
using Avalonia;
using Avalonia.Controls.ApplicationLifetimes;
using Avalonia.Data.Core;
using Avalonia.Data.Core.Plugins;
using Avalonia.Markup.Xaml;
using OpenDraft.ViewModels;
using OpenDraft.Views;

namespace OpenDraft
{
    public partial class App : Application
    {
        public override void Initialize()
        {
            AvaloniaXamlLoader.Load(this);
        }

        public override void OnFrameworkInitializationCompleted()
        {
            if (ApplicationLifetime is IClassicDesktopStyleApplicationLifetime desktop)
            {
                // Avoid duplicate validations from both Avalonia and the CommunityToolkit. 
                // More info: https://docs.avaloniaui.net/docs/guides/development-guides/data-validation#manage-validationplugins
                DisableAvaloniaDataAnnotationValidation();
                desktop.MainWindow = new MainWindow
                {
                    DataContext = new MainWindowViewModel(),
                };
            }

            base.OnFrameworkInitializationCompleted();
        }

        private void DisableAvaloniaDataAnnotationValidation()
        {
            // Get an array of plugins to remove
            var dataValidationPluginsToRemove =
                BindingPlugins.DataValidators.OfType<DataAnnotationsValidationPlugin>().ToArray();

            // remove each entry found
            foreach (var plugin in dataValidationPluginsToRemove)
            {
                BindingPlugins.DataValidators.Remove(plugin);
            }
        }
    }
}




** Program.cs **
Path: .\Program.cs

ï»¿using System;
using Avalonia;

namespace OpenDraft
{
    internal sealed class Program
    {
        // Initialization code. Don't use any Avalonia, third-party APIs or any
        // SynchronizationContext-reliant code before AppMain is called: things aren't initialized
        // yet and stuff might break.
        [STAThread]
        public static void Main(string[] args) => BuildAvaloniaApp()
            .StartWithClassicDesktopLifetime(args);

        // Avalonia configuration, don't remove; also used by visual designer.
        public static AppBuilder BuildAvaloniaApp()
            => AppBuilder.Configure<App>()
                .UsePlatformDetect()
                .WithInterFont()
                .LogToTrace();
    }
}





** ViewLocator.cs **
Path: .\ViewLocator.cs

using System;
using Avalonia.Controls;
using Avalonia.Controls.Templates;
using OpenDraft.ViewModels;

namespace OpenDraft
{
    public class ViewLocator : IDataTemplate
    {

        public Control? Build(object? param)
        {
            if (param is null)
                return null;

            var name = param.GetType().FullName!.Replace("ViewModel", "View", StringComparison.Ordinal);
            var type = Type.GetType(name);

            if (type != null)
            {
                return (Control)Activator.CreateInstance(type)!;
            }

            return new TextBlock { Text = "Not Found: " + name };
        }

        public bool Match(object? data)
        {
            return data is ViewModelBase;
        }
    }
}





** Viewport.axaml **
Path: .\ODCore\Viewport.axaml

<UserControl xmlns="https://github.com/avaloniaui"
             xmlns:x="http://schemas.microsoft.com/winfx/2006/xaml"
             xmlns:d="http://schemas.microsoft.com/expression/blend/2008"
             xmlns:mc="http://schemas.openxmlformats.org/markup-compatibility/2006"
             mc:Ignorable="d" d:DesignWidth="800" d:DesignHeight="450"
             x:Class="OpenDraft.Viewport">
</UserControl>





** Viewport.axaml.cs **
Path: .\ODCore\Viewport.axaml.cs

using Avalonia;
using Avalonia.Controls;
using Avalonia.Input;
using Avalonia.Media;
using OpenDraft.ODCore.ODData;
using OpenDraft.ODCore.ODEditor;
using OpenDraft.ODCore.ODGeometry;
using System;
using System.Collections.ObjectModel;
using System.Diagnostics;


namespace OpenDraft
{
    public class ViewportCamera
    {
        public Point Position { get; set; }
        public float Scale { get; set; }

        public ViewportCamera(Point? position = null, float scale = 1.0f)
        {
            Position = position ?? new Point(0, 0);
            Scale = scale;
        }

        public void MoveBy(Vector delta) => Position += new Point(delta.X, delta.Y);
    }

    public partial class Viewport : UserControl
    {
        public static readonly StyledProperty<ObservableCollection<ODElement>> ElementsProperty =
            AvaloniaProperty.Register<Viewport, ObservableCollection<ODElement>>(nameof(Elements));

        public static readonly StyledProperty<ODLayerManager> LayerManagerProperty =
            AvaloniaProperty.Register<Viewport, ODLayerManager>(nameof(LayerManager));

        public static readonly StyledProperty<ODEditor> EditorProperty =
            AvaloniaProperty.Register<Viewport, ODEditor>(nameof(Editor));

        public ObservableCollection<ODElement> Elements
        {
            get => GetValue(ElementsProperty);
            set => SetValue(ElementsProperty, value);
        }

        public ODLayerManager LayerManager
        {
            get => GetValue(LayerManagerProperty);
            set => SetValue(LayerManagerProperty, value);
        }

        public ODEditor Editor
        {
            get => GetValue(EditorProperty);
            set => SetValue(EditorProperty, value);
        }

        private readonly ViewportCamera Camera = new();
        private bool isPanning = false;
        private Point _lastPointerDragPosition;
        private Point _mousePosition;
        private Size _lastSize;
        private bool _isInitialized = false;

        public Viewport()
        {
            InitializeComponent();
            Background = Brushes.Transparent;

            Elements ??= new ObservableCollection<ODElement>();
            SubscribeToElements();

            PointerPressed += OnPointerPressed;
            PointerReleased += OnPointerReleased;
            PointerMoved += OnPointerMoved;
            PointerWheelChanged += OnPointerWheelChanged;

            InvalidateVisual();
        }

        private void SubscribeToElements()
        {
            if (Elements != null)
            {
                Elements.CollectionChanged -= OnElementsChanged;
                Elements.CollectionChanged += OnElementsChanged;
            }
        }

        private void OnElementsChanged(object? sender, System.Collections.Specialized.NotifyCollectionChangedEventArgs e)
        {
            InvalidateVisual();
        }

        protected override Size ArrangeOverride(Size finalSize)
        {
            if (!_isInitialized)
            {
                _isInitialized = true;
                Camera.Position = new Point(-finalSize.Width / 2 / Camera.Scale,
                                            -finalSize.Height / 2 / Camera.Scale);
            }
            else
            {
                // Keep view centered on resize
                Camera.Position -= new Point(
                    (finalSize.Width - _lastSize.Width) / 2 / Camera.Scale,
                    (finalSize.Height - _lastSize.Height) / 2 / Camera.Scale
                );
            }

            _lastSize = finalSize;

            // Force redraw
            InvalidateVisual();

            return base.ArrangeOverride(finalSize);
        }


        protected override void OnPropertyChanged(AvaloniaPropertyChangedEventArgs change)
        {
            base.OnPropertyChanged(change);

            if (change.Property == ElementsProperty)
                SubscribeToElements();
        }


        private void OnPointerPressed(object? sender, PointerPressedEventArgs e)
        {
            if (e.GetCurrentPoint(this).Properties.IsMiddleButtonPressed)
            {
                _lastPointerDragPosition = e.GetPosition(this);
                isPanning = true;
            }
        }

        private void OnPointerReleased(object? sender, PointerReleasedEventArgs e)
        {
            if (e.InitialPressMouseButton == MouseButton.Left)
            {
                Point worldPos = GetWorldMousePosition();
                var odPoint = new ODPoint(worldPos.X, worldPos.Y);
                Debug.WriteLine($"Left click released at: ({worldPos.X}, {worldPos.Y})");

                // Send directly to editor (no threading)
                Editor?.HandlePointInput(odPoint);
                e.Handled = true;
            }

            if (e.InitialPressMouseButton == MouseButton.Middle)
                isPanning = false;
        }

        private void OnPointerMoved(object? sender, PointerEventArgs e)
        {
            _mousePosition = e.GetPosition(this);
            Point world = GetWorldMousePosition();
            //Debug.WriteLine($"Mouse moved to: ({_mousePosition.X}, {_mousePosition.Y}) => World: ({world.X}, {world.Y})");


            if (!isPanning) return;

            Point current = e.GetPosition(this);
            Camera.MoveBy(new Vector(-(current.X - _lastPointerDragPosition.X) / Camera.Scale,
                                     (current.Y - _lastPointerDragPosition.Y) / Camera.Scale));
            _lastPointerDragPosition = current;

            InvalidateVisual();
        }

        private void OnPointerWheelChanged(object? sender, PointerWheelEventArgs e)
        {
            Point mousePos = e.GetPosition(this);

            float zoomFactor = 1.1f;
            float oldScale = Camera.Scale;
            float newScale = oldScale * (float)Math.Pow(zoomFactor, e.Delta.Y > 0 ? 1 : -1);

            Point ScreenToWorld(Point screen, float scale) =>
                new(screen.X / scale - Camera.Position.X, (Bounds.Height - screen.Y) / scale - Camera.Position.Y);

            var oldWorld = ScreenToWorld(mousePos, oldScale);
            var newWorld = ScreenToWorld(mousePos, newScale);

            Camera.Position += oldWorld - newWorld;
            Camera.Scale = newScale;

            InvalidateVisual();
        }

        public override void Render(DrawingContext context)
        {
            base.Render(context);

            var bounds = new Rect(0, 0, Bounds.Width, Bounds.Height);
            using (context.PushClip(bounds))
            {
                DrawScene(context);
            }
        }

        public Point GetScreenMousePosition()
        {
             return _mousePosition;
        }

        public Point GetWorldMousePosition()
        {
            return ScreenToWorld(_mousePosition);
        }

        private Point ScreenToWorld(Point screenPoint)
        {
            return new Point(
                screenPoint.X / Camera.Scale + Camera.Position.X,
                (Bounds.Height - screenPoint.Y) / Camera.Scale + Camera.Position.Y
            );
        }

        private void DrawScene(DrawingContext context)
        {
            if (Elements == null || Elements.Count == 0)
                return;

            var matrix = new Matrix(
                Camera.Scale, 0,
                0, -Camera.Scale,
                -Camera.Position.X * Camera.Scale,
                Camera.Position.Y * Camera.Scale + Bounds.Height
            );

            using (context.PushTransform(matrix))
            {
                foreach (var element in Elements)
                {
                    Debug.WriteLine($"Drawing element ID: {element.Id}, Type: {element.GetType().Name}");

                    var layer = LayerManager?.GetLayerByID(element.LayerId);

                    if (layer != null)
                        element.Draw(context, layer);
                }
            }
        }
    }
}





** ODDataManager.cs **
Path: .\ODCore\ODData\ODDataManager.cs

ï»¿using CommunityToolkit.Mvvm.ComponentModel;
using OpenDraft.ODCore.ODGeometry;
using System;
using System.Collections.Generic;
using System.Collections.ObjectModel;
using System.Linq;
using System.Text;
using System.Threading.Tasks;

namespace OpenDraft.ODCore.ODData
{
    public class ODDataManager
    {
        public ObservableCollection<ODGeometry.ODElement> Elements { get; } = new();
        public ODLayerManager LayerManager { get; } = new ODLayerManager();

        public ODDataManager()
        {

        }


        public void AddElement(ODElement element)
        {
            if (element == null)
                throw new ArgumentNullException(nameof(element));

            element.LayerId = LayerManager.GetActiveLayer();
            Elements.Add(element);
        }
    }
}





** ODLayer.cs **
Path: .\ODCore\ODData\ODLayer.cs

ï»¿using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading.Tasks;

namespace OpenDraft.ODCore.ODData
{
    public class ODLayer
    {
        private ushort _id;
        public String Name { get; set; } = Guid.NewGuid().ToString();
        public String Color { get; set; } = "#FFFFFF";
        public String LineType { get; set; } = "Continuous";
        public float LineWeight { get; set; } = 0.6f;
        public bool IsVisible { get; set; } = true;
        public bool IsLocked { get; set; } = false;
        
        public ODLayer(ushort id, String name)
        {
            _id = id;
            Name = name;
        }

        public ushort getID()
        {
            return _id;
        }
    }
}





** ODLayerManager.cs **
Path: .\ODCore\ODData\ODLayerManager.cs

ï»¿using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading.Tasks;

namespace OpenDraft.ODCore.ODData
{
    public class ODLayerManager
    {
        private List<ODLayer> Layers { get; set; } = new List<ODLayer>();
        private ushort ActiveLayer { get; set; }

        public ODLayerManager()
        {
            // Add a default layer
            AddLayer("Default");
        }


        private ushort GetNextAvailableID()
        {
            HashSet<ushort> usedIDs = new HashSet<ushort>(Layers.Select(layer => layer.getID()));
            for (ushort id = 0; id < ushort.MaxValue; id++)
            {
                if (!usedIDs.Contains(id))
                    return id;
            }
            throw new InvalidOperationException("No available layer IDs.");
        }


        public ushort GetActiveLayer()
        {
            return ActiveLayer;
        }


        public ushort AddLayer(string name)
        {
            ushort newID = GetNextAvailableID();

            ODLayer newLayer = new ODLayer(newID, name);
            Layers.Add(newLayer);
            return newID;
        }

        public ODLayer? GetLayerByName(string name)
        {
            return Layers.FirstOrDefault(layer => layer.Name == name);
        }

        public ODLayer? GetLayerByID(ushort id)
        {
            return Layers.FirstOrDefault(layer => layer.getID() == id);
        }

        public void SetActiveLayer(string name)
        {
            ODLayer? layer = GetLayerByName(name);
            if (layer != null)
            {
                ActiveLayer = layer.getID();
            }
            else
            {
                throw new ArgumentException($"Layer with name '{name}' does not exist.");
            }
        }

        public void RemoveLayer(string name)
        {
            ODLayer? layerToRemove = GetLayerByName(name);

            if (layerToRemove != null)
            {
                if (ActiveLayer == layerToRemove.getID())
                {
                    SetActiveLayer("Default");
                }
                
                Layers.Remove(layerToRemove);
            }
        }
    }
}





** ODCommandAttribute.cs **
Path: .\ODCore\ODEditor\ODCommandAttribute.cs

ï»¿// ODCommandAttribute.cs
using System;

namespace OpenDraft.ODCore.ODEditor.ODCommands
{
    [AttributeUsage(AttributeTargets.Class, Inherited = false, AllowMultiple = false)]
    public class ODCommandAttribute : Attribute
    {
        public string Name { get; }
        public string Description { get; }
        public string[] Aliases { get; }

        public ODCommandAttribute(string name, string description = "", params string[] aliases)
        {
            Name = name;
            Description = description;
            Aliases = aliases;
        }
    }
}




** ODEditor.cs **
Path: .\ODCore\ODEditor\ODEditor.cs

ï»¿using Avalonia.Threading;
using OpenDraft.ODCore.ODEditor.ODCommands;
using OpenDraft.ODCore.ODData;
using OpenDraft.ODCore.ODGeometry;
using System;
using System.Diagnostics;
using System.Threading;
using System.Threading.Tasks;

namespace OpenDraft.ODCore.ODEditor
{
    public class ODEditor : IDisposable
    {
        private readonly ODDataManager _dataManager;
        private readonly ODCommandRegistry _commandRegistry;
        private ODEditorContext? _currentContext;
        private IODEditorCommand? _currentCommand;

        public event EventHandler<MessageEventArgs>? ShowMessageRequested;
        public event EventHandler<BoolEventArgs>? InputModeChanged;
        public event EventHandler<MessageEventArgs>? StatusMessageChanged;

        public ODEditor(ODDataManager dataManager)
        {
            _dataManager = dataManager;
            _commandRegistry = new ODCommandRegistry();
            _commandRegistry.RegisterAssembly(typeof(ODEditor).Assembly);
        }

        // THIS METHOD WAS ACCIDENTALLY REMOVED - RESTORE IT
        public void ExecuteCommand(string commandName)
        {
            Debug.WriteLine($"ExecuteCommand: {commandName}");

            // Cancel any running command and clear context
            CancelCurrentCommand();

            var command = _commandRegistry.CreateCommand(commandName);
            if (command == null)
            {
                SetStatus($"Unknown command: {commandName}");
                return;
            }

            _currentCommand = command;
            _currentContext = new ODEditorContext(this, _dataManager);

            // Use proper async execution
            async Task RunCommandAsync()
            {
                try
                {
                    await command.ExecuteAsync(_currentContext);
                }
                catch (Exception ex)
                {
                    SetStatus($"Error in {commandName}: {ex.Message}");
                    Debug.WriteLine($"Command error: {ex.Message}");
                }
                finally
                {
                    if (_currentCommand == command)
                    {
                        CancelCurrentCommand();
                    }
                }
            }

            _ = RunCommandAsync();
        }

        public void HandlePointInput(ODPoint point)
        {
            _currentContext?.ProvidePoint(point);
        }

        public void HandleNumberInput(double number)
        {
            _currentContext?.ProvideNumber(number);
        }

        public void HandleTextInput(string text)
        {
            _currentContext?.ProvideText(text);
        }

        public void CancelCurrentCommand()
        {
            _currentContext?.Cancel();
            _currentContext = null;
            _currentCommand = null;
        }

        public void SetStatus(string message)
        {
            Debug.WriteLine("SetStatus: " + message);
            Dispatcher.UIThread.Post(() =>
            {
                StatusMessageChanged?.Invoke(this, new MessageEventArgs(message));
            });
        }

        public void ShowMessage(string message)
        {
            Debug.WriteLine("ShowMessage: " + message);
            Dispatcher.UIThread.Post(() =>
            {
                ShowMessageRequested?.Invoke(this, new MessageEventArgs(message));
            });
        }

        public void Dispose()
        {
            CancelCurrentCommand();
        }
    }

    public class MessageEventArgs : EventArgs
    {
        public string Message { get; }
        public MessageEventArgs(string message) => Message = message;
    }

    public class BoolEventArgs : EventArgs
    {
        public bool Value { get; }
        public BoolEventArgs(bool value) => Value = value;
    }
}




** ODEditorContext.cs **
Path: .\ODCore\ODEditor\ODEditorContext.cs

ï»¿using OpenDraft.ODCore.ODData;
using OpenDraft.ODCore.ODEditor.ODCommands;
using OpenDraft.ODCore.ODGeometry;
using System;
using System.Threading;
using System.Threading.Tasks;

namespace OpenDraft.ODCore.ODEditor
{
    public class ODEditorContext : IODEditorGateway
    {
        private readonly ODEditor _editor;
        private readonly ODDataManager _dataManager;
        private readonly CancellationTokenSource _cancellationTokenSource;

        private TaskCompletionSource<ODPoint>? _pointWaiter;
        private TaskCompletionSource<double>? _numberWaiter;
        private TaskCompletionSource<string>? _textWaiter;
        private TaskCompletionSource<string>? _choiceWaiter;

        public ODDataManager DataManager => _dataManager;
        public CancellationToken CancellationToken => _cancellationTokenSource.Token;

        public ODEditorContext(ODEditor editor, ODDataManager dataManager)
        {
            _editor = editor;
            _dataManager = dataManager;
            _cancellationTokenSource = new CancellationTokenSource();
        }

        public Task<ODPoint> GetPointAsync(string prompt)
        {
            _editor.SetStatus(prompt);
            ClearAllWaiters();
            _pointWaiter = new TaskCompletionSource<ODPoint>();
            return _pointWaiter.Task;
        }

        public Task<double> GetNumberAsync(string prompt)
        {
            _editor.SetStatus(prompt);
            ClearAllWaiters();
            _numberWaiter = new TaskCompletionSource<double>();
            return _numberWaiter.Task;
        }

        public Task<string> GetTextAsync(string prompt)
        {
            _editor.SetStatus(prompt);
            ClearAllWaiters();
            _textWaiter = new TaskCompletionSource<string>();
            return _textWaiter.Task;
        }

        public Task<string> GetChoiceAsync(string prompt, params string[] options)
        {
            _editor.SetStatus(prompt);
            ClearAllWaiters();
            _choiceWaiter = new TaskCompletionSource<string>();
            return _choiceWaiter.Task;
        }

        public void ProvidePoint(ODPoint point)
        {
            if (point == null)
                throw new ArgumentNullException(nameof(point));

            if (_pointWaiter != null && !_pointWaiter.Task.IsCompleted)
            {
                _pointWaiter.TrySetResult(point);
            }
        }

        public void ProvideNumber(double number)
        {
            if (_numberWaiter != null && !_numberWaiter.Task.IsCompleted)
            {
                _numberWaiter.TrySetResult(number);
            }
        }

        public void ProvideText(string text)
        {
            if (_textWaiter != null && !_textWaiter.Task.IsCompleted)
            {
                _textWaiter.TrySetResult(text);
            }
        }

        public void ProvideChoice(string choice)
        {
            if (_choiceWaiter != null && !_choiceWaiter.Task.IsCompleted)
            {
                _choiceWaiter.TrySetResult(choice);
            }
        }

        public void Cancel()
        {
            _cancellationTokenSource.Cancel();
            _pointWaiter?.TrySetCanceled();
            _numberWaiter?.TrySetCanceled();
            _textWaiter?.TrySetCanceled();
            _choiceWaiter?.TrySetCanceled();
            ClearAllWaiters();
        }

        private void ClearAllWaiters()
        {
            _pointWaiter = null;
            _numberWaiter = null;
            _textWaiter = null;
            _choiceWaiter = null;
        }

        public void SetStatus(string message)
        {
            _editor.SetStatus(message);
        }

        public void ShowMessage(string message)
        {
            _editor.ShowMessage(message);
        }
    }
}




** IODEditorCommand.cs **
Path: .\ODCore\ODEditor\ODCommands\IODEditorCommand.cs

ï»¿using System.Threading.Tasks;

namespace OpenDraft.ODCore.ODEditor.ODCommands
{
    public interface IODEditorCommand
    {
        string Name { get; }
        string Description { get; }
        Task ExecuteAsync(IODEditorGateway editor);
    }
}




** IODEditorGateway.cs **
Path: .\ODCore\ODEditor\ODCommands\IODEditorGateway.cs

ï»¿using OpenDraft.ODCore.ODData;
using OpenDraft.ODCore.ODGeometry;
using System.Threading;
using System.Threading.Tasks;

namespace OpenDraft.ODCore.ODEditor.ODCommands
{
    public interface IODEditorGateway
    {
        ODDataManager DataManager { get; }

        Task<ODPoint> GetPointAsync(string prompt);
        Task<double> GetNumberAsync(string prompt);
        Task<string> GetTextAsync(string prompt);
        Task<string> GetChoiceAsync(string prompt, params string[] options);

        void SetStatus(string message);
        void ShowMessage(string message);

        // Add cancellation token for long-running operations
        CancellationToken CancellationToken { get; }
    }
}




** ODBaseEditorCommand.cs **
Path: .\ODCore\ODEditor\ODCommands\ODBaseEditorCommand.cs

ï»¿// ODBaseEditorCommand.cs
using OpenDraft.ODCore.ODGeometry;
using System;
using System.Reflection;
using System.Threading.Tasks;

namespace OpenDraft.ODCore.ODEditor.ODCommands
{
    public abstract class ODBaseEditorCommand : IODEditorCommand
    {
        private readonly Lazy<ODCommandAttribute> _attribute;

        public string Name => _attribute.Value.Name;
        public string Description => _attribute.Value.Description;

        protected ODBaseEditorCommand()
        {
            _attribute = new Lazy<ODCommandAttribute>(() =>
            {
                var attribute = GetType().GetCustomAttribute<ODCommandAttribute>();
                if (attribute == null)
                {
                    throw new InvalidOperationException(
                        $"Command {GetType().Name} must be decorated with [ODCommand] attribute");
                }
                return attribute;
            });
        }

        public abstract Task ExecuteAsync(IODEditorGateway editor);

        // Helper method for common validation
        protected void ValidatePoint(ODPoint point, string paramName)
        {
            if (point == null)
                throw new ArgumentNullException(paramName);

            if (double.IsNaN(point.X) || double.IsNaN(point.Y) ||
                double.IsInfinity(point.X) || double.IsInfinity(point.Y))
                throw new ArgumentException($"Invalid point coordinates: ({point.X}, {point.Y})", paramName);
        }
    }
}




** ODCircleCommand.cs **
Path: .\ODCore\ODEditor\ODCommands\ODCircleCommand.cs

ï»¿// ODCircleCommand.cs
using OpenDraft.ODCore.ODEditor.ODCommands;
using OpenDraft.ODCore.ODGeometry;
using System.Threading.Tasks;

namespace OpenDraft.ODCore.ODEditor.ODCommands
{
    [ODCommand("CIRCLE", "Creates a circle", "C")]
    public class ODCircleCommand : ODBaseEditorCommand
    {
        public override async Task ExecuteAsync(IODEditorGateway editor)
        {
            var center = await editor.GetPointAsync("Specify center point:");
            var radius = await editor.GetNumberAsync("Specify radius:");

            var circle = new ODCircle(center, radius);
            editor.DataManager.AddElement(circle); // Use DataManager directly

            editor.SetStatus("Circle created successfully");
        }
    }
}




** ODCommandRegistry.cs **
Path: .\ODCore\ODEditor\ODCommands\ODCommandRegistry.cs

ï»¿// ODCommandRegistry.cs
using System;
using System.Collections.Generic;
using System.Linq;
using System.Reflection;

namespace OpenDraft.ODCore.ODEditor.ODCommands
{
    public class ODCommandRegistry
    {
        private readonly Dictionary<string, Type> _commands = new Dictionary<string, Type>(StringComparer.OrdinalIgnoreCase);

        public void RegisterAssembly(Assembly assembly)
        {
            var commandTypes = assembly.GetTypes()
                .Where(t => typeof(IODEditorCommand).IsAssignableFrom(t) && !t.IsAbstract)
                .Where(t => t.GetCustomAttribute<ODCommandAttribute>() != null);

            foreach (var type in commandTypes)
            {
                var attribute = type.GetCustomAttribute<ODCommandAttribute>();
                if (attribute != null)
                {
                    _commands[attribute.Name] = type;

                    foreach (var alias in attribute.Aliases)
                    {
                        _commands[alias] = type;
                    }
                }
            }
        }

        public void RegisterCommand<T>(string name, params string[] aliases) where T : IODEditorCommand
        {
            _commands[name] = typeof(T);
            foreach (var alias in aliases)
            {
                _commands[alias] = typeof(T);
            }
        }

        public IODEditorCommand? CreateCommand(string commandName)
        {
            if (_commands.TryGetValue(commandName, out var commandType))
            {
                return (IODEditorCommand)Activator.CreateInstance(commandType);
            }
            return null;
        }

        public IEnumerable<string> GetRegisteredCommandNames()
        {
            return _commands.Keys.Distinct();
        }

        public string GetCommandDescription(string commandName)
        {
            if (_commands.TryGetValue(commandName, out var type))
            {
                var attribute = type.GetCustomAttribute<ODCommandAttribute>();
                return attribute?.Description ?? string.Empty;
            }
            return string.Empty;
        }
    }
}




** ODLineCommand.cs **
Path: .\ODCore\ODEditor\ODCommands\ODLineCommand.cs

ï»¿using OpenDraft.ODCore.ODEditor.ODCommands;
using OpenDraft.ODCore.ODGeometry;
using System.Diagnostics;
using System.Threading.Tasks;

namespace OpenDraft.ODCore.ODEditor.ODCommands
{
    [ODCommand("LINE", "Creates a line", "L")]
    public class ODLineCommand : ODBaseEditorCommand
    {
        public override async Task ExecuteAsync(IODEditorGateway editor)
        {
            Debug.WriteLine("ODLineCommand starting...");

            var startPoint = await editor.GetPointAsync("Specify first point:");
            Debug.WriteLine($"Got first point: ({startPoint.X}, {startPoint.Y})");

            var endPoint = await editor.GetPointAsync("Specify second point:");
            Debug.WriteLine($"Got second point: ({endPoint.X}, {endPoint.Y})");

            Debug.WriteLine("Creating line element...");
            var line = new ODLine(startPoint, endPoint);
            editor.DataManager.AddElement(line);

            Debug.WriteLine("ODLineCommand completed successfully");
            editor.SetStatus("Line created successfully");

            // The context will be cleared in the finally block of RunCommandAsync
        }
    }
}




** ODCircle.cs **
Path: .\ODCore\ODGeometry\ODCircle.cs

ï»¿using Avalonia;
using Avalonia.Media;
using OpenDraft.ODCore.ODData;
using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading.Tasks;

namespace OpenDraft.ODCore.ODGeometry
{
    internal class ODCircle : ODElement
    {
        public ODPoint Center { get; set; }
        public double Radius { get; set; }

        public ODCircle(ODPoint center, double radius)
        {
            Center = center;
            Radius = radius;
        }

        public override void Draw(DrawingContext context, ODLayer layer)
        {
            context.DrawEllipse(
                Brushes.Red, new Pen(Brushes.Red, 0.1),
                new Point(50, 50),
                0.4, 0.4
            );
        }
    }
}





** ODElement.cs **
Path: .\ODCore\ODGeometry\ODElement.cs

ï»¿using Avalonia;
using Avalonia.Media;
using OpenDraft.ODCore.ODData;
using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading.Tasks;

namespace OpenDraft.ODCore.ODGeometry
{
    public class ODElement
    {
        public Guid Id { get; set; }
        public ushort LayerId { get; set; } = 0; // Default layer ID

        public ODElement()
        {
            Id = Guid.NewGuid();
        }

        public virtual void Draw(DrawingContext context, ODLayer layer)
        {
            // Base draw method, to be overridden by derived classes
        }

    }
}





** ODLine.cs **
Path: .\ODCore\ODGeometry\ODLine.cs

ï»¿using Avalonia;
using Avalonia.Controls.Shapes;
using Avalonia.Media;
using OpenDraft.ODCore.ODData;
using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading.Tasks;

namespace OpenDraft.ODCore.ODGeometry
{
    internal class ODLine : ODElement
    {
        public ODPoint StartPoint { get; set; }
        public ODPoint EndPoint { get; set; }


        public ODLine(ODPoint startPoint, ODPoint endPoint)
        {
            StartPoint = startPoint;
            EndPoint = endPoint;
        }


        public override void Draw(DrawingContext context, ODLayer layer)
        {
            if (layer != null && !layer.IsVisible)
                return;

            if (layer == null)
                return;
            
            Pen pen = new Pen(new SolidColorBrush(Color.Parse(layer.Color)), layer.LineWeight);

            context.DrawLine(pen,
                    new Point(StartPoint.X, StartPoint.Y),
                    new Point(EndPoint.X, EndPoint.Y));
        }

    }
}





** ODPoint.cs **
Path: .\ODCore\ODGeometry\ODPoint.cs

ï»¿using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading.Tasks;

namespace OpenDraft.ODCore.ODGeometry
{
    public class ODPoint : ODElement
    {
        public float X { get; set; }
        public float Y { get; set; }
        public ODPoint(double x, double y)
        {
            X = (float)x;
            Y = (float)y;
        }

        public ODPoint(float x, float y)
        {
            X = x;
            Y = y;
        }
    }
}





** ODMath.cs **
Path: .\ODCore\ODMath\ODMath.cs

ï»¿using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading.Tasks;

namespace OpenDraft.ODCore.ODMath
{
    public class Vector2
        {
        public float X { get; set; }
        public float Y { get; set; }
        public Vector2(float x, float y)
        {
            X = x;
            Y = y;
        }
        public static Vector2 operator +(Vector2 a, Vector2 b)
        {
            return new Vector2(a.X + b.X, a.Y + b.Y);
        }

        public static Vector2 operator -(Vector2 a, Vector2 b)
        {
            return new Vector2(a.X - b.X, a.Y - b.Y);
        }

        public static Vector2 operator *(Vector2 a, float scalar)
        {
            return new Vector2(a.X * scalar, a.Y * scalar);
        }
        
        public static Vector2 operator /(Vector2 a, float scalar)
        {
            if (scalar == 0)
                throw new DivideByZeroException("Cannot divide by zero.");
            return new Vector2(a.X / scalar, a.Y / scalar);
        }
        
        public float Magnitude()
        {
            return (float)Math.Sqrt(X * X + Y * Y);
        }
        
        public Vector2 Normalize()
        {
            float magnitude = Magnitude();
            if (magnitude == 0)
                throw new InvalidOperationException("Cannot normalize a zero vector.");
            return this / magnitude;
        }
        
        public override string ToString()
        {
            return $"({X}, {Y})";
        }
    }
}





** MainWindowViewModel.cs **
Path: .\ViewModels\MainWindowViewModel.cs

ï»¿using OpenDraft.ODCore.ODData;
using OpenDraft.ODCore.ODEditor;
using OpenDraft.ODCore.ODGeometry;
using System.Collections.Generic;
using System.Collections.ObjectModel;

namespace OpenDraft.ViewModels
{
    public class MainWindowViewModel : ViewModelBase
    {
        public ODDataManager DataManager { get; }
        public ODEditor EditorRoot { get; private set; }

        public ObservableCollection<ODElement> GeometryElements => DataManager.Elements;
        public ODLayerManager LayerManager => DataManager.LayerManager;
        public ODEditor Editor => EditorRoot;

        public MainWindowViewModel()
        {
            // Initialize the DataManager and Editor
            DataManager = new ODDataManager();
            EditorRoot = new ODEditor(DataManager);

            // Set up layers (this can stay as-is)
            DataManager.LayerManager.AddLayer("New Layer");
            DataManager.LayerManager.SetActiveLayer("New Layer");

            ODLayer? lay = DataManager.LayerManager.GetLayerByName("New Layer");
            if (lay != null)
            {
                lay.Color = "#00FF00";
                lay.LineWeight = 2.0f;
            }


            // This would create the same square using the LINE command
            // Note: This is still interactive and will wait for user input
            Editor.ExecuteCommand("LINE"); // Then user clicks two points
        }

        
    }
}




** ViewModelBase.cs **
Path: .\ViewModels\ViewModelBase.cs

ï»¿using CommunityToolkit.Mvvm.ComponentModel;

namespace OpenDraft.ViewModels
{
    public class ViewModelBase : ObservableObject
    {
    }
}





** MainWindow.axaml **
Path: .\Views\MainWindow.axaml

<Window xmlns="https://github.com/avaloniaui"
        xmlns:x="http://schemas.microsoft.com/winfx/2006/xaml"
        xmlns:vm="using:OpenDraft.ViewModels"
        xmlns:local="using:OpenDraft"
        xmlns:d="http://schemas.microsoft.com/expression/blend/2008"
        xmlns:mc="http://schemas.openxmlformats.org/markup-compatibility/2006"
        mc:Ignorable="d" d:DesignWidth="800" d:DesignHeight="450"
        x:Class="OpenDraft.Views.MainWindow"
        x:DataType="vm:MainWindowViewModel"
        Icon="/Assets/avalonia-logo.ico"
        Title="OpenDraft"
        Width="500"
        Height="300">
  <!-- WindowState="Maximized"> -->

  <Design.DataContext>
    <vm:MainWindowViewModel/>
  </Design.DataContext>

  <Grid>
    <Grid.RowDefinitions>
      <RowDefinition Height="Auto"/>
      <RowDefinition Height="*" />
    </Grid.RowDefinitions>

    <!-- Use Grid.Row attached property -->
    <local:Viewport Grid.Row="1"
                    HorizontalAlignment="Stretch"
                    VerticalAlignment="Stretch"
                    Elements="{Binding GeometryElements}"
                    LayerManager="{Binding LayerManager}"
                    Editor="{Binding Editor}"/>

  </Grid>
</Window>





** MainWindow.axaml.cs **
Path: .\Views\MainWindow.axaml.cs

using Avalonia.Controls;
using OpenDraft.ODCore.ODData;
using OpenDraft.ODCore.ODGeometry;

namespace OpenDraft.Views
{
    public partial class MainWindow : Window
    {
        public ODDataManager Data { get; } = new ODDataManager();

        public MainWindow()
        {
            InitializeComponent();
        }
    }
}


