

** App.axaml **
Path: .\App.axaml

<Application xmlns="https://github.com/avaloniaui"
             xmlns:x="http://schemas.microsoft.com/winfx/2006/xaml"
             x:Class="OpenDraft.App"
             xmlns:local="using:OpenDraft"
             RequestedThemeVariant="Default">

  <Application.DataTemplates>
    <local:ViewLocator/>
  </Application.DataTemplates>

  <Application.Styles>
    <FluentTheme />
    <StyleInclude Source="avares://OpenDraft/Styles/ODStyle.axaml"/>
  </Application.Styles>
</Application>




** App.axaml.cs **
Path: .\App.axaml.cs

using System.Linq;
using Avalonia;
using Avalonia.Controls.ApplicationLifetimes;
using Avalonia.Data.Core;
using Avalonia.Data.Core.Plugins;
using Avalonia.Markup.Xaml;
using OpenDraft.ViewModels;
using OpenDraft.Views;

namespace OpenDraft
{
    public partial class App : Application
    {
        public override void Initialize()
        {
            AvaloniaXamlLoader.Load(this);
        }

        public override void OnFrameworkInitializationCompleted()
        {
            if (ApplicationLifetime is IClassicDesktopStyleApplicationLifetime desktop)
            {
                // Avoid duplicate validations from both Avalonia and the CommunityToolkit. 
                // More info: https://docs.avaloniaui.net/docs/guides/development-guides/data-validation#manage-validationplugins
                DisableAvaloniaDataAnnotationValidation();
                desktop.MainWindow = new MainWindow
                {
                    DataContext = new MainWindowViewModel(),
                };
            }

            base.OnFrameworkInitializationCompleted();
        }

        private void DisableAvaloniaDataAnnotationValidation()
        {
            // Get an array of plugins to remove
            var dataValidationPluginsToRemove =
                BindingPlugins.DataValidators.OfType<DataAnnotationsValidationPlugin>().ToArray();

            // remove each entry found
            foreach (var plugin in dataValidationPluginsToRemove)
            {
                BindingPlugins.DataValidators.Remove(plugin);
            }
        }
    }
}




** Program.cs **
Path: .\Program.cs

ï»¿using System;
using Avalonia;

namespace OpenDraft
{
    internal sealed class Program
    {
        // Initialization code. Don't use any Avalonia, third-party APIs or any
        // SynchronizationContext-reliant code before AppMain is called: things aren't initialized
        // yet and stuff might break.
        [STAThread]
        public static void Main(string[] args) => BuildAvaloniaApp()
            .StartWithClassicDesktopLifetime(args);

        // Avalonia configuration, don't remove; also used by visual designer.
        public static AppBuilder BuildAvaloniaApp()
            => AppBuilder.Configure<App>()
                .UsePlatformDetect()
                .WithInterFont()
                .LogToTrace();
    }
}





** ViewLocator.cs **
Path: .\ViewLocator.cs

using System;
using Avalonia.Controls;
using Avalonia.Controls.Templates;
using OpenDraft.ViewModels;

namespace OpenDraft
{
    public class ViewLocator : IDataTemplate
    {

        public Control? Build(object? param)
        {
            if (param is null)
                return null;

            var name = param.GetType().FullName!.Replace("ViewModel", "View", StringComparison.Ordinal);
            var type = Type.GetType(name);

            if (type != null)
            {
                return (Control)Activator.CreateInstance(type)!;
            }

            return new TextBlock { Text = "Not Found: " + name };
        }

        public bool Match(object? data)
        {
            return data is ViewModelBase;
        }
    }
}





** DynamicCanvas.axaml **
Path: .\ODCore\DynamicCanvas.axaml

<UserControl xmlns="https://github.com/avaloniaui"
             x:Class="OpenDraft.DynamicCanvas"
             xmlns:x="http://schemas.microsoft.com/winfx/2006/xaml">
</UserControl>





** DynamicCanvas.axaml.cs **
Path: .\ODCore\DynamicCanvas.axaml.cs

using Avalonia;
using Avalonia.Controls;
using Avalonia.Markup.Xaml;
using Avalonia.Media;
using System;

namespace OpenDraft;

public partial class DynamicCanvas : Control
{
    public Action<DrawingContext, Rect>? OnRender { get; set; }

    public override void Render(DrawingContext context)
    {
        base.Render(context);
        OnRender?.Invoke(context, Bounds);
    }
}





** StaticCanvas.axaml **
Path: .\ODCore\StaticCanvas.axaml

<UserControl xmlns="https://github.com/avaloniaui"
             x:Class="OpenDraft.StaticCanvas"
             xmlns:x="http://schemas.microsoft.com/winfx/2006/xaml">
</UserControl>




** StaticCanvas.axaml.cs **
Path: .\ODCore\StaticCanvas.axaml.cs

using Avalonia;
using Avalonia.Controls;
using Avalonia.Markup.Xaml;
using Avalonia.Media;
using System;

namespace OpenDraft;

public partial class StaticCanvas : Control
{
    public Action<DrawingContext, Rect>? OnRender { get; set; }

    public override void Render(DrawingContext context)
    {
        base.Render(context);
        OnRender?.Invoke(context, Bounds);
    }
}





** Viewport.axaml **
Path: .\ODCore\Viewport.axaml

<UserControl xmlns="https://github.com/avaloniaui"
             xmlns:x="http://schemas.microsoft.com/winfx/2006/xaml"
             xmlns:d="http://schemas.microsoft.com/expression/blend/2008"
             xmlns:mc="http://schemas.openxmlformats.org/markup-compatibility/2006"
             xmlns:local="clr-namespace:OpenDraft"
             mc:Ignorable="d"
             x:Class="OpenDraft.Viewport"
             d:DesignWidth="800" d:DesignHeight="450">

    <UserControl.Styles>
        <Style Selector="local|Viewport">
            <Setter Property="Cursor" Value="Arrow"/>
        </Style>

        <Style Selector="local|Viewport:pointerover">
            <Setter Property="Cursor" Value="None"/>
        </Style>
    </UserControl.Styles>



	<Grid Background="Transparent">
        <local:StaticCanvas x:Name="StaticCanvas"
							IsHitTestVisible="False"
                            HorizontalAlignment="Stretch"
                            VerticalAlignment="Stretch" />
        <local:DynamicCanvas x:Name="DynamicCanvas"
							 IsHitTestVisible="False"
                             HorizontalAlignment="Stretch"
                             VerticalAlignment="Stretch" />
    </Grid>


</UserControl>





** Viewport.axaml.cs **
Path: .\ODCore\Viewport.axaml.cs

using Avalonia;
using Avalonia.Controls;
using Avalonia.Input;
using Avalonia.Media;
using Avalonia.Threading;
using OpenDraft.ODCore.ODData;
using OpenDraft.ODCore.ODEditor;
using OpenDraft.ODCore.ODEditor.ODDynamics;
using OpenDraft.ODCore.ODGeometry;
using System;
using System.Collections.ObjectModel;
using System.Diagnostics;

namespace OpenDraft
{
    public partial class Viewport : UserControl
    {
        public static readonly StyledProperty<ObservableCollection<ODElement>> ElementsProperty =
            AvaloniaProperty.Register<Viewport, ObservableCollection<ODElement>>(nameof(Elements));

        public static readonly StyledProperty<ODLayerManager> LayerManagerProperty =
            AvaloniaProperty.Register<Viewport, ODLayerManager>(nameof(LayerManager));

        public static readonly StyledProperty<ODEditor> EditorProperty =
            AvaloniaProperty.Register<Viewport, ODEditor>(nameof(Editor));

        public static readonly StyledProperty<IODEditorInputService> InputServiceProperty =
            AvaloniaProperty.Register<Viewport, IODEditorInputService>(nameof(InputService));

        public static readonly StyledProperty<ObservableCollection<ODDynamicElement>> DynamicElementsProperty =
            AvaloniaProperty.Register<Viewport, ObservableCollection<ODDynamicElement>>(nameof(DynamicElements));

        public ObservableCollection<ODElement> Elements
        {
            get => GetValue(ElementsProperty);
            set => SetValue(ElementsProperty, value);
        }

        public ODLayerManager LayerManager
        {
            get => GetValue(LayerManagerProperty);
            set => SetValue(LayerManagerProperty, value);
        }

        public ODEditor Editor
        {
            get => GetValue(EditorProperty);
            set => SetValue(EditorProperty, value);
        }

        public IODEditorInputService InputService
        {
            get => GetValue(InputServiceProperty);
            set => SetValue(InputServiceProperty, value);
        }

        public ObservableCollection<ODDynamicElement> DynamicElements
        {
            get => GetValue(DynamicElementsProperty);
            set => SetValue(DynamicElementsProperty, value);
        }

        private readonly ViewportCamera Camera = new();
        private bool isPanning = false;
        private Point _lastPointerDragPosition;
        private Point _mousePosition;
        private Size _lastSize;
        private bool _isInitialized = false;
        private bool _isMouseInside = false;

        public Viewport()
        {
            InitializeComponent();
            Background = Brushes.Transparent;

            Elements ??= new ObservableCollection<ODElement>();
            DynamicElements ??= new ObservableCollection<ODDynamicElement>();

            SubscribeToCollection(Elements, OnElementsChanged);
            SubscribeToCollection(DynamicElements, OnDynamicElementsChanged);

            PointerPressed += OnPointerPressed;
            PointerReleased += OnPointerReleased;
            PointerMoved += OnPointerMoved;
            PointerWheelChanged += OnPointerWheelChanged;
            PointerEntered += OnPointerEntered;
            PointerExited += OnPointerExited;

            SetupStaticCanvas();
            SetupDynamicCanvas();
        }

        private void SubscribeToCollection<T>(ObservableCollection<T> collection, System.Collections.Specialized.NotifyCollectionChangedEventHandler handler)
        {
            if (collection == null) return;
            collection.CollectionChanged -= handler;
            collection.CollectionChanged += handler;
        }

        private void OnElementsChanged(object? sender, System.Collections.Specialized.NotifyCollectionChangedEventArgs e)
        {
            StaticCanvas?.InvalidateVisual();
        }

        private void OnDynamicElementsChanged(object? sender, System.Collections.Specialized.NotifyCollectionChangedEventArgs e)
        {
            DynamicCanvas?.InvalidateVisual();
        }

        private void SetupStaticCanvas()
        {
            StaticCanvas.OnRender = (context, bounds) =>
            {
                if (Elements == null) return;
                var matrix = Camera.GetMatrix(bounds.Height);

                using (context.PushTransform(matrix))
                {
                    foreach (var element in Elements)
                    {
                        var layer = LayerManager?.GetLayerByID(element.LayerId);
                        if (layer != null)
                            element.Draw(context, layer);
                    }
                }
            };
            StaticCanvas.InvalidateVisual();
        }

        private void SetupDynamicCanvas()
        {
            DynamicCanvas.OnRender = (context, bounds) =>
            {
                if (DynamicElements == null) return;

                ODPoint vpWorldSize = new ODPoint(bounds.Width / Camera.Scale, bounds.Height / Camera.Scale);
                ODPoint worldMousePoint = new ODPoint(GetWorldMousePosition().X, GetWorldMousePosition().Y);

                var matrix = Camera.GetMatrix(bounds.Height);
                using (context.PushTransform(matrix))
                {
                    if (Editor?.DynamicElements != null)
                        foreach (ODDynamicElement element in Editor.DynamicElements)
                        {
                            ODLayer? layer = LayerManager?.GetLayerByID(element.LayerId);
                            if (layer != null) element.Draw(context, layer, Camera.Scale, vpWorldSize, worldMousePoint);
                        }
                }
            };

            var timer = new DispatcherTimer { Interval = TimeSpan.FromMilliseconds(16) };
            timer.Tick += (_, _) => DynamicCanvas?.InvalidateVisual();
            timer.Start();
        }

        protected override Size ArrangeOverride(Size finalSize)
        {
            if (!_isInitialized)
            {
                _isInitialized = true;
                Camera.Position = new Point(-finalSize.Width / 2 / Camera.Scale, -finalSize.Height / 2 / Camera.Scale);
            }
            else
            {
                Camera.Position -= new Vector(
                    (finalSize.Width - _lastSize.Width) / 2 / Camera.Scale,
                    (finalSize.Height - _lastSize.Height) / 2 / Camera.Scale);
            }

            _lastSize = finalSize;
            StaticCanvas?.InvalidateVisual();
            return base.ArrangeOverride(finalSize);
        }

        protected override void OnPropertyChanged(AvaloniaPropertyChangedEventArgs change)
        {
            base.OnPropertyChanged(change);
            if (!_isInitialized) return;

            if (change.Property == ElementsProperty)
                SubscribeToCollection(Elements, OnElementsChanged);
            else if (change.Property == DynamicElementsProperty)
                SubscribeToCollection(DynamicElements, OnDynamicElementsChanged);

            StaticCanvas?.InvalidateVisual();
            DynamicCanvas?.InvalidateVisual();
        }

        private void OnPointerPressed(object? sender, PointerPressedEventArgs e)
        {
            if (e.GetCurrentPoint(this).Properties.IsMiddleButtonPressed)
            {
                _lastPointerDragPosition = e.GetPosition(this);
                isPanning = true;
            }
        }

        private void OnPointerReleased(object? sender, PointerReleasedEventArgs e)
        {
            if (e.InitialPressMouseButton == MouseButton.Left)
            {
                var odPoint = new ODPoint(GetWorldMousePosition().X, GetWorldMousePosition().Y);
                InputService?.RaisePointProvided(odPoint);
                e.Handled = true;
            }

            if (e.InitialPressMouseButton == MouseButton.Middle)
                isPanning = false;
        }

        private void OnPointerMoved(object? sender, PointerEventArgs e)
        {
            _mousePosition = e.GetPosition(this);
            DynamicCanvas?.InvalidateVisual();

            if (!isPanning) return;

            var current = e.GetPosition(this);
            Camera.MoveBy(new Vector(-(current.X - _lastPointerDragPosition.X) / Camera.Scale,
                                     (current.Y - _lastPointerDragPosition.Y) / Camera.Scale));
            _lastPointerDragPosition = current;

            StaticCanvas?.InvalidateVisual();
        }

        private void OnPointerEntered(object? sender, PointerEventArgs e)
        {
            _isMouseInside = true;
            Editor.ShowCrosshair();
        }

        private void OnPointerExited(object? sender, PointerEventArgs e)
        {
            _isMouseInside = false;
            Editor.HideCrosshair();
        }

        private void OnPointerWheelChanged(object? sender, PointerWheelEventArgs e)
        {
            var mousePos = e.GetPosition(this);
            float zoomFactor = 1.1f;
            float oldScale = Camera.Scale;
            float newScale = oldScale * (float)Math.Pow(zoomFactor, e.Delta.Y > 0 ? 1 : -1);

            Point ScreenToWorld(Point screen, float scale) =>
                new(screen.X / scale - Camera.Position.X, (Bounds.Height - screen.Y) / scale - Camera.Position.Y);

            var oldWorld = ScreenToWorld(mousePos, oldScale);
            var newWorld = ScreenToWorld(mousePos, newScale);

            Camera.Position += oldWorld - newWorld; // <--- fix here
            Camera.Scale = newScale;

            StaticCanvas?.InvalidateVisual();
            DynamicCanvas?.InvalidateVisual();
        }


        public Point GetScreenMousePosition() => _mousePosition;

        public Point GetWorldMousePosition() =>
            new Point(_mousePosition.X / Camera.Scale + Camera.Position.X,
                      (Bounds.Height - _mousePosition.Y) / Camera.Scale + Camera.Position.Y);
    }
}





** ODDataManager.cs **
Path: .\ODCore\ODData\ODDataManager.cs

ï»¿using CommunityToolkit.Mvvm.ComponentModel;
using OpenDraft.ODCore.ODGeometry;
using System;
using System.Collections.Generic;
using System.Collections.ObjectModel;
using System.Linq;
using System.Text;
using System.Threading.Tasks;

namespace OpenDraft.ODCore.ODData
{
    public class ODDataManager
    {
        public ObservableCollection<ODGeometry.ODElement> Elements { get; } = new();
        public ODLayerManager LayerManager { get; } = new ODLayerManager();

        public ODDataManager()
        {

        }


        public void AddElement(ODElement element)
        {
            if (element == null)
                throw new ArgumentNullException(nameof(element));

            element.LayerId = LayerManager.GetActiveLayer();
            Elements.Add(element);
        }
    }
}





** ODLayer.cs **
Path: .\ODCore\ODData\ODLayer.cs

ï»¿using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading.Tasks;

namespace OpenDraft.ODCore.ODData
{
    public class ODLayer
    {
        private ushort _id;
        public String Name { get; set; } = Guid.NewGuid().ToString();
        public String Color { get; set; } = "#FFFFFF";
        public String LineType { get; set; } = "Continuous";
        public float LineWeight { get; set; } = 0.6f;
        public bool IsVisible { get; set; } = true;
        public bool IsLocked { get; set; } = false;
        public bool IsSystemLayer { get; set; } = false;

        public ODLayer(ushort id, String name)
        {
            _id = id;
            Name = name;
        }

        public ushort getID()
        {
            return _id;
        }
    }
}





** ODLayerManager.cs **
Path: .\ODCore\ODData\ODLayerManager.cs

ï»¿using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading.Tasks;

namespace OpenDraft.ODCore.ODData
{
    public class ODLayerManager
    {
        private List<ODLayer> Layers { get; set; } = new List<ODLayer>();
        private ushort ActiveLayer { get; set; }

        public ODLayerManager()
        {
            // Add a default layer
            AddLayer("Default");

            AddLayer("Crosshair X");
            GetLayerByName("Crosshair X")!.IsSystemLayer = true;
            AddLayer("Crosshair Y");
            GetLayerByName("Crosshair Y")!.IsSystemLayer = true;
            AddLayer("Crosshair Square");
            GetLayerByName("Crosshair Square")!.IsSystemLayer = true;


        }


        private ushort GetNextAvailableID()
        {
            HashSet<ushort> usedIDs = new HashSet<ushort>(Layers.Select(layer => layer.getID()));
            for (ushort id = 0; id < ushort.MaxValue; id++)
            {
                if (!usedIDs.Contains(id))
                    return id;
            }
            throw new InvalidOperationException("No available layer IDs.");
        }


        public ushort GetActiveLayer()
        {
            return ActiveLayer;
        }


        public ushort AddLayer(string name)
        {
            ushort newID = GetNextAvailableID();

            ODLayer newLayer = new ODLayer(newID, name);
            Layers.Add(newLayer);
            return newID;
        }

        public ODLayer? GetLayerByName(string name)
        {
            return Layers.FirstOrDefault(layer => layer.Name == name);
        }

        public ODLayer? GetLayerByID(ushort id)
        {
            return Layers.FirstOrDefault(layer => layer.getID() == id);
        }

        public void SetActiveLayer(string name)
        {
            ODLayer? layer = GetLayerByName(name);
            if (layer != null)
            {
                ActiveLayer = layer.getID();
            }
            else
            {
                throw new ArgumentException($"Layer with name '{name}' does not exist.");
            }
        }

        public void RemoveLayer(string name)
        {
            ODLayer? layerToRemove = GetLayerByName(name);

            if (layerToRemove != null)
            {
                if (layerToRemove.IsSystemLayer)
                {
                    throw new InvalidOperationException("Cannot remove a system layer.");
                }

                if (ActiveLayer == layerToRemove.getID())
                {
                    SetActiveLayer("Default");
                }
                
                Layers.Remove(layerToRemove);
            }
        }
    }
}





** IODEditorInputService.cs **
Path: .\ODCore\ODEditor\IODEditorInputService.cs

ï»¿// IEditorInputService.cs
using Avalonia.Input;
using OpenDraft.ODCore.ODGeometry;
using System;

namespace OpenDraft.ODCore.ODEditor
{
    public interface IODEditorInputService
    {
        // Events for different input types
        event Action<Key> KeyPressed;
        event Action<ODPoint> PointProvided;
        event Action<string> TextInput;
        event Action<double> NumberInput;
        event Action CancelRequested;

        // ADD THESE METHODS to the interface
        void RaiseKeyPressed(Key key);
        void RaisePointProvided(ODPoint point);
        void RaiseTextInput(string text);
        void RaiseNumberInput(double number);
        void RaiseCancelRequested();

        // Methods to request specific input modes
        void RequestPointInput();
        void RequestTextInput();
        void CancelInputRequest();
    }
}




** ODCommandAttribute.cs **
Path: .\ODCore\ODEditor\ODCommandAttribute.cs

ï»¿// ODCommandAttribute.cs
using System;

namespace OpenDraft.ODCore.ODEditor.ODCommands
{
    [AttributeUsage(AttributeTargets.Class, Inherited = false, AllowMultiple = false)]
    public class ODCommandAttribute : Attribute
    {
        public string Name { get; }
        public string Description { get; }
        public string[] Aliases { get; }

        public ODCommandAttribute(string name, string description = "", params string[] aliases)
        {
            Name = name;
            Description = description;
            Aliases = aliases;
        }
    }
}




** ODEditor.cs **
Path: .\ODCore\ODEditor\ODEditor.cs

ï»¿using Avalonia.Input;
using Avalonia.Threading;
using OpenDraft.ODCore.ODData;
using OpenDraft.ODCore.ODEditor.ODCommands;
using OpenDraft.ODCore.ODEditor.ODDynamics;
using OpenDraft.ODCore.ODGeometry;
using System;
using System.Collections.Generic;
using System.Collections.ObjectModel;
using System.Diagnostics;
using System.Threading;
using System.Threading.Tasks;

namespace OpenDraft.ODCore.ODEditor
{
    public class ODEditor : IDisposable
    {
        private readonly ODDataManager _dataManager;
        private readonly ODCommandRegistry _commandRegistry;
        private readonly IODEditorInputService _inputService;

        public ObservableCollection<ODDynamicElement> DynamicElements { get; } = new();

        private ODEditorContext? _currentContext;
        private IODEditorCommand? _currentCommand;

        public event EventHandler<MessageEventArgs>? ShowMessageRequested;
        public event EventHandler<MessageEventArgs>? StatusMessageChanged;

        ODCrosshairElement ch = new ODCrosshairElement();


        public ODEditor(ODDataManager dataManager, IODEditorInputService inputService)
        {
            _dataManager = dataManager;
            _inputService = inputService;
            _commandRegistry = new ODCommandRegistry();
            _commandRegistry.RegisterAssembly(typeof(ODEditor).Assembly);

            // Subscribe to input events
            _inputService.KeyPressed += OnKeyPressed;
            _inputService.CancelRequested += OnCancelRequested;

            DynamicElements.Add(ch);
        }

        /* DYNAMIC ELEMENTS MANAGEMENT */

        public void restoreDefaultDynamicElements()
        {
            DynamicElements.Clear();
            // Future: Add default dynamic elements if any <<<< TODO IMPLEMENT <<<<
            DynamicElements.Add(ch);
        }

        public void ClearDynamicElements()
        {
            DynamicElements.Clear();
            DynamicElements.Add(ch);
        }

        // ADD THIS: Method to add dynamic elements
        public void AddDynamicElement(ODDynamicElement element)
        {
            Debug.WriteLine("AddDynamicElement: " + element.GetType().Name);
            DynamicElements.Add(element);
        }

        // ADD THIS: Method to remove specific dynamic element
        public void RemoveDynamicElement(ODDynamicElement element)
        {
            DynamicElements.Remove(element);
        }



        /* COMMAND EXECUTION AND INPUT HANDLING  */

        private void OnKeyPressed(Key key)
        {
            // Handle specific keys we care about
            switch (key)
            {
                case Key.Escape:
                    CancelCurrentCommand();
                    break;
                    // Future: handle Enter, Space, etc.
            }
        }

        private void OnCancelRequested()
        {
            CancelCurrentCommand();
        }

        
        public void CancelCurrentCommand()
        {
            restoreDefaultDynamicElements();

            _currentContext?.Cancel();
            _currentContext = null;
            _currentCommand = null;
            SetStatus("Command cancelled");
        }

        public void ExecuteCommand(string commandName)
        {
            Debug.WriteLine($"ExecuteCommand: {commandName}");

            CancelCurrentCommand();

            var command = _commandRegistry.CreateCommand(commandName);
            if (command == null)
            {
                SetStatus($"Unknown command: {commandName}");
                return;
            }

            _currentCommand = command;
            _currentContext = new ODEditorContext(this, _dataManager, _inputService);

            async Task RunCommandAsync()
            {
                try
                {
                    await command.ExecuteAsync(_currentContext);
                }
                catch (Exception ex)
                {
                    SetStatus($"Error in {commandName}: {ex.Message}");
                    Debug.WriteLine($"Command error: {ex.Message}");
                }
                finally
                {
                    if (_currentCommand == command)
                    {
                        CancelCurrentCommand();
                    }
                }
            }

            _ = RunCommandAsync();
        }

        
        public void SetStatus(string message)
        {
            Debug.WriteLine("SetStatus: " + message);
            Dispatcher.UIThread.Post(() =>
            {
                StatusMessageChanged?.Invoke(this, new MessageEventArgs(message));
            });
        }

        public void ShowMessage(string message)
        {
            Debug.WriteLine("ShowMessage: " + message);
            Dispatcher.UIThread.Post(() =>
            {
                ShowMessageRequested?.Invoke(this, new MessageEventArgs(message));
            });
        }

        public void Dispose()
        {
            _inputService.KeyPressed -= OnKeyPressed;
            _inputService.CancelRequested -= OnCancelRequested;
            CancelCurrentCommand();
        }

        public void HideCrosshair()
        {
            ch.IsVisible = false;
        }

        public void ShowCrosshair()
        {
            ch.IsVisible = true;
        }
    }

    
    public class MessageEventArgs : EventArgs
    {
        public string Message { get; }
        public MessageEventArgs(string message) => Message = message;
    }

    public class BoolEventArgs : EventArgs
    {
        public bool Value { get; }
        public BoolEventArgs(bool value) => Value = value;
    }
}




** ODEditorContext.cs **
Path: .\ODCore\ODEditor\ODEditorContext.cs

ï»¿using OpenDraft.ODCore.ODData;
using OpenDraft.ODCore.ODEditor.ODCommands;
using OpenDraft.ODCore.ODEditor.ODDynamics;
using OpenDraft.ODCore.ODGeometry;
using OpenDraft.ODCore.ODMath;
using System;
using System.Numerics;
using System.Threading;
using System.Threading.Tasks;

namespace OpenDraft.ODCore.ODEditor
{
    public class ODEditorContext : IODEditorGateway
    {
        private readonly ODEditor _editor;
        private readonly ODDataManager _dataManager;
        private readonly IODEditorInputService _inputService;
        private readonly CancellationTokenSource _cancellationTokenSource;

        private TaskCompletionSource<ODPoint>? _pointWaiter;
        private TaskCompletionSource<double>? _numberWaiter;
        private TaskCompletionSource<string>? _textWaiter;
        private TaskCompletionSource<string>? _choiceWaiter;

        public ODDataManager DataManager => _dataManager;
        public CancellationToken CancellationToken => _cancellationTokenSource.Token;

        public ODEditorContext(ODEditor editor, ODDataManager dataManager, IODEditorInputService inputService)
        {
            _editor = editor;
            _dataManager = dataManager;
            _inputService = inputService;
            _cancellationTokenSource = new CancellationTokenSource();

            // Subscribe to input service events
            _inputService.PointProvided += OnPointProvided;
            _inputService.NumberInput += OnNumberProvided;
            _inputService.TextInput += OnTextProvided;
        }

        public void AddDynamicElement(ODDynamicElement element)
        {
            _editor.AddDynamicElement(element);
        }

        public void RemoveDynamicElement(ODDynamicElement element)
        {
            _editor.RemoveDynamicElement(element);
        }

        public void ClearDynamicElements()
        {
            _editor.ClearDynamicElements();
        }

        private void OnPointProvided(ODPoint point)
        {
            ProvidePoint(point);
        }

        private void OnNumberProvided(double number)
        {
            ProvideNumber(number);
        }

        private void OnTextProvided(string text)
        {
            ProvideText(text);
        }

        public Task<ODPoint> GetPointAsync(string prompt)
        {
            _editor.SetStatus(prompt); // FIXED: Now calls editor method
            ClearAllWaiters();
            _pointWaiter = new TaskCompletionSource<ODPoint>();
            return _pointWaiter.Task;
        }

        public Task<double> GetNumberAsync(string prompt)
        {
            _editor.SetStatus(prompt); // FIXED
            ClearAllWaiters();
            _numberWaiter = new TaskCompletionSource<double>();
            return _numberWaiter.Task;
        }

        public Task<string> GetTextAsync(string prompt)
        {
            _editor.SetStatus(prompt); // FIXED
            ClearAllWaiters();
            _textWaiter = new TaskCompletionSource<string>();
            return _textWaiter.Task;
        }

        public async Task<(ODPoint start, ODPoint end)> GetLineAsync(string promptStart, string promptEnd)
        {
            var start = await GetPointAsync(promptStart);
            ODRubberBandLine rubberBandLine = new ODRubberBandLine(start);
            rubberBandLine.LayerId = _dataManager.LayerManager.GetActiveLayer();
            _editor.AddDynamicElement(rubberBandLine);
            var end = await GetPointAsync(promptEnd);

            return (start, end);
        }

        public Task<string> GetChoiceAsync(string prompt, params string[] options)
        {
            _editor.SetStatus(prompt); // FIXED
            ClearAllWaiters();
            _choiceWaiter = new TaskCompletionSource<string>();
            return _choiceWaiter.Task;
        }

        public void ProvidePoint(ODPoint point)
        {
            if (point == null)
                throw new ArgumentNullException(nameof(point));

            if (_pointWaiter != null && !_pointWaiter.Task.IsCompleted)
            {
                _pointWaiter.TrySetResult(point);
            }
        }

        public void ProvideNumber(double number)
        {
            if (_numberWaiter != null && !_numberWaiter.Task.IsCompleted)
            {
                _numberWaiter.TrySetResult(number);
            }
        }

        public void ProvideText(string text)
        {
            if (_textWaiter != null && !_textWaiter.Task.IsCompleted)
            {
                _textWaiter.TrySetResult(text);
            }
        }

        public void ProvideChoice(string choice)
        {
            if (_choiceWaiter != null && !_choiceWaiter.Task.IsCompleted)
            {
                _choiceWaiter.TrySetResult(choice);
            }
        }

        public void Cancel()
        {
            _cancellationTokenSource.Cancel();
            _inputService.PointProvided -= OnPointProvided;
            _inputService.NumberInput -= OnNumberProvided;
            _inputService.TextInput -= OnTextProvided;
            ClearAllWaiters();
        }

        private void ClearAllWaiters()
        {
            _pointWaiter = null;
            _numberWaiter = null;
            _textWaiter = null;
            _choiceWaiter = null;
        }

        public void SetStatus(string message)
        {
            _editor.SetStatus(message);
        }

        public void ShowMessage(string message)
        {
            _editor.ShowMessage(message);
        }
    }
}




** ODEditorInputService.cs **
Path: .\ODCore\ODEditor\ODEditorInputService.cs

ï»¿// EditorInputService.cs
using Avalonia.Input;
using OpenDraft.ODCore.ODGeometry;
using System;

namespace OpenDraft.ODCore.ODEditor
{
    public class ODEditorInputService : IODEditorInputService
    {
        public event Action<Key>? KeyPressed;
        public event Action<ODPoint>? PointProvided;
        public event Action<string>? TextInput;
        public event Action<double>? NumberInput;
        public event Action? CancelRequested;

        public void RaiseKeyPressed(Key key)
        {
            KeyPressed?.Invoke(key);
        }

        public void RaisePointProvided(ODPoint point)
        {
            PointProvided?.Invoke(point);
        }

        public void RaiseTextInput(string text)
        {
            TextInput?.Invoke(text);
        }

        public void RaiseNumberInput(double number)
        {
            NumberInput?.Invoke(number);
        }

        public void RaiseCancelRequested()
        {
            CancelRequested?.Invoke();
        }

        // These can be expanded later for more sophisticated input handling
        public void RequestPointInput() { /* Future: change cursor, show hints */ }
        public void RequestTextInput() { /* Future: focus text box */ }
        public void CancelInputRequest() { /* Future: reset cursor */ }
    }
}




** ODViewportCamera.cs **
Path: .\ODCore\ODEditor\ODViewportCamera.cs

ï»¿using Avalonia;

public class ViewportCamera
{
    public Point Position { get; set; } = new Point(0, 0);
    public float Scale { get; set; } = 1.0f;

    public ViewportCamera(Point? position = null, float scale = 1.0f)
    {
        Position = position ?? new Point(0, 0);
        Scale = scale;
    }

    public void MoveBy(Vector delta) => Position += new Point(delta.X, delta.Y);

    public Matrix GetMatrix(double viewportHeight) =>
        new Matrix(Scale, 0, 0, -Scale, -Position.X * Scale, Position.Y * Scale + viewportHeight);
}




** IODEditorCommand.cs **
Path: .\ODCore\ODEditor\ODCommands\IODEditorCommand.cs

ï»¿using System.Threading.Tasks;

namespace OpenDraft.ODCore.ODEditor.ODCommands
{
    public interface IODEditorCommand
    {
        string Name { get; }
        string Description { get; }
        Task ExecuteAsync(IODEditorGateway editor);
    }
}




** IODEditorGateway.cs **
Path: .\ODCore\ODEditor\ODCommands\IODEditorGateway.cs

ï»¿using OpenDraft.ODCore.ODData;
using OpenDraft.ODCore.ODEditor.ODDynamics;
using OpenDraft.ODCore.ODGeometry;
using System.Threading;
using System.Threading.Tasks;

namespace OpenDraft.ODCore.ODEditor.ODCommands
{
    public interface IODEditorGateway
    {
        ODDataManager DataManager { get; }

        Task<ODPoint> GetPointAsync(string prompt);
        Task<double> GetNumberAsync(string prompt);
        Task<string> GetTextAsync(string prompt);
        Task<string> GetChoiceAsync(string prompt, params string[] options);
        Task<(ODPoint start, ODPoint end)> GetLineAsync(string promptStart, string promptEnd);

        void SetStatus(string message);
        void ShowMessage(string message);

        void AddDynamicElement(ODDynamicElement element);
        void RemoveDynamicElement(ODDynamicElement element);
        void ClearDynamicElements();

        CancellationToken CancellationToken { get; }
    }
}




** ODBaseEditorCommand.cs **
Path: .\ODCore\ODEditor\ODCommands\ODBaseEditorCommand.cs

ï»¿// ODBaseEditorCommand.cs
using OpenDraft.ODCore.ODGeometry;
using System;
using System.Reflection;
using System.Threading.Tasks;

namespace OpenDraft.ODCore.ODEditor.ODCommands
{
    public abstract class ODBaseEditorCommand : IODEditorCommand
    {
        private readonly Lazy<ODCommandAttribute> _attribute;

        public string Name => _attribute.Value.Name;
        public string Description => _attribute.Value.Description;

        protected ODBaseEditorCommand()
        {
            _attribute = new Lazy<ODCommandAttribute>(() =>
            {
                var attribute = GetType().GetCustomAttribute<ODCommandAttribute>();
                if (attribute == null)
                {
                    throw new InvalidOperationException(
                        $"Command {GetType().Name} must be decorated with [ODCommand] attribute");
                }
                return attribute;
            });
        }

        public abstract Task ExecuteAsync(IODEditorGateway editor);

        // Helper method for common validation
        protected void ValidatePoint(ODPoint point, string paramName)
        {
            if (point == null)
                throw new ArgumentNullException(paramName);

            if (double.IsNaN(point.X) || double.IsNaN(point.Y) ||
                double.IsInfinity(point.X) || double.IsInfinity(point.Y))
                throw new ArgumentException($"Invalid point coordinates: ({point.X}, {point.Y})", paramName);
        }
    }
}




** ODCircleCommand.cs **
Path: .\ODCore\ODEditor\ODCommands\ODCircleCommand.cs

ï»¿// ODCircleCommand.cs
using OpenDraft.ODCore.ODEditor.ODCommands;
using OpenDraft.ODCore.ODGeometry;
using System.Threading.Tasks;

namespace OpenDraft.ODCore.ODEditor.ODCommands
{
    [ODCommand("CIRCLE", "Creates a circle", "C")]
    public class ODCircleCommand : ODBaseEditorCommand
    {
        public override async Task ExecuteAsync(IODEditorGateway editor)
        {
            var center = await editor.GetPointAsync("Specify center point:");
            var radius = await editor.GetNumberAsync("Specify radius:");

            var circle = new ODCircle(center, radius);
            editor.DataManager.AddElement(circle); // Use DataManager directly

            editor.SetStatus("Circle created successfully");
        }
    }
}




** ODCommandRegistry.cs **
Path: .\ODCore\ODEditor\ODCommands\ODCommandRegistry.cs

ï»¿// ODCommandRegistry.cs
using System;
using System.Collections.Generic;
using System.Linq;
using System.Reflection;

namespace OpenDraft.ODCore.ODEditor.ODCommands
{
    public class ODCommandRegistry
    {
        private readonly Dictionary<string, Type> _commands = new Dictionary<string, Type>(StringComparer.OrdinalIgnoreCase);

        public void RegisterAssembly(Assembly assembly)
        {
            var commandTypes = assembly.GetTypes()
                .Where(t => typeof(IODEditorCommand).IsAssignableFrom(t) && !t.IsAbstract)
                .Where(t => t.GetCustomAttribute<ODCommandAttribute>() != null);

            foreach (var type in commandTypes)
            {
                var attribute = type.GetCustomAttribute<ODCommandAttribute>();
                if (attribute != null)
                {
                    _commands[attribute.Name] = type;

                    foreach (var alias in attribute.Aliases)
                    {
                        _commands[alias] = type;
                    }
                }
            }
        }

        public void RegisterCommand<T>(string name, params string[] aliases) where T : IODEditorCommand
        {
            _commands[name] = typeof(T);
            foreach (var alias in aliases)
            {
                _commands[alias] = typeof(T);
            }
        }

        public IODEditorCommand? CreateCommand(string commandName)
        {
            if (_commands.TryGetValue(commandName, out var commandType))
            {
                return (IODEditorCommand)Activator.CreateInstance(commandType);
            }
            return null;
        }

        public IEnumerable<string> GetRegisteredCommandNames()
        {
            return _commands.Keys.Distinct();
        }

        public string GetCommandDescription(string commandName)
        {
            if (_commands.TryGetValue(commandName, out var type))
            {
                var attribute = type.GetCustomAttribute<ODCommandAttribute>();
                return attribute?.Description ?? string.Empty;
            }
            return string.Empty;
        }
    }
}




** ODLineCommand.cs **
Path: .\ODCore\ODEditor\ODCommands\ODLineCommand.cs

ï»¿// Example of using dynamic elements in a command
using OpenDraft.ODCore.ODEditor.ODCommands;
using OpenDraft.ODCore.ODEditor.ODDynamics;
using OpenDraft.ODCore.ODGeometry;
using System.Diagnostics;
using System.Threading.Tasks;

[ODCommand("LINE", "Creates a line", "L")]
public class ODLineCommand : ODBaseEditorCommand
{
    public override async Task ExecuteAsync(IODEditorGateway editor)
    {
        var vec = await editor.GetLineAsync("Specify start point:", "Specify end point:");

        var line = new ODLine(vec.start, vec.end);
        editor.DataManager.AddElement(line);
        editor.SetStatus("Line created successfully");
    }
}




** ODCrosshair.cs **
Path: .\ODCore\ODEditor\ODDynamics\ODCrosshair.cs

ï»¿using Avalonia;
using Avalonia.Media;
using OpenDraft;
using OpenDraft.ODCore.ODData;
using OpenDraft.ODCore.ODGeometry;
using System;

namespace OpenDraft.ODCore.ODEditor.ODDynamics
{
    public class ODCrosshairElement : ODDynamicElement
    {
        // Visibility
        public bool IsVisible { get; set; } = true;

        // Style properties
        private int _size = 10;
        public int Size
        {
            get => _size;
            set => _size = value;
        }

        public ODCrosshairElement()
        {

        }

        public override void Draw(DrawingContext context, ODLayer layer, float scale, ODPoint vpWorldSize, ODPoint worldMousePosition)
        {
            if (!IsVisible)
                return;

            // Get layer
            Pen pen = new Pen(new SolidColorBrush(Avalonia.Media.Color.Parse(layer.Color)), layer.LineWeight / scale);
            ODPoint Center = worldMousePosition;
            float cSize = Size / scale; // Centre square size

            // Get styles from registry
            Color xColour = Avalonia.Media.Color.Parse(ODSystem.GetRegistrValueAsString("style/crosshair_x_colour") ?? "Red");
            Color yColour = Avalonia.Media.Color.Parse(ODSystem.GetRegistrValueAsString("style/crosshair_y_colour") ?? "Lime");
            Color sqColour = Avalonia.Media.Color.Parse(ODSystem.GetRegistrValueAsString("style/crosshair_sq_colour") ?? "White");
            float xThickness = ODSystem.GetRegistrValueAsDecimal("style/crosshair_line_weight") ?? 1;

            Pen xPen = new Pen(new SolidColorBrush(xColour), xThickness / scale);
            Pen yPen = new Pen(new SolidColorBrush(yColour), xThickness / scale);
            Pen sqPen = new Pen(new SolidColorBrush(sqColour), xThickness / scale);


            // Centre square
            context.DrawRectangle(null, pen,
                new Rect(
                    new Point(Center.X - cSize / 2, Center.Y - cSize / 2),
                    new Size(cSize, cSize)
                ));

            var top = new Point(Center.X, Center.Y + vpWorldSize.Y);
            var bottom = new Point(Center.X, Center.Y - vpWorldSize.Y);
            var left = new Point(Center.X - vpWorldSize.X, Center.Y);
            var right = new Point(Center.X + vpWorldSize.X, Center.Y);

            context.DrawLine(yPen, top, new Point(Center.X, Center.Y + cSize / 2)); // Top
            context.DrawLine(xPen, left, new Point(Center.X - cSize / 2, Center.Y)); // Left
            context.DrawLine(yPen, new Point(Center.X, Center.Y - cSize / 2), bottom); // Bottom
            context.DrawLine(xPen, new Point(Center.X + cSize / 2, Center.Y), right); // Right
        }

    }
}





** ODDynamicElement.cs **
Path: .\ODCore\ODEditor\ODDynamics\ODDynamicElement.cs

ï»¿using Avalonia;
using Avalonia.Media;
using OpenDraft.ODCore.ODData;
using OpenDraft.ODCore.ODGeometry;
using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading.Tasks;

namespace OpenDraft.ODCore.ODEditor.ODDynamics
{
    public class ODDynamicElement
    {
        public Guid Id { get; set; }
        public string Color { get; set; } = "#FF0000";
        public float LineWeight { get; set; } = 2.0f;
        public ushort LayerId { get; set; } = 0; // Default layer ID

        public ODDynamicElement()
        {
            Id = Guid.NewGuid();
        }

        public virtual void Draw(DrawingContext context, ODLayer layer, float scale, ODPoint vpWorldSize, ODPoint mousePosition)
        {
            // Base draw method, to be overridden by derived classes
        }

    }
}





** ODRubberBandLine.cs **
Path: .\ODCore\ODEditor\ODDynamics\ODRubberBandLine.cs

ï»¿using Avalonia;
using Avalonia.Media;
using OpenDraft.ODCore.ODData;
using OpenDraft.ODCore.ODGeometry;
using System;
using System.Diagnostics;

namespace OpenDraft.ODCore.ODEditor.ODDynamics
{
    public class ODRubberBandLine : ODDynamicElement
    {
        public ODPoint Start { get; set; }
        public float Weight { get; set; } = 1.0f;

        public ODRubberBandLine(ODPoint start)
        {
            Start = start;
        }

        public override void Draw(DrawingContext context, ODLayer layer, float scale, ODPoint vpWorldSize, ODPoint mousePosition)
        {
            if (layer != null && !layer.IsVisible)
                return;

            Pen pen = new Pen(new SolidColorBrush(Avalonia.Media.Color.Parse(layer.Color)), layer.LineWeight);

            context.DrawLine(pen, new Point(Start.X, Start.Y), new Point(mousePosition.X, mousePosition.Y));
        }

    }
}





** ODSnapIndicatorElement.cs **
Path: .\ODCore\ODEditor\ODDynamics\ODSnapIndicatorElement.cs

ï»¿using Avalonia;
using Avalonia.Media;
using OpenDraft.ODCore.ODData;
using OpenDraft.ODCore.ODGeometry;
using System;

namespace OpenDraft.ODCore.ODEditor.ODDynamics
{
    public class SnapIndicatorElement : ODDynamicElement
    {
        public ODPoint Position { get; set; }
        public double Radius { get; set; } = 5.0;

        public SnapIndicatorElement(ODPoint position)
        {
            Position = position;
        }

        public override void Draw(DrawingContext context, ODLayer layer, float scale, ODPoint vpExtents, ODPoint worldMousePosition)
        {
            var brush = new SolidColorBrush(Colors.Yellow);
            var pen = new Pen(brush, 1.5);

            context.DrawEllipse(null, pen,
                new Point(Position.X, Position.Y),
                Radius, Radius);
        }
    }
}





** ODCircle.cs **
Path: .\ODCore\ODGeometry\ODCircle.cs

ï»¿using Avalonia;
using Avalonia.Media;
using OpenDraft.ODCore.ODData;
using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading.Tasks;

namespace OpenDraft.ODCore.ODGeometry
{
    internal class ODCircle : ODElement
    {
        public ODPoint Center { get; set; }
        public double Radius { get; set; }

        public ODCircle(ODPoint center, double radius)
        {
            Center = center;
            Radius = radius;
        }

        public override void Draw(DrawingContext context, ODLayer layer)
        {
            context.DrawEllipse(
                Brushes.Red, new Pen(Brushes.Red, 0.1),
                new Point(50, 50),
                0.4, 0.4
            );
        }
    }
}





** ODElement.cs **
Path: .\ODCore\ODGeometry\ODElement.cs

ï»¿using Avalonia;
using Avalonia.Media;
using OpenDraft.ODCore.ODData;
using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading.Tasks;

namespace OpenDraft.ODCore.ODGeometry
{
    public class ODElement
    {
        public Guid Id { get; set; }
        public ushort LayerId { get; set; } = 0; // Default layer ID

        public ODElement()
        {
            Id = Guid.NewGuid();
        }

        public virtual void Draw(DrawingContext context, ODLayer layer)
        {
            // Base draw method, to be overridden by derived classes
        }

    }
}





** ODLine.cs **
Path: .\ODCore\ODGeometry\ODLine.cs

ï»¿using Avalonia;
using Avalonia.Controls.Shapes;
using Avalonia.Media;
using OpenDraft.ODCore.ODData;
using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading.Tasks;

namespace OpenDraft.ODCore.ODGeometry
{
    internal class ODLine : ODElement
    {
        public ODPoint StartPoint { get; set; }
        public ODPoint EndPoint { get; set; }


        public ODLine(ODPoint startPoint, ODPoint endPoint)
        {
            StartPoint = startPoint;
            EndPoint = endPoint;
        }


        public override void Draw(DrawingContext context, ODLayer layer)
        {
            if (layer != null && !layer.IsVisible)
                return;

            if (layer == null)
                return;
            
            Pen pen = new Pen(new SolidColorBrush(Color.Parse(layer.Color)), layer.LineWeight);

            context.DrawLine(pen,
                    new Point(StartPoint.X, StartPoint.Y),
                    new Point(EndPoint.X, EndPoint.Y));
        }

    }
}





** ODPoint.cs **
Path: .\ODCore\ODGeometry\ODPoint.cs

ï»¿using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading.Tasks;

namespace OpenDraft.ODCore.ODGeometry
{
    public class ODPoint : ODElement
    {
        public float X { get; set; }
        public float Y { get; set; }
        public ODPoint(double x, double y)
        {
            X = (float)x;
            Y = (float)y;
        }

        public ODPoint(float x, float y)
        {
            X = x;
            Y = y;
        }
    }
}





** ODMath.cs **
Path: .\ODCore\ODMath\ODMath.cs

ï»¿using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading.Tasks;

namespace OpenDraft.ODCore.ODMath
{
    public class ODVec2
        {
        public float X { get; set; }
        public float Y { get; set; }
        public ODVec2(float x, float y)
        {
            X = x;
            Y = y;
        }
        public static ODVec2 operator +(ODVec2 a, ODVec2 b)
        {
            return new ODVec2(a.X + b.X, a.Y + b.Y);
        }

        public static ODVec2 operator -(ODVec2 a, ODVec2 b)
        {
            return new ODVec2(a.X - b.X, a.Y - b.Y);
        }

        public static ODVec2 operator *(ODVec2 a, float scalar)
        {
            return new ODVec2(a.X * scalar, a.Y * scalar);
        }
        
        public static ODVec2 operator /(ODVec2 a, float scalar)
        {
            if (scalar == 0)
                throw new DivideByZeroException("Cannot divide by zero.");
            return new ODVec2(a.X / scalar, a.Y / scalar);
        }
        
        public float Magnitude()
        {
            return (float)Math.Sqrt(X * X + Y * Y);
        }
        
        public ODVec2 Normalize()
        {
            float magnitude = Magnitude();
            if (magnitude == 0)
                throw new InvalidOperationException("Cannot normalize a zero vector.");
            return this / magnitude;
        }
        
        public override string ToString()
        {
            return $"({X}, {Y})";
        }
    }
}





** ODStyle.axaml **
Path: .\Styles\ODStyle.axaml

<Styles xmlns="https://github.com/avaloniaui"
    xmlns:x="http://schemas.microsoft.com/winfx/2006/xaml">

	<Styles.Resources>
		<Color x:Key="BackgroundDark">#141415</Color>
		<Color x:Key="BackgroundLight">#1E2024</Color>
        <Color x:Key="PrimaryColor">#333</Color>
        <Color x:Key="AccentColor">#FF0000</Color>
		<SolidColorBrush x:Key="BackgroundDarkBrush" Color="{DynamicResource BackgroundDark}"/>
		<SolidColorBrush x:Key="BackgroundLightBrush" Color="{DynamicResource BackgroundLight}"/>
        <SolidColorBrush x:Key="PrimaryBrush" Color="{DynamicResource PrimaryColor}"/>
        <SolidColorBrush x:Key="AccentBrush" Color="{DynamicResource AccentColor}"/>
    </Styles.Resources>

	<Style Selector="Window">
		<Setter Property="FontSize" Value="12"/>
		<Setter Property="Background" Value="{DynamicResource BackgroundDarkBrush}"/>
	</Style>
  
	<Style Selector="Button">
		<Setter Property="Margin" Value="2"/>
		<Setter Property="Padding" Value="2"/>
		<Setter Property="Background" Value="#333"/>
		<Setter Property="CornerRadius" Value="1"/>
		<Setter Property="Height" Value="36"/>
	</Style>

	<Style Selector="Menu">
		<Setter Property="Background" Value="{DynamicResource BackgroundDarkBrush}"/>
		<Setter Property="Height" Value="22"/>
	</Style>

	<Style Selector="MenuItem">
		<Setter Property="Background" Value="Transparent"/>
		<Setter Property="Foreground" Value="#CCC"/>
		<Setter Property="CornerRadius" Value="4"/>
	</Style>




	

	<Style Selector="MenuItem:pointerover /template/ Border#PART_LayoutRoot">
		<Setter Property="Background" Value="#80FF0000"/>
	</Style>
	






	<Style Selector="StackPanel.toolbar">
		<Setter Property="Background" Value="{DynamicResource BackgroundLightBrush}"/>
		<Setter Property="Height" Value="40"/>
		<Setter Property="Orientation" Value="Horizontal"/>
	</Style>

	<Style Selector="StackPanel.statusbar">
		<Setter Property="Background" Value="{DynamicResource BackgroundLightBrush}"/>
		<Setter Property="Height" Value="32"/>
		<Setter Property="Orientation" Value="Horizontal"/>
	</Style>

	<Style Selector="StackPanel.toolbar > Button">
		<Setter Property="Background" Value="{DynamicResource BackgroundLightBrush}"/>
		<Setter Property="Width" Value="28"/>
		<Setter Property="Height" Value="28"/>
	</Style>

	<Style Selector="StackPanel.statusbar > Button">
		<Setter Property="Background" Value="Red"/>
		<Setter Property="Width" Value="28"/>
		<Setter Property="Height" Value="28"/>
	</Style>

</Styles>




** ODSystem.cs **
Path: .\System\ODSystem.cs

ï»¿using System;
using System.Collections.Generic;
using System.Diagnostics;
using System.IO;
using System.Text.Json;
using System.Threading.Tasks;

namespace OpenDraft
{
    public static class ODSystem
    {
        private static Dictionary<string, string> _dictionary = new Dictionary<string, string>();


        public static void Initialise()
        {
            LoadRegistry();
        }

        private static void LoadRegistry()
        {
            _dictionary.Clear();
            string registryPath = "config.json";

            if (File.Exists(registryPath))
            {
                string json = File.ReadAllText(registryPath);
                using var doc = JsonDocument.Parse(json);

                var flat = new Dictionary<string, string>();
                FlattenJson(doc.RootElement, "", flat);

                foreach (var kvp in flat)
                    _dictionary[kvp.Key] = kvp.Value;
            }

            Debug.WriteLine($"ODSystem registry loaded with {_dictionary.Count} entries.");
        }

        private static void FlattenJson(JsonElement element, string prefix, Dictionary<string, string> result)
        {
            switch (element.ValueKind)
            {
                case JsonValueKind.Object:
                    foreach (var prop in element.EnumerateObject())
                    {
                        string newPrefix = string.IsNullOrEmpty(prefix) ? prop.Name : $"{prefix}/{prop.Name}";
                        FlattenJson(prop.Value, newPrefix, result);
                    }
                    break;

                case JsonValueKind.Array:
                    foreach (var item in element.EnumerateArray())
                    {
                        // Donât append an index â treat array items as part of the same scope
                        FlattenJson(item, prefix, result);
                    }
                    break;

                default:
                    result[prefix] = element.ToString();
                    break;
            }
        }

        public static string? GetRegistrValueAsString(string key)
        {
            if (_dictionary.TryGetValue(key, out var value))
            {
                return value;
            }
            return null;
        }

        public static int? GetRegistrValueAsInt(string key)
        {
            if (_dictionary.TryGetValue(key, out var value))
            {
                if (int.TryParse(value, out var intValue))
                {
                    return intValue;
                }
            }
            return null;
        }

        public static bool? GetRegistrValueAsBool(string key)
        {
            if (_dictionary.TryGetValue(key, out var value))
            {
                if (bool.TryParse(value, out var boolValue))
                {
                    return boolValue;
                }
            }
            return null;
        }

        public static float ? GetRegistrValueAsDecimal(string key)
        {
            if (_dictionary.TryGetValue(key, out var value))
            {
                if (float.TryParse(value, out var floatValue))
                {
                    return floatValue;
                }
            }
            return null;
        }

        public static void SetRegistryValue(string key, string value)
        {
            _dictionary[key] = value;
            SaveRegistry();
        }

        private static void SaveRegistry()
        {
            // Save registry to file or other source
            // For example, write to a JSON file
            string registryPath = "config.json";
            var json = JsonSerializer.Serialize(_dictionary, new JsonSerializerOptions { WriteIndented = true });
            File.WriteAllText(registryPath, json);
            Debug.WriteLine("ODSystem registry saved with " + _dictionary.Count + " entries.");
        }

    }

}





** MainWindowViewModel.cs **
Path: .\ViewModels\MainWindowViewModel.cs

ï»¿using OpenDraft.ODCore.ODData;
using OpenDraft.ODCore.ODEditor;
using OpenDraft.ODCore.ODGeometry;
using System.Collections.Generic;
using System.Collections.ObjectModel;

namespace OpenDraft.ViewModels
{
    public class MainWindowViewModel : ViewModelBase
    {
        public ODDataManager DataManager { get; }
        public IODEditorInputService InputService { get; }
        public ODEditor EditorRoot { get; private set; }

        public ObservableCollection<ODElement> GeometryElements => DataManager.Elements;
        public ODLayerManager LayerManager => DataManager.LayerManager;
        public ODEditor Editor => EditorRoot;

        public MainWindowViewModel()
        {
            ODSystem.Initialise();

            // Initialize the DataManager and Editor
            DataManager = new ODDataManager();
            InputService = new ODEditorInputService();
            EditorRoot = new ODEditor(DataManager, InputService);

            // Set up layers (this can stay as-is)
            DataManager.LayerManager.AddLayer("New Layer");
            DataManager.LayerManager.SetActiveLayer("New Layer");

            ODLayer? lay = DataManager.LayerManager.GetLayerByName("New Layer");
            if (lay != null)
            {
                lay.Color = "#00FF00";
                lay.LineWeight = 2.0f;
            }


            // This would create the same square using the LINE command
            // Note: This is still interactive and will wait for user input
            Editor.ExecuteCommand("LINE"); // Then user clicks two points
            
        }

        
    }
}




** ViewModelBase.cs **
Path: .\ViewModels\ViewModelBase.cs

ï»¿using CommunityToolkit.Mvvm.ComponentModel;

namespace OpenDraft.ViewModels
{
    public class ViewModelBase : ObservableObject
    {
    }
}





** MainWindow.axaml **
Path: .\Views\MainWindow.axaml

<Window xmlns="https://github.com/avaloniaui"
        xmlns:x="http://schemas.microsoft.com/winfx/2006/xaml"
        xmlns:vm="using:OpenDraft.ViewModels"
        xmlns:local="using:OpenDraft"
        xmlns:d="http://schemas.microsoft.com/expression/blend/2008"
        xmlns:mc="http://schemas.openxmlformats.org/markup-compatibility/2006"
        mc:Ignorable="d" d:DesignWidth="800" d:DesignHeight="450"
        x:Class="OpenDraft.Views.MainWindow"
        x:DataType="vm:MainWindowViewModel"
        Icon="/Assets/od-icon2.ico"
        Title="OpenDraft"
        Width="800"
        Height="400"
		MinWidth="800"
		MinHeight="400"
		>
  <!-- WindowState="Maximized"> -->

  <!-- Top Menu -->
  <Design.DataContext>
    <vm:MainWindowViewModel/>
  </Design.DataContext>

  <Grid>
    <Grid.RowDefinitions>
      <RowDefinition Height="Auto"/>      <!-- Menu strip -->
      <RowDefinition Height="Auto"/>      <!-- Toolbar -->
      <RowDefinition Height="*"/>         <!-- Viewport (fills space) -->
      <RowDefinition Height="Auto"/>      <!-- Status bar -->
    </Grid.RowDefinitions>

    <Menu Grid.Row="0" Height="22">
      <MenuItem Header="_File">
        <MenuItem Header="_New"/>
        <MenuItem Header="_Open"/>
        <MenuItem Header="_Save" />
        <MenuItem Header="Save _As" />
        <Separator/>
        <MenuItem Header="E_xit" />
      </MenuItem>
      <MenuItem Header="_Edit">
        <MenuItem Header="_Undo" />
        <MenuItem Header="_Redo" />
        <Separator/>
        <MenuItem Header="Cu_t" />
        <MenuItem Header="_Copy" />
        <MenuItem Header="_Paste" />
        <Separator/>
        <MenuItem Header="_Delete" />
        <Separator/>
        <MenuItem Header="Select _All" />
      </MenuItem>
      <MenuItem Header="_View">
        <MenuItem Header="Zoom _In" />
        <MenuItem Header="Zoom _Out" />
        <MenuItem Header="_Reset Zoom" />
        <Separator/>
        <MenuItem Header="_Grid Settings..." />
      </MenuItem>
      <MenuItem Header="_Help">
        <MenuItem Header="_About" />
      </MenuItem>
    </Menu>


    <!-- Toolbar -->
    <StackPanel
      Classes="toolbar"
      Grid.Row="1"
      HorizontalAlignment="Stretch"
      Orientation="Horizontal">
        <Button Content="Select" />
        <Button Content="Line" />
        <Button Content="Circle" />
    </StackPanel>
    
    
    <!-- Use Grid.Row attached property -->
    <local:Viewport Grid.Row="2"
                    HorizontalAlignment="Stretch"
                    VerticalAlignment="Stretch"
                    Elements="{Binding GeometryElements}"
                    DynamicElements="{Binding Editor.DynamicElements}"
                    LayerManager="{Binding LayerManager}"
                    Editor="{Binding Editor}"
                    InputService ="{Binding InputService}"/>

    <!-- Status Bar -->
    <StackPanel
      Classes="statusbar"
      Grid.Row="3"
      HorizontalAlignment="Stretch"
      Orientation="Horizontal">
      <Button Content="Select" />
      <Button Content="Line" />
      <Button Content="Circle" />
    </StackPanel>
    
  </Grid>
</Window>





** MainWindow.axaml.cs **
Path: .\Views\MainWindow.axaml.cs

using Avalonia.Controls;
using Avalonia.Input;
using OpenDraft.ViewModels;

namespace OpenDraft.Views
{
    public partial class MainWindow : Window
    {
        public MainWindow()
        {
            InitializeComponent();

            // Subscribe to key events at window level
            AddHandler(KeyDownEvent, OnKeyDown, handledEventsToo: true);
        }

        private void OnKeyDown(object? sender, KeyEventArgs e)
        {
            if (DataContext is MainWindowViewModel vm)
            {
                // Route all keys to input service
                vm.InputService.RaiseKeyPressed(e.Key);

                // Special case: ESC also triggers cancel specifically
                if (e.Key == Key.Escape)
                {
                    vm.InputService.RaiseCancelRequested();
                    e.Handled = true;
                }
            }
        }
    }
}


