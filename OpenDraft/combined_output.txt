

** App.axaml **
Path: D:\OpenDraft\OpenDraft\App.axaml

<Application xmlns="https://github.com/avaloniaui"
             xmlns:x="http://schemas.microsoft.com/winfx/2006/xaml"
             x:Class="OpenDraft.App"
             xmlns:local="using:OpenDraft"
             RequestedThemeVariant="Default">
  <Application.DataTemplates>
    <local:ViewLocator/>
  </Application.DataTemplates>
  <Application.Styles>
    <FluentTheme />
    <StyleInclude Source="avares://OpenDraft/Styles/ODStyle.axaml"/>
  </Application.Styles>
</Application>

** App.axaml.cs **
Path: D:\OpenDraft\OpenDraft\App.axaml.cs

using System.Linq;
using Avalonia;
using Avalonia.Controls.ApplicationLifetimes;
using Avalonia.Data.Core;
using Avalonia.Data.Core.Plugins;
using Avalonia.Markup.Xaml;
using OpenDraft.ViewModels;
using OpenDraft.Views;
using Avalonia.Controls;
using System;
using OpenDraft.XSVG;
namespace OpenDraft
{
    public partial class App : Application
    {
        public override void Initialize()
        {
            AvaloniaXamlLoader.Load(this);
        }
        public override void OnFrameworkInitializationCompleted()
        {
            if (ApplicationLifetime is IClassicDesktopStyleApplicationLifetime desktop)
            {
                // Avoid duplicate validations from both Avalonia and the CommunityToolkit. 
                // More info: https://docs.avaloniaui.net/docs/guides/development-guides/data-validation#manage-validationplugins
                DisableAvaloniaDataAnnotationValidation();
                desktop.MainWindow = new MainWindow
                {
                    DataContext = new MainWindowViewModel(),
                };
                // Subscribe to Exit event for cleanup
                desktop.Exit += (_, __) => ODXsvgReader.CleanupAllTempFiles();
            }
            base.OnFrameworkInitializationCompleted();
        }
        private void DisableAvaloniaDataAnnotationValidation()
        {
            // Get an array of plugins to remove
            var dataValidationPluginsToRemove =
                BindingPlugins.DataValidators.OfType<DataAnnotationsValidationPlugin>().ToArray();
            // remove each entry found
            foreach (var plugin in dataValidationPluginsToRemove)
            {
                BindingPlugins.DataValidators.Remove(plugin);
            }
        }
    }
}

** Program.cs **
Path: D:\OpenDraft\OpenDraft\Program.cs

ï»¿using System;
using Avalonia;
namespace OpenDraft
{
    internal sealed class Program
    {
        // Initialization code. Don't use any Avalonia, third-party APIs or any
        // SynchronizationContext-reliant code before AppMain is called: things aren't initialized
        // yet and stuff might break.
        [STAThread]
        public static void Main(string[] args) => BuildAvaloniaApp()
            .StartWithClassicDesktopLifetime(args);
        // Avalonia configuration, don't remove; also used by visual designer.
        public static AppBuilder BuildAvaloniaApp()
            => AppBuilder.Configure<App>()
                .UsePlatformDetect()
                .WithInterFont()
                .LogToTrace();
    }
}


** ViewLocator.cs **
Path: D:\OpenDraft\OpenDraft\ViewLocator.cs

using System;
using Avalonia.Controls;
using Avalonia.Controls.Templates;
using OpenDraft.ViewModels;
namespace OpenDraft
{
    public class ViewLocator : IDataTemplate
    {
        public Control? Build(object? param)
        {
            if (param is null)
                return null;
            var name = param.GetType().FullName!.Replace("ViewModel", "View", StringComparison.Ordinal);
            var type = Type.GetType(name);
            if (type != null)
            {
                return (Control)Activator.CreateInstance(type)!;
            }
            return new TextBlock { Text = "Not Found: " + name };
        }
        public bool Match(object? data)
        {
            return data is ViewModelBase;
        }
    }
}


** DynamicCanvas.axaml **
Path: D:\OpenDraft\OpenDraft\ODCore\DynamicCanvas.axaml

<UserControl xmlns="https://github.com/avaloniaui"
             x:Class="OpenDraft.DynamicCanvas"
             xmlns:x="http://schemas.microsoft.com/winfx/2006/xaml">
</UserControl>


** DynamicCanvas.axaml.cs **
Path: D:\OpenDraft\OpenDraft\ODCore\DynamicCanvas.axaml.cs

using Avalonia;
using Avalonia.Controls;
using Avalonia.Markup.Xaml;
using Avalonia.Media;
using System;
namespace OpenDraft;
public partial class DynamicCanvas : Control
{
    public Action<DrawingContext, Rect>? OnRender { get; set; }
    public override void Render(DrawingContext context)
    {
        base.Render(context);
        OnRender?.Invoke(context, Bounds);
    }
}


** StaticCanvas.axaml **
Path: D:\OpenDraft\OpenDraft\ODCore\StaticCanvas.axaml

<UserControl xmlns="https://github.com/avaloniaui"
             x:Class="OpenDraft.StaticCanvas"
             xmlns:x="http://schemas.microsoft.com/winfx/2006/xaml">
</UserControl>

** StaticCanvas.axaml.cs **
Path: D:\OpenDraft\OpenDraft\ODCore\StaticCanvas.axaml.cs

using Avalonia;
using Avalonia.Controls;
using Avalonia.Markup.Xaml;
using Avalonia.Media;
using System;
namespace OpenDraft;
public partial class StaticCanvas : Control
{
    public Action<DrawingContext, Rect>? OnRender { get; set; }
    public override void Render(DrawingContext context)
    {
        base.Render(context);
        OnRender?.Invoke(context, Bounds);
    }
}


** Viewport.axaml **
Path: D:\OpenDraft\OpenDraft\ODCore\Viewport.axaml

<UserControl xmlns="https://github.com/avaloniaui"
             xmlns:x="http://schemas.microsoft.com/winfx/2006/xaml"
             xmlns:d="http://schemas.microsoft.com/expression/blend/2008"
             xmlns:mc="http://schemas.openxmlformats.org/markup-compatibility/2006"
             xmlns:local="clr-namespace:OpenDraft"
             mc:Ignorable="d"
             x:Class="OpenDraft.Viewport"
             d:DesignWidth="800" d:DesignHeight="450">
    <UserControl.Styles>
        <Style Selector="local|Viewport">
            <Setter Property="Cursor" Value="Arrow"/>
        </Style>
        <Style Selector="local|Viewport:pointerover">
            <Setter Property="Cursor" Value="None"/>
        </Style>
    </UserControl.Styles>
	<Grid Background="Transparent">
        <local:StaticCanvas x:Name="StaticCanvas"
							IsHitTestVisible="False"
                            HorizontalAlignment="Stretch"
                            VerticalAlignment="Stretch" />
        <local:DynamicCanvas x:Name="DynamicCanvas"
							 IsHitTestVisible="False"
                             HorizontalAlignment="Stretch"
                             VerticalAlignment="Stretch" />
    </Grid>
</UserControl>


** Viewport.axaml.cs **
Path: D:\OpenDraft\OpenDraft\ODCore\Viewport.axaml.cs

using Avalonia;
using Avalonia.Controls;
using Avalonia.Input;
using Avalonia.Media;
using Avalonia.Threading;
using OpenDraft.ODCore.ODData;
using OpenDraft.ODCore.ODEditor;
using OpenDraft.ODCore.ODEditor.ODDynamics;
using OpenDraft.ODCore.ODGeometry;
using OpenDraft.ODCore.ODMath;
using System;
using System.Collections.ObjectModel;
using System.Diagnostics;
namespace OpenDraft
{
    public partial class Viewport : UserControl
    {
        public static readonly StyledProperty<ObservableCollection<ODElement>> ElementsProperty =
            AvaloniaProperty.Register<Viewport, ObservableCollection<ODElement>>(nameof(Elements));
        public static readonly StyledProperty<ODDrawConnector> DrawConnectorProperty =
            AvaloniaProperty.Register<Viewport, ODDrawConnector>(nameof(DrawConnector));
        public static readonly StyledProperty<IODEditorInputService> InputServiceProperty =
            AvaloniaProperty.Register<Viewport, IODEditorInputService>(nameof(InputService));
        public static readonly StyledProperty<ObservableCollection<ODDynamicElement>> DynamicElementsProperty =
            AvaloniaProperty.Register<Viewport, ObservableCollection<ODDynamicElement>>(nameof(DynamicElements));
        public ObservableCollection<ODElement> Elements
        {
            get => GetValue(ElementsProperty);
            set => SetValue(ElementsProperty, value);
        }
        public ODDrawConnector DrawConnector
        {
            get => GetValue(DrawConnectorProperty);
            set => SetValue(DrawConnectorProperty, value);
        }
        public IODEditorInputService InputService
        {
            get => GetValue(InputServiceProperty);
            set => SetValue(InputServiceProperty, value);
        }
        public ObservableCollection<ODDynamicElement> DynamicElements
        {
            get => GetValue(DynamicElementsProperty);
            set => SetValue(DynamicElementsProperty, value);
        }
        private readonly ViewportCamera Camera = new();
        private bool isPanning = false;
        private Point _lastPointerDragPosition;
        private Point _mousePosition;
        private Size _lastSize;
        private bool _isInitialized = false;
        public Viewport()
        {
            InitializeComponent();
            Background = Brushes.Transparent;
            Elements ??= new ObservableCollection<ODElement>();
            DynamicElements ??= new ObservableCollection<ODDynamicElement>();
            SubscribeToCollection(Elements, OnElementsChanged);
            SubscribeToCollection(DynamicElements, OnDynamicElementsChanged);
            PointerPressed += OnPointerPressed;
            PointerReleased += OnPointerReleased;
            PointerMoved += OnPointerMoved;
            PointerWheelChanged += OnPointerWheelChanged;
            PointerEntered += OnPointerEntered;
            PointerExited += OnPointerExited;
            SetupStaticCanvas();
            SetupDynamicCanvas();
        }
        private void SubscribeToCollection<T>(ObservableCollection<T> collection, System.Collections.Specialized.NotifyCollectionChangedEventHandler handler)
        {
            if (collection == null) return;
            collection.CollectionChanged -= handler;
            collection.CollectionChanged += handler;
        }
        private void OnElementsChanged(object? sender, System.Collections.Specialized.NotifyCollectionChangedEventArgs e)
        {
            StaticCanvas?.InvalidateVisual();
        }
        private void OnDynamicElementsChanged(object? sender, System.Collections.Specialized.NotifyCollectionChangedEventArgs e)
        {
            DynamicCanvas?.InvalidateVisual();
        }
        private void SetupStaticCanvas()
        {
            StaticCanvas.OnRender = (context, bounds) =>
            {
                if (Elements == null) return;
                var matrix = Camera.GetMatrix(bounds.Height);
                using (context.PushTransform(matrix))
                {
                    foreach (var element in Elements)
                    {
                        var layer = DrawConnector.GetLayerByID(element.LayerId);
                        if (layer != null)
                            element.Draw(context, DrawConnector);
                    }
                }
            };
            StaticCanvas.InvalidateVisual();
        }
        private void SetupDynamicCanvas()
        {
            DynamicCanvas.OnRender = (context, bounds) =>
            {
                if (DynamicElements == null) return;
                ODVec2 vpWorldSize = new ODVec2(bounds.Width / Camera.Scale, bounds.Height / Camera.Scale);
                ODVec2 worldMousePoint = new ODVec2(GetWorldMousePosition().X, GetWorldMousePosition().Y);
                var matrix = Camera.GetMatrix(bounds.Height);
                using (context.PushTransform(matrix))
                {
                    if (DynamicElements != null)
                        foreach (ODDynamicElement element in DynamicElements)
                        {
                            ODLayer? layer = DrawConnector.GetLayerByID(element.LayerId);
                            if (layer != null) element.Draw(context, DrawConnector, Camera.Scale, vpWorldSize, worldMousePoint);
                        }
                }
            };
            var timer = new DispatcherTimer { Interval = TimeSpan.FromMilliseconds(16) };
            timer.Tick += (_, _) => DynamicCanvas?.InvalidateVisual();
            timer.Start();
        }
        protected override Size ArrangeOverride(Size finalSize)
        {
            if (!_isInitialized)
            {
                _isInitialized = true;
                Camera.Position = new Point(-finalSize.Width / 2 / Camera.Scale, -finalSize.Height / 2 / Camera.Scale);
            }
            else
            {
                Camera.Position -= new Vector(
                    (finalSize.Width - _lastSize.Width) / 2 / Camera.Scale,
                    (finalSize.Height - _lastSize.Height) / 2 / Camera.Scale);
            }
            _lastSize = finalSize;
            StaticCanvas?.InvalidateVisual();
            return base.ArrangeOverride(finalSize);
        }
        protected override void OnPropertyChanged(AvaloniaPropertyChangedEventArgs change)
        {
            base.OnPropertyChanged(change);
            if (!_isInitialized) return;
            if (change.Property == ElementsProperty)
                SubscribeToCollection(Elements, OnElementsChanged);
            else if (change.Property == DynamicElementsProperty)
                SubscribeToCollection(DynamicElements, OnDynamicElementsChanged);
            StaticCanvas?.InvalidateVisual();
            DynamicCanvas?.InvalidateVisual();
        }
        private void OnPointerPressed(object? sender, PointerPressedEventArgs e)
        {
            if (e.GetCurrentPoint(this).Properties.IsMiddleButtonPressed)
            {
                _lastPointerDragPosition = e.GetPosition(this);
                isPanning = true;
            }
        }
        private void OnPointerReleased(object? sender, PointerReleasedEventArgs e)
        {
            if (e.InitialPressMouseButton == MouseButton.Left)
            {
                var ODVec2 = new ODVec2(GetWorldMousePosition().X, GetWorldMousePosition().Y);
                InputService?.RaisePointProvided(ODVec2);
                e.Handled = true;
            }
            if (e.InitialPressMouseButton == MouseButton.Middle)
                isPanning = false;
        }
        private void OnPointerMoved(object? sender, PointerEventArgs e)
        {
            _mousePosition = e.GetPosition(this);
            DynamicCanvas?.InvalidateVisual();
            if (!isPanning) return;
            var current = e.GetPosition(this);
            Camera.MoveBy(new Vector(-(current.X - _lastPointerDragPosition.X) / Camera.Scale,
                                     (current.Y - _lastPointerDragPosition.Y) / Camera.Scale));
            _lastPointerDragPosition = current;
            StaticCanvas?.InvalidateVisual();
        }
        private void OnPointerEntered(object? sender, PointerEventArgs e)
        {
            InputService?.RaiseViewportEntered();
        }
        private void OnPointerExited(object? sender, PointerEventArgs e)
        {
            InputService?.RaiseViewportExited();
        }
        private void OnPointerWheelChanged(object? sender, PointerWheelEventArgs e)
        {
            var mousePos = e.GetPosition(this);
            double zoomFactor = 1.1f;
            double oldScale = Camera.Scale;
            double newScale = oldScale * Math.Pow(zoomFactor, e.Delta.Y > 0 ? 1 : -1);
            Point ScreenToWorld(Point screen, double scale) =>
                new(screen.X / scale - Camera.Position.X, (Bounds.Height - screen.Y) / scale - Camera.Position.Y);
            var oldWorld = ScreenToWorld(mousePos, oldScale);
            var newWorld = ScreenToWorld(mousePos, newScale);
            Camera.Position += oldWorld - newWorld; // <--- fix here
            Camera.Scale = newScale;
            StaticCanvas?.InvalidateVisual();
            DynamicCanvas?.InvalidateVisual();
        }
        public Point GetScreenMousePosition() => _mousePosition;
        public ODVec2 GetWorldMousePosition()
        {
            double x = (_mousePosition.X / Camera.Scale + Camera.Position.X);
            double y = ((Bounds.Height - _mousePosition.Y) / Camera.Scale) + Camera.Position.Y;
            return new ODVec2(x,y);
        }
    }
}


** ODColour.cs **
Path: D:\OpenDraft\OpenDraft\ODCore\ODData\ODColour.cs

ï»¿using System;
namespace OpenDraft.ODCore.ODData
{
    public class ODColour
    {
        // Basic colors
        public static ODColour Red => new(255, 0, 0);
        public static ODColour Green => new(0, 255, 0);
        public static ODColour Blue => new(0, 0, 255);
        public static ODColour White => new(255, 255, 255);
        public static ODColour Black => new(0, 0, 0);
        public static ODColour Transparent => new(0, 0, 0, 0);
        // Secondary colors
        public static ODColour Yellow => new(255, 255, 0);
        public static ODColour Cyan => new(0, 255, 255);
        public static ODColour Magenta => new(255, 0, 255);
        // Grayscale variants
        public static ODColour Gray => new(128, 128, 128);
        public static ODColour LightGray => new(211, 211, 211);
        public static ODColour DarkGray => new(169, 169, 169);
        public static ODColour Silver => new(192, 192, 192);
        public static ODColour DimGray => new(105, 105, 105);
        public static ODColour SlateGray => new(112, 128, 144);
        // Red family
        public static ODColour DarkRed => new(139, 0, 0);
        public static ODColour FireBrick => new(178, 34, 34);
        public static ODColour Crimson => new(220, 20, 60);
        public static ODColour IndianRed => new(205, 92, 92);
        public static ODColour LightCoral => new(240, 128, 128);
        public static ODColour Salmon => new(250, 128, 114);
        public static ODColour DarkSalmon => new(233, 150, 122);
        public static ODColour LightSalmon => new(255, 160, 122);
        // Green family
        public static ODColour DarkGreen => new(0, 100, 0);
        public static ODColour ForestGreen => new(34, 139, 34);
        public static ODColour SeaGreen => new(46, 139, 87);
        public static ODColour MediumSeaGreen => new(60, 179, 113);
        public static ODColour LimeGreen => new(50, 205, 50);
        public static ODColour SpringGreen => new(0, 255, 127);
        public static ODColour MediumSpringGreen => new(0, 250, 154);
        public static ODColour PaleGreen => new(152, 251, 152);
        public static ODColour LightGreen => new(144, 238, 144);
        public static ODColour LawnGreen => new(124, 252, 0);
        public static ODColour Chartreuse => new(127, 255, 0);
        public static ODColour Olive => new(128, 128, 0);
        public static ODColour OliveDrab => new(107, 142, 35);
        public static ODColour DarkOliveGreen => new(85, 107, 47);
        // Blue family
        public static ODColour DarkBlue => new(0, 0, 139);
        public static ODColour MediumBlue => new(0, 0, 205);
        public static ODColour RoyalBlue => new(65, 105, 225);
        public static ODColour SteelBlue => new(70, 130, 180);
        public static ODColour DodgerBlue => new(30, 144, 255);
        public static ODColour DeepSkyBlue => new(0, 191, 255);
        public static ODColour CornflowerBlue => new(100, 149, 237);
        public static ODColour SkyBlue => new(135, 206, 235);
        public static ODColour LightSkyBlue => new(135, 206, 250);
        public static ODColour LightSteelBlue => new(176, 196, 222);
        public static ODColour LightBlue => new(173, 216, 230);
        public static ODColour PowderBlue => new(176, 224, 230);
        public static ODColour Navy => new(0, 0, 128);
        public static ODColour MidnightBlue => new(25, 25, 112);
        public static ODColour DarkSlateBlue => new(72, 61, 139);
        // Purple/Magenta family
        public static ODColour Purple => new(128, 0, 128);
        public static ODColour DarkMagenta => new(139, 0, 139);
        public static ODColour DarkViolet => new(148, 0, 211);
        public static ODColour BlueViolet => new(138, 43, 226);
        public static ODColour MediumPurple => new(147, 112, 219);
        public static ODColour MediumOrchid => new(186, 85, 211);
        public static ODColour Orchid => new(218, 112, 214);
        public static ODColour Violet => new(238, 130, 238);
        public static ODColour Plum => new(221, 160, 221);
        public static ODColour Thistle => new(216, 191, 216);
        public static ODColour Lavender => new(230, 230, 250);
        // Orange/Brown family
        public static ODColour Orange => new(255, 165, 0);
        public static ODColour DarkOrange => new(255, 140, 0);
        public static ODColour Coral => new(255, 127, 80);
        public static ODColour Tomato => new(255, 99, 71);
        public static ODColour OrangeRed => new(255, 69, 0);
        public static ODColour Gold => new(255, 215, 0);
        public static ODColour YellowGold => new(255, 223, 0);
        public static ODColour Goldenrod => new(218, 165, 32);
        public static ODColour DarkGoldenrod => new(184, 134, 11);
        public static ODColour Chocolate => new(210, 105, 30);
        public static ODColour SaddleBrown => new(139, 69, 19);
        public static ODColour Sienna => new(160, 82, 45);
        public static ODColour Brown => new(165, 42, 42);
        public static ODColour Maroon => new(128, 0, 0);
        public static ODColour Tan => new(210, 180, 140);
        public static ODColour RosyBrown => new(188, 143, 143);
        public static ODColour Peru => new(205, 133, 63);
        public static ODColour BurlyWood => new(222, 184, 135);
        public static ODColour Wheat => new(245, 222, 179);
        public static ODColour SandyBrown => new(244, 164, 96);
        // Pink family
        public static ODColour Pink => new(255, 192, 203);
        public static ODColour LightPink => new(255, 182, 193);
        public static ODColour HotPink => new(255, 105, 180);
        public static ODColour DeepPink => new(255, 20, 147);
        public static ODColour PaleVioletRed => new(219, 112, 147);
        public static ODColour MediumVioletRed => new(199, 21, 133);
        // Yellow family
        public static ODColour LightYellow => new(255, 255, 224);
        public static ODColour LemonChiffon => new(255, 250, 205);
        public static ODColour LightGoldenrodYellow => new(250, 250, 210);
        public static ODColour PapayaWhip => new(255, 239, 213);
        public static ODColour Moccasin => new(255, 228, 181);
        public static ODColour PeachPuff => new(255, 218, 185);
        public static ODColour PaleGoldenrod => new(238, 232, 170);
        public static ODColour Khaki => new(240, 230, 140);
        public static ODColour DarkKhaki => new(189, 183, 107);
        // Special/System colors
        public static ODColour AliceBlue => new(240, 248, 255);
        public static ODColour GhostWhite => new(248, 248, 255);
        public static ODColour Azure => new(240, 255, 255);
        public static ODColour MintCream => new(245, 255, 250);
        public static ODColour Honeydew => new(240, 255, 240);
        public static ODColour Ivory => new(255, 255, 240);
        public static ODColour Beige => new(245, 245, 220);
        public static ODColour OldLace => new(253, 245, 230);
        public static ODColour FloralWhite => new(255, 250, 240);
        public static ODColour Seashell => new(255, 245, 238);
        public static ODColour Snow => new(255, 250, 250);
        public static ODColour Linen => new(250, 240, 230);
        public static ODColour AntiqueWhite => new(250, 235, 215);
        public static ODColour NavajoWhite => new(255, 222, 173);
        public static ODColour Cornsilk => new(255, 248, 220);
        public static ODColour BlanchedAlmond => new(255, 235, 205);
        public static ODColour Bisque => new(255, 228, 196);
        public byte R { get; set; }
        public byte G { get; set; }
        public byte B { get; set; }
        public byte A { get; set; }
        public ODColour()
        {
            R = 0;
            G = 0;
            B = 0;
            A = 255;
        }
        public ODColour(byte r, byte g, byte b)
        {
            R = r;
            G = g;
            B = b;
            A = 255;
        }
        public ODColour(byte r, byte g, byte b, byte a)
        {
            R = r;
            G = g;
            B = b;
            A = a;
        }
        public ODColour(string hex)
        {
            SetFromHex(hex);
        }
        public ODColour(ODColour color)
        {
            R = color.R;
            G = color.G;
            B = color.B;
            A = color.A;
        }
        public ODColour(Avalonia.Media.Color color)
        {
            R = color.R;
            G = color.G;
            B = color.B;
            A = color.A;
        }
        public override string ToString()
        {
            return $"ODColour(R: {R}, G: {G}, B: {B}, A: {A})";
        }
        public void SetRGB(byte r, byte g, byte b)
        {
            R = r;
            G = g;
            B = b;
        }
        public void SetAlpha(byte a)
        {
            A = a;
        }
        public void SetRGBA(byte r, byte g, byte b, byte a)
        {
            R = r;
            G = g;
            B = b;
            A = a;
        }
        public void SetFromHex(string hex)
        {
            if (hex.StartsWith("#"))
            {
                hex = hex.Substring(1);
            }
            if (hex.Length == 6)
            {
                R = Convert.ToByte(hex.Substring(0, 2), 16);
                G = Convert.ToByte(hex.Substring(2, 2), 16);
                B = Convert.ToByte(hex.Substring(4, 2), 16);
                A = 255; // Default alpha
            }
            else if (hex.Length == 8)
            {
                R = Convert.ToByte(hex.Substring(0, 2), 16);
                G = Convert.ToByte(hex.Substring(2, 2), 16);
                B = Convert.ToByte(hex.Substring(4, 2), 16);
                A = Convert.ToByte(hex.Substring(6, 2), 16);
            }
            else
            {
                throw new ArgumentException("Hex string must be in the format RRGGBB or RRGGBBAA");
            }
        }
        public void SetFromHSL(float h, float s, float l, byte a = 255)
        {
            // Normalize inputs
            h = (h % 360 + 360) % 360; // Wrap hue to 0-360
            s = Math.Clamp(s, 0, 100);
            l = Math.Clamp(l, 0, 100);
            s /= 100f;
            l /= 100f;
            float c = (1 - Math.Abs(2 * l - 1)) * s;
            float x = c * (1 - Math.Abs((h / 60) % 2 - 1));
            float m = l - c / 2;
            float r, g, b;
            if (h >= 0 && h < 60) { r = c; g = x; b = 0; }
            else if (h >= 60 && h < 120) { r = x; g = c; b = 0; }
            else if (h >= 120 && h < 180) { r = 0; g = c; b = x; }
            else if (h >= 180 && h < 240) { r = 0; g = x; b = c; }
            else if (h >= 240 && h < 300) { r = x; g = 0; b = c; }
            else { r = c; g = 0; b = x; }
            R = (byte)((r + m) * 255);
            G = (byte)((g + m) * 255);
            B = (byte)((b + m) * 255);
            A = a;
        }
        public string ToHex()
        {
            return A == 255
                ? $"#{R:X2}{G:X2}{B:X2}"
                : $"#{R:X2}{G:X2}{B:X2}{A:X2}";
        }
        public Avalonia.Media.Color ToAvaloniaColor()
        {
            return Avalonia.Media.Color.FromArgb(A, R, G, B);
        }
        public ODColour Lighten(float factor)
        {
            factor = Math.Clamp(factor, 0, 1);
            return new ODColour(
                (byte)Math.Min(255, R + (255 - R) * factor),
                (byte)Math.Min(255, G + (255 - G) * factor),
                (byte)Math.Min(255, B + (255 - B) * factor),
                A
            );
        }
        public ODColour Darken(float factor)
        {
            factor = Math.Clamp(factor, 0, 1);
            return new ODColour(
                (byte)Math.Max(0, R * (1 - factor)),
                (byte)Math.Max(0, G * (1 - factor)),
                (byte)Math.Max(0, B * (1 - factor)),
                A
            );
        }
        public ODColour Invert()
        {
            return new ODColour(
                (byte)(255 - R),
                (byte)(255 - G),
                (byte)(255 - B),
                A
            );
        }
        public (float Hue, float Saturation, float Lightness) ToHSL()
        {
            float r = R / 255f;
            float g = G / 255f;
            float b = B / 255f;
            float max = Math.Max(r, Math.Max(g, b));
            float min = Math.Min(r, Math.Min(g, b));
            float delta = max - min;
            float hue = 0;
            float saturation = 0;
            float lightness = (max + min) / 2;
            if (delta != 0)
            {
                saturation = lightness < 0.5 ? delta / (max + min) : delta / (2 - max - min);
                if (max == r)
                    hue = (g - b) / delta + (g < b ? 6 : 0);
                else if (max == g)
                    hue = (b - r) / delta + 2;
                else
                    hue = (r - g) / delta + 4;
                hue *= 60;
            }
            return (hue, saturation * 100, lightness * 100);
        }
    }
}


** ODDataManager.cs **
Path: D:\OpenDraft\OpenDraft\ODCore\ODData\ODDataManager.cs

ï»¿using OpenDraft.ODCore.ODGeometry;
using System;
using System.Collections.ObjectModel;
namespace OpenDraft.ODCore.ODData
{
    public class ODDataManager
    {
        public ObservableCollection<ODGeometry.ODElement> Elements { get; } = new();
        public ODLayerManager LayerManager { get; } = new ODLayerManager();
        public ODLineStyleRegistry LineStyleRegister { get; } = new ODLineStyleRegistry();
        public ODSymbolTable SymbolTableRegister = new ODSymbolTable();
        public ODDataManager()
        {
        }
        public void AddElement(ODElement element)
        {
            if (element == null)
                throw new ArgumentNullException(nameof(element));
            if (Elements.Contains(element))
                return;
            element.LayerId = LayerManager.GetActiveLayer();
            Elements.Add(element);
        }
    }
}


** ODDrawConnector.cs **
Path: D:\OpenDraft\OpenDraft\ODCore\ODData\ODDrawConnector.cs

ï»¿using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading.Tasks;
using Avalonia.Media;
using OpenDraft.ODCore.ODEditor;
using OpenDraft.ODCore.ODGeometry;
namespace OpenDraft.ODCore.ODData
{
    public class ODDrawConnector
    {
        private ODDataManager DataManager;
        private ODEditor.ODEditor? Editor;
        private ODSymbolTable SymbolTable;
        public ODDrawConnector(ODDataManager dm, ODEditor.ODEditor ed, ODSymbolTable st)
        {
            DataManager = dm;
            Editor = ed;
            SymbolTable = st;
        }
        public ODLayer? GetLayerByName(string name) {
            return this.DataManager.LayerManager.GetLayerByName(name);
        }
        public ODLayer? GetLayerByID(ushort id) {
            return this.DataManager.LayerManager.GetLayerByID(id);
        }
        public IDashStyle ToAvaloniaDashStyle(string dashStyle)
        {
            ODLineStyleRegistry lsr = DataManager.LineStyleRegister;
            return lsr.ToAvaloniaDashStyle(dashStyle) ?? lsr.ToAvaloniaDashStyle("Continous")!;
        }
        public ODSymbolDefinition? GetSymbolDefinition(string symbolName)
        {
            return SymbolTable.GetSymbolDefinition(symbolName);
        }
    }
}


** ODLayer.cs **
Path: D:\OpenDraft\OpenDraft\ODCore\ODData\ODLayer.cs

ï»¿using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading.Tasks;
namespace OpenDraft.ODCore.ODData
{
    public class ODLayer
    {
        private ushort _id;
        public string Name { get; set; } = Guid.NewGuid().ToString();
        public ODColour Color { get; set; } = new ODColour("#FFFFFF");
        public string LineType { get; set; } = "Continuous";
        public float LineWeight { get; set; } = 0.6f;
        public bool IsVisible { get; set; } = true;
        public bool IsLocked { get; set; } = false;
        public bool IsSystemLayer { get; set; } = false;
        public ODLayer(ushort id, string name)
        {
            _id = id;
            Name = name;
        }
        public ushort getID()
        {
            return _id;
        }
    }
}


** ODLayerManager.cs **
Path: D:\OpenDraft\OpenDraft\ODCore\ODData\ODLayerManager.cs

ï»¿using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading.Tasks;
namespace OpenDraft.ODCore.ODData
{
    public class ODLayerManager
    {
        private List<ODLayer> Layers { get; set; } = new List<ODLayer>();
        private ushort ActiveLayer { get; set; }
        public ODLineStyleRegistry LineStyleRegistry { get; } = new ODLineStyleRegistry();
        public ODLayerManager()
        {
            // Add a default layer
            AddLayer("Default");
            AddLayer("Crosshair X");
            GetLayerByName("Crosshair X")!.IsSystemLayer = true;
            AddLayer("Crosshair Y");
            GetLayerByName("Crosshair Y")!.IsSystemLayer = true;
            AddLayer("Crosshair Square");
            GetLayerByName("Crosshair Square")!.IsSystemLayer = true;
        }
        private ushort GetNextAvailableID()
        {
            HashSet<ushort> usedIDs = new HashSet<ushort>(Layers.Select(layer => layer.getID()));
            for (ushort id = 0; id < ushort.MaxValue; id++)
            {
                if (!usedIDs.Contains(id))
                    return id;
            }
            throw new InvalidOperationException("No available layer IDs.");
        }
        public ushort GetActiveLayer()
        {
            return ActiveLayer;
        }
        public ushort AddLayer(string name)
        {
            ushort newID = GetNextAvailableID();
            ODLayer newLayer = new ODLayer(newID, name);
            Layers.Add(newLayer);
            return newID;
        }
        public ODLayer? GetLayerByName(string name)
        {
            return Layers.FirstOrDefault(layer => layer.Name == name);
        }
        public ODLayer? GetLayerByID(ushort id)
        {
            return Layers.FirstOrDefault(layer => layer.getID() == id);
        }
        public void SetActiveLayer(string name)
        {
            ODLayer? layer = GetLayerByName(name);
            if (layer != null)
            {
                ActiveLayer = layer.getID();
            }
            else
            {
                throw new ArgumentException($"Layer with name '{name}' does not exist.");
            }
        }
        public void RemoveLayer(string name)
        {
            ODLayer? layerToRemove = GetLayerByName(name);
            if (layerToRemove != null)
            {
                if (layerToRemove.IsSystemLayer)
                {
                    throw new InvalidOperationException("Cannot remove a system layer.");
                }
                if (ActiveLayer == layerToRemove.getID())
                {
                    SetActiveLayer("Default");
                }
                Layers.Remove(layerToRemove);
            }
        }
    }
}


** ODLineStyleRegistry.cs **
Path: D:\OpenDraft\OpenDraft\ODCore\ODData\ODLineStyleRegistry.cs

ï»¿using Avalonia.Media;
using System;
using System.Collections.Generic;
using System.Linq;
namespace OpenDraft.ODCore.ODData
{
    public class ODLineStyleRegistry
    {
        private Dictionary<string, string> lineStyles = new Dictionary<string, string>();
        private Dictionary<string, float[]> lineStyleArrays = new Dictionary<string, float[]>();
        public ODLineStyleRegistry()
        {
            InitialiseDefaultLineStyles();
        }
        private void InitialiseDefaultLineStyles()
        {
            // Store both string and array representations
            RegisterLineStyle("Continuous", "");
            RegisterLineStyle("Dashed", "10,5");
            RegisterLineStyle("Dotted", "2,5");
            RegisterLineStyle("DashDot", "10,5,2,5");
            RegisterLineStyle("DashDotDot", "10,5,2,5,2,5");
            RegisterLineStyle("Center", "20,5,2,5,2,5");
            RegisterLineStyle("Phantom", "25,5,2,5,2,5,2,5");
            RegisterLineStyle("Border", "15,3");
            RegisterLineStyle("Hidden", "5,3");
        }
        public string? GetStyleAsString(string name)
        {
            if (lineStyles.ContainsKey(name))
            {
                return lineStyles[name];
            }
            return null;
        }
        public float[]? GetStyleAsArray(string name)
        {
            if (lineStyleArrays.ContainsKey(name))
            {
                return lineStyleArrays[name];
            }
            return null;
        }
        public void RegisterLineStyle(string name, string dashArray)
        {
            lineStyles[name] = dashArray;
            // Pre-compute the array version for performance
            if (!string.IsNullOrEmpty(dashArray))
            {
                var parts = dashArray.Split(',');
                var array = new float[parts.Length];
                for (int i = 0; i < parts.Length; i++)
                {
                    if (float.TryParse(parts[i], out float value))
                    {
                        array[i] = value;
                    }
                    else
                    {
                        array[i] = 0;
                    }
                }
                lineStyleArrays[name] = array;
            }
            else
            {
                lineStyleArrays[name] = Array.Empty<float>();
            }
        }
        public void RegisterLineStyle(string name, float[] dashArray)
        {
            lineStyleArrays[name] = dashArray;
            lineStyles[name] = dashArray.Length > 0 ? string.Join(",", dashArray) : "";
        }
        public bool UnregisterLineStyle(string name)
        {
            bool removed1 = lineStyles.Remove(name);
            bool removed2 = lineStyleArrays.Remove(name);
            return removed1 || removed2;
        }
        public IEnumerable<string> GetAvailableStyleNames()
        {
            return lineStyles.Keys.OrderBy(name => name);
        }
        public bool StyleExists(string name)
        {
            return lineStyles.ContainsKey(name);
        }
        // Convert to Avalonia DashStyle
        public IDashStyle? ToAvaloniaDashStyle(string linetypeName)
        {
            var pattern = GetStyleAsArray(linetypeName);
            if (pattern == null || pattern.Length == 0)
                return null; // Continuous line
            return new DashStyle(pattern.Select(p => (double)p).ToArray(), 0);
        }
        // Parse from SVG dash array
        public string? FromSvgDashArray(string dashArray)
        {
            if (string.IsNullOrEmpty(dashArray) || dashArray == "none")
                return "Continuous";
            // Try to find exact match first
            var exactMatch = lineStyles.FirstOrDefault(x => x.Value == dashArray).Key;
            if (exactMatch != null)
                return exactMatch;
            // Try to parse and find similar
            try
            {
                var parts = dashArray.Split(',');
                var pattern = parts.Select(p => float.Parse(p.Trim())).ToArray();
                // Look for matching pattern
                foreach (var style in lineStyleArrays)
                {
                    if (style.Value.SequenceEqual(pattern))
                        return style.Key;
                }
                // No match found, create a custom style
                string customName = $"Custom_{dashArray.Replace(",", "_")}";
                RegisterLineStyle(customName, pattern);
                return customName;
            }
            catch
            {
                return "Continuous"; // Fallback
            }
        }
    }
}

** ODSelectionManager.cs **
Path: D:\OpenDraft\OpenDraft\ODCore\ODData\ODSelectionManager.cs

ï»¿using Avalonia.Controls;
using OpenDraft.ODCore.ODGeometry;
using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading.Tasks;
namespace OpenDraft.ODCore.ODData
{
    public class ODSelectionSet
    {
        public IReadOnlyCollection<ODElement> SelectedElements { get; }
        public ODSelectionSet()
        {
            SelectedElements = new List<ODElement>().AsReadOnly();
        }
        public ODSelectionSet(IEnumerable<ODElement> elements)
        {
            SelectedElements = elements?.ToList().AsReadOnly() ?? new List<ODElement>().AsReadOnly();
        }
        public bool IsEmpty => SelectedElements.Count == 0;
        public int Count => SelectedElements.Count;
        // Helper methods for common operations
        public ODSelectionSet AddElement(ODElement element)
        {
            if (element == null) return this;
            var newElements = SelectedElements.ToList();
            if (!newElements.Contains(element))
            {
                newElements.Add(element);
            }
            return new ODSelectionSet(newElements);
        }
        public ODSelectionSet AddElements(IEnumerable<ODElement> elements)
        {
            var elementList = elements?.ToList() ?? new List<ODElement>();
            if (elementList.Count == 0) return this;
            var newElements = SelectedElements.ToList();
            foreach (var element in elementList)
            {
                if (element != null && !newElements.Contains(element))
                {
                    newElements.Add(element);
                }
            }
            return new ODSelectionSet(newElements);
        }
        public ODSelectionSet RemoveElement(ODElement element)
        {
            if (element == null) return this;
            var newElements = SelectedElements.ToList();
            newElements.Remove(element);
            return new ODSelectionSet(newElements);
        }
        public ODSelectionSet Clear()
        {
            return new ODSelectionSet();
        }
        public bool Contains(ODElement element)
        {
            return SelectedElements.Contains(element);
        }
    }
    public class ODSelectionManager
    {
        private readonly ODDataManager _dataManager;        
        private ODSelectionSet _activeSelection;
        public ODSelectionManager(ODDataManager dataManager)
        {
            _dataManager = dataManager;
            _activeSelection = new ODSelectionSet();
        }
        public ODSelectionSet GetActiveSelectionSet()
        {
            return _activeSelection;
        }
        public void UpdateSelectionSet(ODSelectionSet selectionSet)
        {
            _activeSelection = selectionSet;
        }
    }
}

** ODSymbolTable.cs **
Path: D:\OpenDraft\OpenDraft\ODCore\ODData\ODSymbolTable.cs

ï»¿using OpenDraft.ODCore.ODGeometry;
using System.Collections.Generic;
namespace OpenDraft.ODCore.ODData
{
    public class ODSymbolTable
    {
        private List<ODSymbolDefinition> SymbolTable = new List<ODSymbolDefinition>();
        public ODSymbolDefinition? GetSymbolDefinition(string symbolName)
        {
            foreach (ODSymbolDefinition symbol in SymbolTable)
            {
                if (symbol.Name == symbolName)
                    return symbol;
            }
            return null;
        }
        public void AddSymbol(ODSymbolDefinition symbol)
        {
            SymbolTable.Add(symbol);
        }
    }
}


** IODEditorInputService.cs **
Path: D:\OpenDraft\OpenDraft\ODCore\ODEditor\IODEditorInputService.cs

ï»¿// IEditorInputService.cs
using Avalonia.Input;
using OpenDraft.ODCore.ODGeometry;
using OpenDraft.ODCore.ODMath;
using System;
namespace OpenDraft.ODCore.ODEditor
{
    public interface IODEditorInputService
    {
        // Events for different input types
        event Action<Key> KeyPressed;
        event Action<ODVec2> PointProvided;
        event Action<string> TextInput;
        event Action<double> NumberInput;
        event Action CancelRequested;
        event Action ViewportEntered;
        event Action ViewportExited;
        // ADD THESE METHODS to the interface
        void RaiseKeyPressed(Key key);
        void RaisePointProvided(ODVec2 point);
        void RaiseTextInput(string text);
        void RaiseNumberInput(double number);
        void RaiseCancelRequested();
        void RaiseViewportEntered();
        void RaiseViewportExited();
        // Methods to request specific input modes
        void RequestPointInput();
        void RequestTextInput();
        void CancelInputRequest();
    }
}

** ODBoundingBox.cs **
Path: D:\OpenDraft\OpenDraft\ODCore\ODEditor\ODBoundingBox.cs

ï»¿using OpenDraft.ODCore.ODMath;
public class ODBoundingBox
{
    private ODVec2 _origin;  // This should be the MINIMUM point (bottom-left in Y-up system)
    private ODVec2 _size;
    public ODBoundingBox(ODVec2 origin, ODVec2 size)
    {
        _origin = origin;
        _size = size;
    }
    public ODVec2 GetOrigin => _origin;
    public ODVec2 GetSize => _size;
    public double Width => _size.X;
    public double Height => _size.Y;
    // Fixed corner calculations
    public ODVec2 BottomLeft => _origin;  // Minimum X, Minimum Y
    public ODVec2 BottomRight => new ODVec2(_origin.X + _size.X, _origin.Y);
    public ODVec2 TopLeft => new ODVec2(_origin.X, _origin.Y + _size.Y);
    public ODVec2 TopRight => new ODVec2(_origin.X + _size.X, _origin.Y + _size.Y);
    public double Left => _origin.X;
    public double Right => _origin.X + _size.X;
    public double Bottom => _origin.Y;
    public double Top => _origin.Y + _size.Y;
    // Helper method to create from min/max points
    public static ODBoundingBox CreateFromMinMax(ODVec2 min, ODVec2 max)
    {
        return new ODBoundingBox(min, new ODVec2(max.X - min.X, max.Y - min.Y));
    }
}

** ODCommandAttribute.cs **
Path: D:\OpenDraft\OpenDraft\ODCore\ODEditor\ODCommandAttribute.cs

ï»¿// ODCommandAttribute.cs
using System;
namespace OpenDraft.ODCore.ODEditor.ODCommands
{
    [AttributeUsage(AttributeTargets.Class, Inherited = false, AllowMultiple = false)]
    public class ODCommandAttribute : Attribute
    {
        public string Name { get; }
        public string Description { get; }
        public string[] Aliases { get; }
        public ODCommandAttribute(string name, string description = "", params string[] aliases)
        {
            Name = name;
            Description = description;
            Aliases = aliases;
        }
    }
}

** ODEditor.cs **
Path: D:\OpenDraft\OpenDraft\ODCore\ODEditor\ODEditor.cs

ï»¿using Avalonia.Input;
using Avalonia.Threading;
using OpenDraft.ODCore.ODData;
using OpenDraft.ODCore.ODEditor.ODCommands;
using OpenDraft.ODCore.ODEditor.ODDynamics;
using OpenDraft.ODCore.ODGeometry;
using System;
using System.Collections.Generic;
using System.Collections.ObjectModel;
using System.Diagnostics;
using System.Threading;
using System.Threading.Tasks;
namespace OpenDraft.ODCore.ODEditor
{
    public class ODEditor : IDisposable
    {
        private readonly ODDataManager _dataManager;
        private readonly ODCommandRegistry _commandRegistry;
        private readonly IODEditorInputService _inputService;
        private readonly ODSelectionManager _selectionManager;
        public ObservableCollection<ODDynamicElement> DynamicElements { get; } = new();
        private ODEditorContext? _currentContext;
        private IODEditorCommand? _currentCommand;
        public event EventHandler<MessageEventArgs>? ShowMessageRequested;
        public event EventHandler<MessageEventArgs>? StatusMessageChanged;
        ODCrosshairElement ch = new ODCrosshairElement();
        public ODEditor(ODDataManager dataManager, IODEditorInputService inputService)
        {
            _dataManager = dataManager;
            _inputService = inputService;
            _commandRegistry = new ODCommandRegistry();
            _commandRegistry.RegisterAssembly(typeof(ODEditor).Assembly);
            // Subscribe to input events
            _inputService.KeyPressed += OnKeyPressed;
            _inputService.CancelRequested += OnCancelRequested;
            // Subscribe to viewport focus events
            _inputService.ViewportEntered += OnViewportEntered;
            _inputService.ViewportExited += OnViewportExited;
            DynamicElements.Add(ch);
        }
        // Add event handlers
        private void OnViewportEntered()
        {
            ShowCrosshair();
        }
        private void OnViewportExited()
        {
            HideCrosshair();
        }
        /* DYNAMIC ELEMENTS MANAGEMENT */
        public void restoreDefaultDynamicElements()
        {
            DynamicElements.Clear();
            // Future: Add default dynamic elements if any <<<< TODO IMPLEMENT <<<<
            DynamicElements.Add(ch);
        }
        public void ClearDynamicElements()
        {
            DynamicElements.Clear();
            DynamicElements.Add(ch);
        }
        // ADD THIS: Method to add dynamic elements
        public void AddDynamicElement(ODDynamicElement element)
        {
            Debug.WriteLine("AddDynamicElement: " + element.GetType().Name);
            DynamicElements.Add(element);
        }
        // ADD THIS: Method to remove specific dynamic element
        public void RemoveDynamicElement(ODDynamicElement element)
        {
            DynamicElements.Remove(element);
        }
        public void AddStaticElement(ODElement element)
        {
            _dataManager.AddElement(element);
        }
        /* COMMAND EXECUTION AND INPUT HANDLING  */
        private void OnKeyPressed(Key key)
        {
            // Handle specific keys we care about
            switch (key)
            {
                case Key.Escape:
                    CancelCurrentCommand();
                    break;
                    // Future: handle Enter, Space, etc.
            }
        }
        private void OnCancelRequested()
        {
            CancelCurrentCommand();
        }
        public void CancelCurrentCommand()
        {
            restoreDefaultDynamicElements();
            _currentContext?.Cancel();
            _currentContext = null;
            _currentCommand = null;
            SetStatus("Command cancelled");
        }
        public void ExecuteCommand(string commandName)
        {
            Debug.WriteLine($"ExecuteCommand: {commandName}");
            CancelCurrentCommand();
            var command = _commandRegistry.CreateCommand(commandName);
            if (command == null)
            {
                SetStatus($"Unknown command: {commandName}");
                return;
            }
            _currentCommand = command;
            _currentContext = new ODEditorContext(this, _dataManager, _inputService);
            async Task RunCommandAsync()
            {
                try
                {
                    await command.ExecuteAsync(_currentContext);
                }
                catch (Exception ex)
                {
                    SetStatus($"Error in {commandName}: {ex.Message}");
                    Debug.WriteLine($"Command error: {ex.Message}");
                }
                finally
                {
                    if (_currentCommand == command)
                    {
                        CancelCurrentCommand();
                    }
                }
            }
            _ = RunCommandAsync();
        }
        public void SetStatus(string message)
        {
            Debug.WriteLine("SetStatus: " + message);
            Dispatcher.UIThread.Post(() =>
            {
                StatusMessageChanged?.Invoke(this, new MessageEventArgs(message));
            });
        }
        public void ShowMessage(string message)
        {
            Debug.WriteLine("ShowMessage: " + message);
            Dispatcher.UIThread.Post(() =>
            {
                ShowMessageRequested?.Invoke(this, new MessageEventArgs(message));
            });
        }
        public void Dispose()
        {
            _inputService.KeyPressed -= OnKeyPressed;
            _inputService.CancelRequested -= OnCancelRequested;
            CancelCurrentCommand();
        }
        public void HideCrosshair()
        {
            ch.IsVisible = false;
        }
        public void ShowCrosshair()
        {
            ch.IsVisible = true;
        }
    }
    public class MessageEventArgs : EventArgs
    {
        public string Message { get; }
        public MessageEventArgs(string message) => Message = message;
    }
    public class BoolEventArgs : EventArgs
    {
        public bool Value { get; }
        public BoolEventArgs(bool value) => Value = value;
    }
}

** ODEditorContext.cs **
Path: D:\OpenDraft\OpenDraft\ODCore\ODEditor\ODEditorContext.cs

ï»¿using OpenDraft.ODCore.ODData;
using OpenDraft.ODCore.ODEditor.ODCommands;
using OpenDraft.ODCore.ODEditor.ODDynamics;
using OpenDraft.ODCore.ODGeometry;
using OpenDraft.ODCore.ODMath;
using System;
using System.Numerics;
using System.Threading;
using System.Threading.Tasks;
namespace OpenDraft.ODCore.ODEditor
{
    public class ODEditorContext : IODEditorGateway
    {
        private readonly ODEditor _editor;
        private readonly ODDataManager _dataManager;
        private readonly IODEditorInputService _inputService;
        private readonly CancellationTokenSource _cancellationTokenSource;
        private TaskCompletionSource<ODVec2>? _pointWaiter;
        private TaskCompletionSource<double>? _numberWaiter;
        private TaskCompletionSource<string>? _textWaiter;
        private TaskCompletionSource<string>? _choiceWaiter;
        public ODDataManager DataManager => _dataManager;
        public CancellationToken CancellationToken => _cancellationTokenSource.Token;
        public ODEditorContext(ODEditor editor, ODDataManager dataManager, IODEditorInputService inputService)
        {
            _editor = editor;
            _dataManager = dataManager;
            _inputService = inputService;
            _cancellationTokenSource = new CancellationTokenSource();
            // Subscribe to input service events
            _inputService.PointProvided += OnPointProvided;
            _inputService.NumberInput += OnNumberProvided;
            _inputService.TextInput += OnTextProvided;
        }
        public void AddDynamicElement(ODDynamicElement element)
        {
            _editor.AddDynamicElement(element);
        }
        public void RemoveDynamicElement(ODDynamicElement element)
        {
            _editor.RemoveDynamicElement(element);
        }
        public void ClearDynamicElements()
        {
            _editor.ClearDynamicElements();
        }
        private void OnPointProvided(ODVec2 point)
        {
            ProvidePoint(point);
        }
        private void OnNumberProvided(double number)
        {
            ProvideNumber(number);
        }
        private void OnTextProvided(string text)
        {
            ProvideText(text);
        }
        public Task<ODVec2> GetPointAsync(string prompt)
        {
            _editor.SetStatus(prompt); // FIXED: Now calls editor method
            ClearAllWaiters();
            _pointWaiter = new TaskCompletionSource<ODVec2>();
            return _pointWaiter.Task;
        }
        public Task<double> GetNumberAsync(string prompt)
        {
            _editor.SetStatus(prompt); // FIXED
            ClearAllWaiters();
            _numberWaiter = new TaskCompletionSource<double>();
            return _numberWaiter.Task;
        }
        public Task<string> GetTextAsync(string prompt)
        {
            _editor.SetStatus(prompt); // FIXED
            ClearAllWaiters();
            _textWaiter = new TaskCompletionSource<string>();
            return _textWaiter.Task;
        }
        public async Task<(ODVec2 start, ODVec2 end)> GetLineAsync(string promptStart, string promptEnd)
        {
            var start = await GetPointAsync(promptStart);
            var end = await GetPointAsync(promptEnd);
            return (start, end);
        }
        public Task<string> GetChoiceAsync(string prompt, params string[] options)
        {
            _editor.SetStatus(prompt); // FIXED
            ClearAllWaiters();
            _choiceWaiter = new TaskCompletionSource<string>();
            return _choiceWaiter.Task;
        }
        public void ProvidePoint(ODVec2 point)
        {
            if (point == null)
                throw new ArgumentNullException(nameof(point));
            if (_pointWaiter != null && !_pointWaiter.Task.IsCompleted)
            {
                _pointWaiter.TrySetResult(point);
            }
        }
        public void ProvideNumber(double number)
        {
            if (_numberWaiter != null && !_numberWaiter.Task.IsCompleted)
            {
                _numberWaiter.TrySetResult(number);
            }
        }
        public void ProvideText(string text)
        {
            if (_textWaiter != null && !_textWaiter.Task.IsCompleted)
            {
                _textWaiter.TrySetResult(text);
            }
        }
        public void ProvideChoice(string choice)
        {
            if (_choiceWaiter != null && !_choiceWaiter.Task.IsCompleted)
            {
                _choiceWaiter.TrySetResult(choice);
            }
        }
        public void Cancel()
        {
            _cancellationTokenSource.Cancel();
            _inputService.PointProvided -= OnPointProvided;
            _inputService.NumberInput -= OnNumberProvided;
            _inputService.TextInput -= OnTextProvided;
            ClearAllWaiters();
        }
        private void ClearAllWaiters()
        {
            _pointWaiter = null;
            _numberWaiter = null;
            _textWaiter = null;
            _choiceWaiter = null;
        }
        public void SetStatus(string message)
        {
            _editor.SetStatus(message);
        }
        public void ShowMessage(string message)
        {
            _editor.ShowMessage(message);
        }
    }
}

** ODEditorInputService.cs **
Path: D:\OpenDraft\OpenDraft\ODCore\ODEditor\ODEditorInputService.cs

ï»¿// EditorInputService.cs
using Avalonia.Input;
using OpenDraft.ODCore.ODGeometry;
using OpenDraft.ODCore.ODMath;
using System;
namespace OpenDraft.ODCore.ODEditor
{
    public class ODEditorInputService : IODEditorInputService
    {
        public event Action<Key>? KeyPressed;
        public event Action<ODVec2>? PointProvided;
        public event Action<string>? TextInput;
        public event Action<double>? NumberInput;
        public event Action? CancelRequested;
        public event Action? ViewportEntered;
        public event Action? ViewportExited;
        public void RaiseKeyPressed(Key key)
        {
            KeyPressed?.Invoke(key);
        }
        public void RaisePointProvided(ODVec2 point)
        {
            PointProvided?.Invoke(point);
        }
        public void RaiseTextInput(string text)
        {
            TextInput?.Invoke(text);
        }
        public void RaiseNumberInput(double number)
        {
            NumberInput?.Invoke(number);
        }
        public void RaiseCancelRequested()
        {
            CancelRequested?.Invoke();
        }
        public void RaiseViewportEntered()
        {
            ViewportEntered?.Invoke();
        }
        public void RaiseViewportExited()
        {
            ViewportExited?.Invoke();
        }
        // These can be expanded later for more sophisticated input handling
        public void RequestPointInput() { /* Future: change cursor, show hints */ }
        public void RequestTextInput() { /* Future: focus text box */ }
        public void CancelInputRequest() { /* Future: reset cursor */ }
    }
}

** ODViewportCamera.cs **
Path: D:\OpenDraft\OpenDraft\ODCore\ODEditor\ODViewportCamera.cs

ï»¿using Avalonia;
public class ViewportCamera
{
    public Point Position { get; set; } = new Point(0, 0);
    public double Scale { get; set; } = 1.0f;
    public ViewportCamera(Point? position = null, float scale = 1.0f)
    {
        Position = position ?? new Point(0, 0);
        Scale = scale;
    }
    public void MoveBy(Vector delta) => Position += new Point(delta.X, delta.Y);
    public Matrix GetMatrix(double viewportHeight) =>
        new Matrix(Scale, 0, 0, -Scale, -Position.X * Scale, Position.Y * Scale + viewportHeight);
}

** IODEditorCommand.cs **
Path: D:\OpenDraft\OpenDraft\ODCore\ODEditor\ODCommands\IODEditorCommand.cs

ï»¿using System.Threading.Tasks;
namespace OpenDraft.ODCore.ODEditor.ODCommands
{
    public interface IODEditorCommand
    {
        string Name { get; }
        string Description { get; }
        Task ExecuteAsync(IODEditorGateway editor);
    }
}

** IODEditorGateway.cs **
Path: D:\OpenDraft\OpenDraft\ODCore\ODEditor\ODCommands\IODEditorGateway.cs

ï»¿using OpenDraft.ODCore.ODData;
using OpenDraft.ODCore.ODEditor.ODDynamics;
using OpenDraft.ODCore.ODGeometry;
using OpenDraft.ODCore.ODMath;
using System.Threading;
using System.Threading.Tasks;
namespace OpenDraft.ODCore.ODEditor.ODCommands
{
    public interface IODEditorGateway
    {
        ODDataManager DataManager { get; }
        Task<ODVec2> GetPointAsync(string prompt);
        Task<double> GetNumberAsync(string prompt);
        Task<string> GetTextAsync(string prompt);
        Task<string> GetChoiceAsync(string prompt, params string[] options);
        Task<(ODVec2 start, ODVec2 end)> GetLineAsync(string promptStart, string promptEnd);
        void SetStatus(string message);
        void ShowMessage(string message);
        void AddDynamicElement(ODDynamicElement element);
        void RemoveDynamicElement(ODDynamicElement element);
        void ClearDynamicElements();
        CancellationToken CancellationToken { get; }
    }
}

** ODBaseEditorCommand.cs **
Path: D:\OpenDraft\OpenDraft\ODCore\ODEditor\ODCommands\ODBaseEditorCommand.cs

ï»¿// ODBaseEditorCommand.cs
using OpenDraft.ODCore.ODGeometry;
using OpenDraft.ODCore.ODMath;
using System;
using System.Reflection;
using System.Threading.Tasks;
namespace OpenDraft.ODCore.ODEditor.ODCommands
{
    public abstract class ODBaseEditorCommand : IODEditorCommand
    {
        private readonly Lazy<ODCommandAttribute> _attribute;
        public string Name => _attribute.Value.Name;
        public string Description => _attribute.Value.Description;
        protected ODBaseEditorCommand()
        {
            _attribute = new Lazy<ODCommandAttribute>(() =>
            {
                var attribute = GetType().GetCustomAttribute<ODCommandAttribute>();
                if (attribute == null)
                {
                    throw new InvalidOperationException(
                        $"Command {GetType().Name} must be decorated with [ODCommand] attribute");
                }
                return attribute;
            });
        }
        public abstract Task ExecuteAsync(IODEditorGateway editor);
        // Helper method for common validation
        protected void ValidatePoint(ODVec2 point, string paramName)
        {
            if (point == null)
                throw new ArgumentNullException(paramName);
            if (double.IsNaN(point.X) || double.IsNaN(point.Y) ||
                double.IsInfinity(point.X) || double.IsInfinity(point.Y))
                throw new ArgumentException($"Invalid point coordinates: ({point.X}, {point.Y})", paramName);
        }
    }
}

** ODCircleCommand.cs **
Path: D:\OpenDraft\OpenDraft\ODCore\ODEditor\ODCommands\ODCircleCommand.cs

ï»¿// Example of using dynamic elements in a command
using OpenDraft.ODCore.ODData;
using OpenDraft.ODCore.ODEditor.ODCommands;
using OpenDraft.ODCore.ODEditor.ODDynamics;
using OpenDraft.ODCore.ODGeometry;
using OpenDraft.ODCore.ODSystem;
using OpenDraft.ODCore.ODMath;
using System.Threading.Tasks;
using System;
[ODCommand("CIRCLE", "Creates a circle", "C")]
public class ODCircleCommand : ODBaseEditorCommand
{
    public override async Task ExecuteAsync(IODEditorGateway editor)
    {
        ushort layId = editor.DataManager.LayerManager.GetActiveLayer();
        ODLayer lay = editor.DataManager.LayerManager.GetLayerByID(layId)!;
        ODVec2 center = await editor.GetPointAsync("Specify center point:");
        ODRubberBandLine rubberBand = new ODRubberBandLine(center);
        rubberBand.LineWeight = ODSystem.GetRegistryValueAsDecimal("style/draw_tool_line_weight");
        rubberBand.Colour = new ODColour(ODSystem.GetRegistryValueAsString("style/draw_tool_colour") ?? "#FFFFFF");
        rubberBand.LineType = ODSystem.GetRegistryValueAsString("style/draw_tool_line_type");
        editor.AddDynamicElement(rubberBand);
        ODRubberBandCircle rubberCircle = new ODRubberBandCircle(center);
        rubberCircle.LineWeight = lay.LineWeight;
        rubberCircle.Colour = lay.Color;
        rubberCircle.LineType = lay.LineType;
        editor.AddDynamicElement(rubberCircle);
        ODVec2 radPoint = await editor.GetPointAsync("Specify radius:");
        // TODO CHANGE POINTS TO VECTORS
        double radius = Math.Sqrt(
            Math.Pow(radPoint.X - center.X, 2) + Math.Pow(radPoint.Y - center.Y, 2)
            );
        var circle = new ODCircle(center, radius);
        editor.DataManager.AddElement(circle); // Use DataManager directly
        editor.SetStatus("Circle created successfully");
    }
}

** ODCommandRegistry.cs **
Path: D:\OpenDraft\OpenDraft\ODCore\ODEditor\ODCommands\ODCommandRegistry.cs

ï»¿// ODCommandRegistry.cs
using System;
using System.Collections.Generic;
using System.Linq;
using System.Reflection;
namespace OpenDraft.ODCore.ODEditor.ODCommands
{
    public class ODCommandRegistry
    {
        private readonly Dictionary<string, Type> _commands = new Dictionary<string, Type>(StringComparer.OrdinalIgnoreCase);
        public void RegisterAssembly(Assembly assembly)
        {
            var commandTypes = assembly.GetTypes()
                .Where(t => typeof(IODEditorCommand).IsAssignableFrom(t) && !t.IsAbstract)
                .Where(t => t.GetCustomAttribute<ODCommandAttribute>() != null);
            foreach (var type in commandTypes)
            {
                var attribute = type.GetCustomAttribute<ODCommandAttribute>();
                if (attribute != null)
                {
                    _commands[attribute.Name] = type;
                    foreach (var alias in attribute.Aliases)
                    {
                        _commands[alias] = type;
                    }
                }
            }
        }
        public void RegisterCommand<T>(string name, params string[] aliases) where T : IODEditorCommand
        {
            _commands[name] = typeof(T);
            foreach (var alias in aliases)
            {
                _commands[alias] = typeof(T);
            }
        }
        public IODEditorCommand? CreateCommand(string commandName)
        {
            if (_commands.TryGetValue(commandName, out var commandType))
            {
                var instance = Activator.CreateInstance(commandType);
                if (instance is IODEditorCommand command)
                {
                    return command;
                }
                return null;
            }
            return null;
        }
        public IEnumerable<string> GetRegisteredCommandNames()
        {
            return _commands.Keys.Distinct();
        }
        public string GetCommandDescription(string commandName)
        {
            if (_commands.TryGetValue(commandName, out var type))
            {
                var attribute = type.GetCustomAttribute<ODCommandAttribute>();
                return attribute?.Description ?? string.Empty;
            }
            return string.Empty;
        }
    }
}

** ODLineCommand.cs **
Path: D:\OpenDraft\OpenDraft\ODCore\ODEditor\ODCommands\ODLineCommand.cs

ï»¿// Example of using dynamic elements in a command
using OpenDraft.ODCore.ODData;
using OpenDraft.ODCore.ODEditor.ODCommands;
using OpenDraft.ODCore.ODEditor.ODDynamics;
using OpenDraft.ODCore.ODGeometry;
using OpenDraft.ODCore.ODMath;
using System.Threading.Tasks;
[ODCommand("LINE", "Creates a line", "L")]
public class ODLineCommand : ODBaseEditorCommand
{
    public override async Task ExecuteAsync(IODEditorGateway editor)
    {
        ODVec2 start = await editor.GetPointAsync("Specify start point:");
        ushort layId = editor.DataManager.LayerManager.GetActiveLayer();
        ODLayer lay = editor.DataManager.LayerManager.GetLayerByID(layId)!;
        ODRubberBandLine rubberBand = new ODRubberBandLine(start);
        rubberBand.LineWeight = lay.LineWeight;
        rubberBand.Colour = lay.Color;
        rubberBand.LineType = lay.LineType;
        editor.AddDynamicElement(rubberBand);
        ODVec2 end   = await editor.GetPointAsync("Specify end point:");
        var line = new ODLine(start, end);
        editor.DataManager.AddElement(line);
        editor.SetStatus("Line created successfully");
    }
}

** ODCrosshair.cs **
Path: D:\OpenDraft\OpenDraft\ODCore\ODEditor\ODDynamics\ODCrosshair.cs

ï»¿using Avalonia;
using Avalonia.Media;
using OpenDraft.ODCore.ODData;
using OpenDraft.ODCore.ODGeometry;
using OpenDraft.ODCore.ODSystem;
using OpenDraft.ODCore.ODMath;
using System;
namespace OpenDraft.ODCore.ODEditor.ODDynamics
{
    public class ODCrosshairElement : ODDynamicElement
    {
        // Visibility
        public bool IsVisible { get; set; } = true;
        // Style properties
        private int _size = 10;
        public int Size
        {
            get => _size;
            set => _size = value;
        }
        public ODCrosshairElement()
        {
        }
        public override void Draw(DrawingContext context, ODDrawConnector connector,
            double scale, ODVec2 vpWorldSize, ODVec2 worldMousePosition)
        {
            if (!IsVisible)
                return;
            ODLayer? layer = connector.GetLayerByID(LayerId);
            // Get layer
            ODVec2 Center = worldMousePosition;
            double cSize = Size / scale; // Centre square size
            // Get styles from registry
            Color xColour = Avalonia.Media.Color.Parse(ODSystem.ODSystem.GetRegistryValueAsString("style/crosshair_x_colour") ?? "Red");
            Color yColour = Avalonia.Media.Color.Parse(ODSystem.ODSystem.GetRegistryValueAsString("style/crosshair_y_colour") ?? "Lime");
            Color sqColour = Avalonia.Media.Color.Parse(ODSystem.ODSystem.GetRegistryValueAsString("style/crosshair_sq_colour") ?? "White");
            float xThickness = ODSystem.ODSystem.GetRegistryValueAsDecimal("style/crosshair_line_weight") ?? 1;
            Pen xPen = new Pen(new SolidColorBrush(xColour), xThickness / scale);
            Pen yPen = new Pen(new SolidColorBrush(yColour), xThickness / scale);
            Pen sqPen = new Pen(new SolidColorBrush(sqColour), xThickness / scale);
            // Centre square
            context.DrawRectangle(null, sqPen,
                new Rect(
                    new Point(Center.X - cSize / 2, Center.Y - cSize / 2),
                    new Size(cSize, cSize)
                ));
            var top = new Point(Center.X, Center.Y + vpWorldSize.Y);
            var bottom = new Point(Center.X, Center.Y - vpWorldSize.Y);
            var left = new Point(Center.X - vpWorldSize.X, Center.Y);
            var right = new Point(Center.X + vpWorldSize.X, Center.Y);
            context.DrawLine(yPen, top, new Point(Center.X, Center.Y + cSize / 2)); // Top
            context.DrawLine(xPen, left, new Point(Center.X - cSize / 2, Center.Y)); // Left
            context.DrawLine(yPen, new Point(Center.X, Center.Y - cSize / 2), bottom); // Bottom
            context.DrawLine(xPen, new Point(Center.X + cSize / 2, Center.Y), right); // Right
        }
    }
}


** ODDynamicElement.cs **
Path: D:\OpenDraft\OpenDraft\ODCore\ODEditor\ODDynamics\ODDynamicElement.cs

ï»¿using Avalonia;
using Avalonia.Media;
using OpenDraft.ODCore.ODData;
using OpenDraft.ODCore.ODGeometry;
using OpenDraft.ODCore.ODMath;
using System;
namespace OpenDraft.ODCore.ODEditor.ODDynamics
{
    public class ODDynamicElement
    {
        public Guid Id { get; set; }
        public ODColour? Colour { get; set; } = null; // If null, use layer colour
        public double? LineWeight { get; set; } = 2.0f; // If null, use layer line weight
        public string? LineType { get; set; } = null; // If null, use layer line type
        public ushort LayerId { get; set; } = 0; // Default layer ID
        public ODDynamicElement()
        {
            Id = Guid.NewGuid();
        }
        public virtual void Draw(DrawingContext context, ODDrawConnector connector, 
            double scale, ODVec2 vpWorldSize, ODVec2 mousePosition)
        {
            // Base draw method, to be overridden by derived classes
        }
    }
}


** ODRubberBandCircle.cs **
Path: D:\OpenDraft\OpenDraft\ODCore\ODEditor\ODDynamics\ODRubberBandCircle.cs

ï»¿using Avalonia;
using Avalonia.Media;
using OpenDraft.ODCore.ODData;
using OpenDraft.ODCore.ODGeometry;
using OpenDraft.ODCore.ODMath;
using System;
using System.Diagnostics;
using System.Net;
namespace OpenDraft.ODCore.ODEditor.ODDynamics
{
    public class ODRubberBandCircle : ODDynamicElement
    {
        public ODVec2 Start { get; set; }
        public float Weight { get; set; } = 1.0f;
        public ODRubberBandCircle(ODVec2 start)
        {
            Start = start;
        }
        public override void Draw(DrawingContext context, ODDrawConnector connector,
            double scale, ODVec2 vpWorldSize, ODVec2 mousePosition)
        {
            ODLayer? layer = connector.GetLayerByID(LayerId);
            if (layer == null || !layer.IsVisible || layer.Color == null)
                return;
            // Get dash style from registry
            IDashStyle dashStyle = connector.ToAvaloniaDashStyle(LineType ?? layer.LineType);
            string effectiveColour = (Colour != null) ? Colour.ToHex() : layer.Color.ToHex();
            double effectiveLineWeight = LineWeight ?? layer.LineWeight;
            // Create pen
            Pen pen = new Pen(
                new SolidColorBrush(Color.Parse(effectiveColour)), // Brush only
                effectiveLineWeight,                               // Thickness
                dashStyle                                          // Dash style
            );
            double radius = Math.Sqrt(
                Math.Pow(mousePosition.X - Start.X, 2) + Math.Pow(mousePosition.Y - Start.Y, 2)
                );
            context.DrawEllipse(null, pen,
                new Point(Start.X, Start.Y),
                Math.Abs(radius),
                Math.Abs(radius));
        }
    }
}


** ODRubberBandLine.cs **
Path: D:\OpenDraft\OpenDraft\ODCore\ODEditor\ODDynamics\ODRubberBandLine.cs

ï»¿using Avalonia;
using Avalonia.Media;
using OpenDraft.ODCore.ODData;
using OpenDraft.ODCore.ODGeometry;
using OpenDraft.ODCore.ODMath;
using System;
namespace OpenDraft.ODCore.ODEditor.ODDynamics
{
    public class ODRubberBandLine : ODDynamicElement
    {
        public ODVec2 Start { get; set; }
        public ODRubberBandLine(ODVec2 start)
        {
            Start = start;
        }
        public override void Draw(DrawingContext context, ODDrawConnector connector,
            double scale, ODVec2 vpWorldSize, ODVec2 mousePosition)
        {
            ODLayer? layer = connector.GetLayerByID(LayerId);
            if (layer == null || !layer.IsVisible || layer.Color == null)
                return;
            // Get dash style from registry
            IDashStyle dashStyle = connector.ToAvaloniaDashStyle(LineType ?? layer.LineType);
            string effectiveColour = (Colour != null) ? Colour.ToHex() : layer.Color.ToHex();
            double effectiveLineWeight = LineWeight ?? layer.LineWeight;
            // Create pen
            Pen pen = new Pen(
                new SolidColorBrush(Color.Parse(effectiveColour)), // Brush only
                effectiveLineWeight,                               // Thickness
                dashStyle                                          // Dash style
            );
            context.DrawLine(pen, new Point(Start.X, Start.Y), new Point(mousePosition.X, mousePosition.Y));
        }
    }
}


** ODSnapIndicatorElement.cs **
Path: D:\OpenDraft\OpenDraft\ODCore\ODEditor\ODDynamics\ODSnapIndicatorElement.cs

ï»¿using Avalonia;
using Avalonia.Media;
using OpenDraft.ODCore.ODData;
using OpenDraft.ODCore.ODGeometry;
using OpenDraft.ODCore.ODMath;
using System;
namespace OpenDraft.ODCore.ODEditor.ODDynamics
{
    public class SnapIndicatorElement : ODDynamicElement
    {
        public ODVec2 Position { get; set; }
        public double Radius { get; set; } = 5.0;
        public SnapIndicatorElement(ODVec2 position)
        {
            Position = position;
        }
        public override void Draw(DrawingContext context, ODDrawConnector connector, 
            double scale, ODVec2 vpExtents, ODVec2 worldMousePosition)
        {
            var brush = new SolidColorBrush(Colors.Yellow);
            var pen = new Pen(brush, 1.5);
            context.DrawEllipse(null, pen,
                new Point(Position.X, Position.Y),
                Radius, Radius);
        }
    }
}


** ODCircle.cs **
Path: D:\OpenDraft\OpenDraft\ODCore\ODGeometry\ODCircle.cs

ï»¿using Avalonia;
using Avalonia.Media;
using OpenDraft.ODCore.ODData;
using OpenDraft.ODCore.ODEditor;
using OpenDraft.ODCore.ODMath;
using System;
using System.Net;
namespace OpenDraft.ODCore.ODGeometry
{
    internal class ODCircle : ODElement
    {
        public ODVec2 Center { get; set; }
        public double Radius { get; set; }
        public ODCircle(ODVec2 center, double radius)
        {
            Center = center;
            Radius = radius;
        }
        public override void Draw(DrawingContext context, ODDrawConnector connector)
        {
            ODLayer? layer = connector.GetLayerByID(LayerId);
            if (layer != null && !layer.IsVisible)
                return;
            if (layer == null)
                return;
            // Get dash style from registry
            var dashStyle = connector.ToAvaloniaDashStyle(LineType ?? layer.LineType);
            ODColour effectiveColour = (Colour != null) ? Colour : layer.Color;
            double effectiveLineWeight = LineWeight ?? layer.LineWeight;
            // Create pen
            var pen = new Pen(
                new SolidColorBrush(effectiveColour.ToAvaloniaColor()), // Brush only
                effectiveLineWeight,                                    // Thickness
                dashStyle                                               // Dash style
            );
            context.DrawEllipse(null, pen, new Point(Center.X, Center.Y), Radius, Radius);
            var bbpen = new Pen(new SolidColorBrush(Colors.Yellow, 1));
            ODBoundingBox bb = GetBoundingBox();
            var rect = new Rect(bb.GetOrigin.X,
                                bb.GetOrigin.Y,
                                bb.Width,
                                bb.Height);
            context.DrawRectangle(bbpen, rect);
        }
        public override void DrawHighlight(DrawingContext context, ODDrawConnector connector, int intensity)
        {
        }
        public override ODBoundingBox GetBoundingBox()
        {
            double minX = Center.X - Radius;
            double minY = Center.Y - Radius;
            double maxX = Center.X + Radius;
            double maxY = Center.Y + Radius;
            return ODBoundingBox.CreateFromMinMax(new ODVec2(minX, minY), new ODVec2(maxX, maxY));
        }
        public override bool HitTest(ODVec2 point)
        {
            return false;
        }
    }
}


** ODElement.cs **
Path: D:\OpenDraft\OpenDraft\ODCore\ODGeometry\ODElement.cs

ï»¿using Avalonia;
using Avalonia.Media;
using OpenDraft.ODCore.ODData;
using OpenDraft.ODCore.ODEditor;
using OpenDraft.ODCore.ODMath;
using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading.Tasks;
namespace OpenDraft.ODCore.ODGeometry
{
    public abstract class ODElement
    {
        public Guid Id { get; set; }
        public ushort LayerId { get; set; } = 0; // Default layer ID
        public ODColour? Colour { get; set; } = null; // If null, use layer colour
        public double? LineWeight { get; set; } = null; // If null, use layer lineweight
        public string? LineType { get; set; } = null; // If null, use layer linetype
        public ODElement()
        {
            Id = Guid.NewGuid();
        }
        public abstract void Draw(DrawingContext context, ODDrawConnector connector);
        public abstract void DrawHighlight(DrawingContext context, ODDrawConnector connector, int Intensity);
        public abstract ODBoundingBox GetBoundingBox();
        public abstract bool HitTest(ODVec2 point);
        public bool isPointInsideBoundingBox(ODVec2 point)
        {
            ODBoundingBox bb = GetBoundingBox();
            if (point.X >= bb.Left.X && point.X <= bb.Right && point.Y >= bb.Bottom && point.Y <= bb.Top)
                return true;
            return false;
        }
    }
}


** ODLine.cs **
Path: D:\OpenDraft\OpenDraft\ODCore\ODGeometry\ODLine.cs

ï»¿using Avalonia;
using Avalonia.Media;
using Microsoft.Win32;
using OpenDraft.ODCore.ODData;
using OpenDraft.ODCore.ODEditor;
using OpenDraft.ODCore.ODMath;
using System;
namespace OpenDraft.ODCore.ODGeometry
{
    internal class ODLine : ODElement
    {
        public ODVec2 StartPoint { get; set; }
        public ODVec2 EndPoint { get; set; }
        public ODLine(ODVec2 startPoint, ODVec2 endPoint)
        {
            StartPoint = startPoint;
            EndPoint = endPoint;
        }
        public override void Draw(DrawingContext context, ODDrawConnector connector)
        {
            ODLayer? layer = connector.GetLayerByID(LayerId);
            if (layer != null && !layer.IsVisible)
                return;
            if (layer == null)
                return;
            // Get dash style from registry
            IDashStyle dashStyle = connector.ToAvaloniaDashStyle(LineType ?? layer.LineType);
            ODColour effectiveColour = (Colour != null) ? Colour : layer.Color;
            double effectiveLineWeight = LineWeight ?? layer.LineWeight;
            // Create pen
            var pen = new Pen(
                new SolidColorBrush(effectiveColour.ToAvaloniaColor()), // Brush only
                effectiveLineWeight,                                    // Thickness
                dashStyle                                               // Dash style
            );
            context.DrawLine(pen,
                    new Point(StartPoint.X, StartPoint.Y),
                    new Point(EndPoint.X, EndPoint.Y));
            var bbpen = new Pen(new SolidColorBrush(Colors.Yellow, 1));
            ODBoundingBox bb = GetBoundingBox();
            var rect = new Rect(bb.GetOrigin.X,
                                bb.GetOrigin.Y,
                                bb.Width,
                                bb.Height);
            context.DrawRectangle(bbpen, rect);
        }
        public override void DrawHighlight(DrawingContext context, ODDrawConnector connector, int intensity)
        {
            // Create pen
            var brsh = new SolidColorBrush(Color.FromArgb(0, 0, 255, 255)); // 128 = 50% alpha
            var pen = new Pen(new SolidColorBrush(Colors.Yellow, 1));            
            context.DrawLine(pen,
                    new Point(StartPoint.X, StartPoint.Y),
                    new Point(EndPoint.X, EndPoint.Y));
        }
        public override ODBoundingBox GetBoundingBox()
        {
            double minX = Math.Min(StartPoint.X, EndPoint.X);
            double minY = Math.Min(StartPoint.Y, EndPoint.Y);
            double maxX = Math.Max(StartPoint.X, EndPoint.X);
            double maxY = Math.Max(StartPoint.Y, EndPoint.Y);
            return ODBoundingBox.CreateFromMinMax(new ODVec2(minX, minY), new ODVec2(maxX, maxY));
        }
        public override bool HitTest(ODVec2 point)
        {
            return isPointInsideBoundingBox(point);
        }
    }
}


** ODPoint.cs **
Path: D:\OpenDraft\OpenDraft\ODCore\ODGeometry\ODPoint.cs

ï»¿using Avalonia.Media;
using OpenDraft.ODCore.ODData;
using OpenDraft.ODCore.ODEditor;
using OpenDraft.ODCore.ODMath;
using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading.Tasks;
namespace OpenDraft.ODCore.ODGeometry
{
    public class ODPoint : ODElement
    {
        public double X { get; set; }
        public double Y { get; set; }
        public ODPoint(double x, double y)
        {
            X = x;
            Y = y;
        }
        public ODPoint(float x, float y)
        {
            X = x;
            Y = y;
        }
        public override void Draw(DrawingContext context, ODDrawConnector connector)
        {
            // To Do
        }
        public override void DrawHighlight(DrawingContext context, ODDrawConnector connector, int intensity)
        {
        }
        public override ODBoundingBox GetBoundingBox()
        {
            return new ODBoundingBox(new ODVec2(0, 0), new ODVec2(0, 0));
        }
        public override bool HitTest(ODVec2 point)
        {
            return false;
        }
    }
}


** ODPolyline.cs **
Path: D:\OpenDraft\OpenDraft\ODCore\ODGeometry\ODPolyline.cs

ï»¿using Avalonia;
using Avalonia.Media;
using Microsoft.Win32;
using OpenDraft.ODCore.ODData;
using System;
using System.Collections.Generic;
using OpenDraft.ODCore.ODMath;
using System.Linq;
using OpenDraft.ODCore.ODEditor;
namespace OpenDraft.ODCore.ODGeometry
{
    public class ODPolyline : ODElement
    {
        public List<ODVec2> Points { get; set; }
        public ODPolyline(List<ODVec2> points)
        {
            Points = points ?? new List<ODVec2>();
        }
        public override void Draw(DrawingContext context, ODDrawConnector connector)
        {
            ODLayer? layer = connector.GetLayerByID(LayerId);
            if (layer != null && !layer.IsVisible)
                return;
            if (layer == null)
                return;
            if (Points == null || Points.Count < 2)
                return;
            // Get dash style from registry
            var dashStyle = connector.ToAvaloniaDashStyle(LineType ?? layer.LineType);
            ODColour effectiveColour = (Colour != null) ? Colour : layer.Color;
            double effectiveLineWeight = LineWeight ?? layer.LineWeight;
            // Create pen
            var pen = new Pen(
                new SolidColorBrush(effectiveColour.ToAvaloniaColor()), // Brush only
                effectiveLineWeight,                                    // Thickness
                dashStyle                                               // Dash style
            );
            // Draw each segment individually
            for (int i = 1; i < Points.Count; i++)
            {
                context.DrawLine(pen,
                    new Point(Points[i - 1].X, Points[i - 1].Y),
                    new Point(Points[i].X, Points[i].Y));
            }
        }
        public override void DrawHighlight(DrawingContext context, ODDrawConnector connector, int intensity)
        {
        }
        public bool IsClosed => Points.Count > 2 && Points[0].Equals(Points[Points.Count - 1]);
        public double Length
        {
            get
            {
                if (Points.Count < 2) return 0;
                double length = 0;
                for (int i = 1; i < Points.Count; i++)
                {
                    length += Math.Sqrt(
                        Math.Pow(Points[i].X - Points[i - 1].X, 2) +
                        Math.Pow(Points[i].Y - Points[i - 1].Y, 2));
                }
                return length;
            }
        }
        public ODVec2 StartPoint => Points?.FirstOrDefault() ?? new ODVec2(0, 0);
        public ODVec2 EndPoint => Points?.LastOrDefault() ?? new ODVec2(0, 0);
        public void AddPoint(ODVec2 point)
        {
            Points.Add(point);
        }
        public void InsertPoint(int index, ODVec2 point)
        {
            if (index >= 0 && index <= Points.Count)
                Points.Insert(index, point);
        }
        public void RemovePoint(int index)
        {
            if (index >= 0 && index < Points.Count)
                Points.RemoveAt(index);
        }
        public override ODBoundingBox GetBoundingBox()
        {
            if (Points == null || Points.Count == 0)
                return new ODBoundingBox(new ODVec2(0, 0), new ODVec2(0, 0));
            double minX = Points.Min(p => p.X);
            double maxX = Points.Max(p => p.X);
            double minY = Points.Min(p => p.Y);
            double maxY = Points.Max(p => p.Y);
            return new ODBoundingBox(new ODVec2(minX, minY), new ODVec2(maxX, maxY));
        }
        public override bool HitTest(ODVec2 point)
        {
            return false;
        }
    }
}

** ODRectangle.cs **
Path: D:\OpenDraft\OpenDraft\ODCore\ODGeometry\ODRectangle.cs

ï»¿using Avalonia;
using Avalonia.Media;
using OpenDraft.ODCore.ODData;
using System;
using System.Collections.Generic;
using OpenDraft.ODCore.ODMath;
using System.Linq;
using System.Xml.Linq;
using OpenDraft.ODCore.ODEditor;
namespace OpenDraft.ODCore.ODGeometry
{
    public class ODRectangle : ODElement
    {
        public ODVec2 TopLeft { get; set; }
        public ODVec2 BottomRight { get; set; }
        public ODRectangle(ODVec2 topLeft, ODVec2 bottomRight)
        {
            TopLeft = topLeft;
            BottomRight = bottomRight;
        }
        // Alternative constructor from center point and dimensions
        public ODRectangle(ODVec2 center, double width, double height)
        {
            double halfWidth = width / 2;
            double halfHeight = height / 2;
            TopLeft = new ODVec2(center.X - halfWidth, center.Y - halfHeight);
            BottomRight = new ODVec2(center.X + halfWidth, center.Y + halfHeight);
        }
        // Alternative constructor from corner point and dimensions
        public ODRectangle(ODVec2 corner, double width, double height, bool isTopLeft = true)
        {
            if (isTopLeft)
            {
                TopLeft = corner;
                BottomRight = new ODVec2(corner.X + width, corner.Y + height);
            }
            else
            {
                BottomRight = corner;
                TopLeft = new ODVec2(corner.X - width, corner.Y - height);
            }
        }
        public override void Draw(DrawingContext context, ODDrawConnector connector)
        {
            ODLayer? layer = connector.GetLayerByID(LayerId);
            if (layer != null && !layer.IsVisible)
                return;
            if (layer == null)
                return;
            // Get dash style from registry
            var dashStyle = connector.ToAvaloniaDashStyle(LineType ?? layer.LineType);
            ODColour effectiveColour = (Colour != null) ? Colour : layer.Color;
            double effectiveLineWeight = LineWeight ?? layer.LineWeight;
            // Create pen
            var pen = new Pen(
                new SolidColorBrush(effectiveColour.ToAvaloniaColor()), // Brush only
                effectiveLineWeight,                                    // Thickness
                dashStyle                                               // Dash style
            );
            // Create rectangle geometry
            Rect rect = new Rect(
                new Point(TopLeft.X, TopLeft.Y),
                new Point(BottomRight.X, BottomRight.Y)
            );
            // Draw the rectangle
            context.DrawRectangle(pen, rect);
        }
        public override void DrawHighlight(DrawingContext context, ODDrawConnector connector, int intensity)
        {
        }
        // Properties for convenience
        public double X => TopLeft.X;
        public double Y => TopLeft.Y;
        public double Width => Math.Abs(BottomRight.X - TopLeft.X);
        public double Height => Math.Abs(BottomRight.Y - TopLeft.Y);
        public ODVec2 TopRight => new ODVec2(BottomRight.X, TopLeft.Y);
        public ODVec2 BottomLeft => new ODVec2(TopLeft.X, BottomRight.Y);
        public ODVec2 Center => new ODVec2(
            (TopLeft.X + BottomRight.X) / 2,
            (TopLeft.Y + BottomRight.Y) / 2
        );
        public double Area => Width * Height;
        public double Perimeter => 2 * (Width + Height);
        // Method to check if a point is inside the rectangle
        public bool ContainsPoint(ODVec2 point)
        {
            var minX = Math.Min(TopLeft.X, BottomRight.X);
            var maxX = Math.Max(TopLeft.X, BottomRight.X);
            var minY = Math.Min(TopLeft.Y, BottomRight.Y);
            var maxY = Math.Max(TopLeft.Y, BottomRight.Y);
            return point.X >= minX && point.X <= maxX &&
                   point.Y >= minY && point.Y <= maxY;
        }
        // Convert to polyline (useful for some operations)
        public ODPolyline ToPolyline()
        {
            var points = new List<ODVec2>
            {
                TopLeft,
                TopRight,
                BottomRight,
                BottomLeft,
                TopLeft // Close the rectangle
            };
            return new ODPolyline(points);
        }
        // Get bounding box (for compatibility with other geometry)
        public override ODBoundingBox GetBoundingBox()
        {
            // Calculate the actual min/max points
            double minX = Math.Min(TopLeft.X, BottomRight.X);
            double minY = Math.Min(TopLeft.Y, BottomRight.Y);
            double maxX = Math.Max(TopLeft.X, BottomRight.X);
            double maxY = Math.Max(TopLeft.Y, BottomRight.Y);
            return ODBoundingBox.CreateFromMinMax(new ODVec2(minX, minY), new ODVec2(maxX, maxY));
        }
        public override bool HitTest(ODVec2 point)
        {
            return false;
        }
        // SVG export support
        public XElement ToSvgElement(ODLayer layer, ODLineStyleRegistry registry)
        {
            var element = new XElement("{http://www.w3.org/2000/svg}rect",
                new XAttribute("x", TopLeft.X),
                new XAttribute("y", TopLeft.Y),
                new XAttribute("width", Width),
                new XAttribute("height", Height),
                new XAttribute("fill", "none") // No fill by default
            );
            return element;
        }
        public override string ToString()
        {
            return $"Rectangle [({X:0.##}, {Y:0.##}) {Width:0.##}x{Height:0.##}]";
        }
    }
}

** ODSymbol.cs **
Path: D:\OpenDraft\OpenDraft\ODCore\ODGeometry\ODSymbol.cs

ï»¿using Avalonia;
using Avalonia.Media;
using OpenDraft.ODCore.ODData;
using OpenDraft.ODCore.ODEditor;
using OpenDraft.ODCore.ODMath;
using System;
namespace OpenDraft.ODCore.ODGeometry
{
    public class ODSymbol : ODElement
    {
        public string SymbolName { get; set; }
        public ODVec2 InsertionPoint { get; set; }
        public double Rotation { get; set; }
        public double Scale { get; set; } = 1.0;
        public ODSymbol(string symbolName, ODVec2 insertionPoint)
        {
            SymbolName = symbolName;
            InsertionPoint = insertionPoint;
        }
        private Matrix CreateSymbolMatrix()
        {
            // Start with identity matrix
            var matrix = Matrix.Identity;
            // Apply scaling
            if (Scale != 1.0)
            {
                matrix = matrix * Matrix.CreateScale(Scale, Scale);
            }
            // Apply rotation (convert degrees to radians)
            if (Rotation != 0.0)
            {
                double radians = Rotation * Math.PI / 180.0;
                matrix = matrix * Matrix.CreateRotation(radians);
            }
            // Apply translation
            matrix = matrix * Matrix.CreateTranslation(new Vector(InsertionPoint.X, InsertionPoint.Y));
            return matrix;
        }
        public override void Draw(DrawingContext context, ODDrawConnector connector)
        {
            ODLayer? layer = connector.GetLayerByID(LayerId);
            if (layer != null && !layer.IsVisible)
                return;
            if (layer == null)
                return;
            // Get dash style from registry
            var dashStyle = connector.ToAvaloniaDashStyle(LineType ?? layer.LineType);
            ODColour effectiveColour = (Colour != null) ? Colour : layer.Color;
            double effectiveLineWeight = LineWeight ?? layer.LineWeight;
            // Create pen
            var pen = new Pen(
                new SolidColorBrush(effectiveColour.ToAvaloniaColor()), // Brush only
                effectiveLineWeight,                                    // Thickness
                dashStyle                                               // Dash style
            );
            ODSymbolDefinition? symbolDefition = connector.GetSymbolDefinition(SymbolName);
            if (symbolDefition == null)
                return;
            using (context.PushTransform(CreateSymbolMatrix()))
            {
                foreach (ODElement element in symbolDefition.Elements)
                {
                    element.Draw(context, connector);
                }
            }
        }
        public override void DrawHighlight(DrawingContext context, ODDrawConnector connector, int intensity)
        {
        }
        public override ODBoundingBox GetBoundingBox()
        {
            return new ODBoundingBox(new ODVec2(0, 0), new ODVec2(0, 0));
        }
        public override bool HitTest(ODVec2 point)
        {
            return false;
        }
    }
}

** ODSymbolDefinition.cs **
Path: D:\OpenDraft\OpenDraft\ODCore\ODGeometry\ODSymbolDefinition.cs

ï»¿using Avalonia.Media;
using OpenDraft.ODCore.ODEditor;
using OpenDraft.ODCore.ODGeometry;
using OpenDraft.ODCore.ODMath;
using System.Collections.Generic;
namespace OpenDraft.ODCore.ODGeometry
{
    public class ODSymbolDefinition
    {
        public string Name { get; set; }
        public List<ODElement> Elements { get; set; } = new List<ODElement>();
        public ODSymbolDefinition(string name)
        {
            Name = name;
        }
    }
}

** ODMath.cs **
Path: D:\OpenDraft\OpenDraft\ODCore\ODMath\ODMath.cs

ï»¿using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading.Tasks;
namespace OpenDraft.ODCore.ODMath
{
    public class ODVec2
        {
        public double X { get; set; }
        public double Y { get; set; }
        public ODVec2(double x, double y)
        {
            X = x;
            Y = y;
        }
        public static ODVec2 operator +(ODVec2 a, ODVec2 b)
        {
            return new ODVec2(a.X + b.X, a.Y + b.Y);
        }
        public static ODVec2 operator -(ODVec2 a, ODVec2 b)
        {
            return new ODVec2(a.X - b.X, a.Y - b.Y);
        }
        public static ODVec2 operator *(ODVec2 a, double scalar)
        {
            return new ODVec2(a.X * scalar, a.Y * scalar);
        }
        public static ODVec2 operator /(ODVec2 a, double scalar)
        {
            if (scalar == 0)
                throw new DivideByZeroException("Cannot divide by zero.");
            return new ODVec2(a.X / scalar, a.Y / scalar);
        }
        public double Magnitude()
        {
            return (double)Math.Sqrt(X * X + Y * Y);
        }
        public ODVec2 Normalize()
        {
            double magnitude = Magnitude();
            if (magnitude == 0)
                throw new InvalidOperationException("Cannot normalize a zero vector.");
            return this / magnitude;
        }
        public override string ToString()
        {
            return $"({X}, {Y})";
        }
    }
}


** ODSystem.cs **
Path: D:\OpenDraft\OpenDraft\ODCore\ODSystem\ODSystem.cs

ï»¿using System;
using System.Collections.Generic;
using System.Diagnostics;
using System.IO;
using System.Text.Json;
using System.Threading.Tasks;
namespace OpenDraft.ODCore.ODSystem
{
    public static class ODSystem
    {
        private static Dictionary<string, string> _dictionary = new Dictionary<string, string>();
        public static void Initialise()
        {
            LoadRegistry();
        }
        private static void LoadRegistry()
        {
            _dictionary.Clear();
            string registryPath = "config.json";
            if (File.Exists(registryPath))
            {
                string json = File.ReadAllText(registryPath);
                using var doc = JsonDocument.Parse(json);
                var flat = new Dictionary<string, string>();
                FlattenJson(doc.RootElement, "", flat);
                foreach (var kvp in flat)
                    _dictionary[kvp.Key] = kvp.Value;
            }
            Debug.WriteLine($"ODSystem registry loaded with {_dictionary.Count} entries.");
        }
        private static void FlattenJson(JsonElement element, string prefix, Dictionary<string, string> result)
        {
            switch (element.ValueKind)
            {
                case JsonValueKind.Object:
                    foreach (var prop in element.EnumerateObject())
                    {
                        string newPrefix = string.IsNullOrEmpty(prefix) ? prop.Name : $"{prefix}/{prop.Name}";
                        FlattenJson(prop.Value, newPrefix, result);
                    }
                    break;
                case JsonValueKind.Array:
                    foreach (var item in element.EnumerateArray())
                    {
                        // Donât append an index â treat array items as part of the same scope
                        FlattenJson(item, prefix, result);
                    }
                    break;
                default:
                    result[prefix] = element.ToString();
                    break;
            }
        }
        public static string? GetRegistryValueAsString(string key)
        {
            if (_dictionary.TryGetValue(key, out var value))
            {
                return value;
            }
            return null;
        }
        public static int? GetRegistryValueAsInt(string key)
        {
            if (_dictionary.TryGetValue(key, out var value))
            {
                if (int.TryParse(value, out var intValue))
                {
                    return intValue;
                }
            }
            return null;
        }
        public static bool? GetRegistryValueAsBool(string key)
        {
            if (_dictionary.TryGetValue(key, out var value))
            {
                if (bool.TryParse(value, out var boolValue))
                {
                    return boolValue;
                }
            }
            return null;
        }
        public static float ? GetRegistryValueAsDecimal(string key)
        {
            if (_dictionary.TryGetValue(key, out var value))
            {
                if (float.TryParse(value, out var floatValue))
                {
                    return floatValue;
                }
            }
            return null;
        }
        public static void SetRegistryValue(string key, string value)
        {
            _dictionary[key] = value;
            SaveRegistry();
        }
        private static void SaveRegistry()
        {
            // Save registry to file or other source
            // For example, write to a JSON file
            string registryPath = "config.json";
            var json = JsonSerializer.Serialize(_dictionary, new JsonSerializerOptions { WriteIndented = true });
            File.WriteAllText(registryPath, json);
            Debug.WriteLine("ODSystem registry saved with " + _dictionary.Count + " entries.");
        }
    }
}


** ODStyle.axaml **
Path: D:\OpenDraft\OpenDraft\Styles\ODStyle.axaml

<Styles xmlns="https://github.com/avaloniaui"
    xmlns:x="http://schemas.microsoft.com/winfx/2006/xaml">
	<Styles.Resources>
		<Color x:Key="BackgroundDark">#141415</Color>
		<Color x:Key="BackgroundLight">#1E2024</Color>
        <Color x:Key="PrimaryColor">#333</Color>
        <Color x:Key="AccentColor">#FF0000</Color>
		<SolidColorBrush x:Key="BackgroundDarkBrush" Color="{DynamicResource BackgroundDark}"/>
		<SolidColorBrush x:Key="BackgroundLightBrush" Color="{DynamicResource BackgroundLight}"/>
        <SolidColorBrush x:Key="PrimaryBrush" Color="{DynamicResource PrimaryColor}"/>
        <SolidColorBrush x:Key="AccentBrush" Color="{DynamicResource AccentColor}"/>
    </Styles.Resources>
	<Style Selector="Window">
		<Setter Property="FontSize" Value="12"/>
		<Setter Property="Background" Value="{DynamicResource BackgroundDarkBrush}"/>
	</Style>
	<Style Selector="Button">
		<Setter Property="Margin" Value="2"/>
		<Setter Property="Padding" Value="2"/>
		<Setter Property="Background" Value="#333"/>
		<Setter Property="CornerRadius" Value="1"/>
		<Setter Property="Height" Value="36"/>
	</Style>
	<Style Selector="Menu">
		<Setter Property="Background" Value="{DynamicResource BackgroundDarkBrush}"/>
		<Setter Property="Height" Value="22"/>
	</Style>
	<Style Selector="MenuItem">
		<Setter Property="Background" Value="Transparent"/>
		<Setter Property="Foreground" Value="#CCC"/>
		<Setter Property="CornerRadius" Value="4"/>
	</Style>
	<Style Selector="MenuItem:pointerover /template/ Border#PART_LayoutRoot">
		<Setter Property="Background" Value="#80FF0000"/>
	</Style>
	<Style Selector="StackPanel.toolbar">
		<Setter Property="Background" Value="{DynamicResource BackgroundLightBrush}"/>
		<Setter Property="Height" Value="40"/>
		<Setter Property="Orientation" Value="Horizontal"/>
	</Style>
	<Style Selector="StackPanel.statusbar">
		<Setter Property="Background" Value="{DynamicResource BackgroundLightBrush}"/>
		<Setter Property="Height" Value="32"/>
		<Setter Property="Orientation" Value="Horizontal"/>
	</Style>
	<Style Selector="StackPanel.toolbar > Button">
		<Setter Property="Background" Value="{DynamicResource BackgroundLightBrush}"/>
		<Setter Property="Width" Value="28"/>
		<Setter Property="Height" Value="28"/>
	</Style>
	<Style Selector="StackPanel.statusbar > Button">
		<Setter Property="Background" Value="Red"/>
		<Setter Property="Width" Value="28"/>
		<Setter Property="Height" Value="28"/>
	</Style>
</Styles>

** MainWindowViewModel.cs **
Path: D:\OpenDraft\OpenDraft\ViewModels\MainWindowViewModel.cs

ï»¿using CommunityToolkit.Mvvm.Input;
using OpenDraft.ODCore.ODData;
using OpenDraft.ODCore.ODEditor;
using OpenDraft.ODCore.ODGeometry;
using OpenDraft.ODCore.ODMath;
using OpenDraft.ODCore.ODSystem;
using OpenDraft.XSVG;
using System.Collections.Generic;
using System.Collections.ObjectModel;
using System.Diagnostics;
namespace OpenDraft.ViewModels
{
    public partial class MainWindowViewModel : ViewModelBase
    {
        public ODDataManager DataManagerRoot { get; }
        public IODEditorInputService InputService { get; }
        public ODEditor EditorRoot { get; private set; }
        public ODDrawConnector DrawConnectorRoot { get; }
        public ObservableCollection<ODElement> GeometryElements => DataManager.Elements;
        public ODDataManager DataManager => DataManagerRoot;
        public ODEditor Editor => EditorRoot;
        public ODSymbolTable SymbolTable { get; private set; }
        public ODDrawConnector DrawConnector => DrawConnectorRoot;
        public MainWindowViewModel()
        {
            ODSystem.Initialise();
            // Initialize the DataManager and Editor
            DataManagerRoot = new ODDataManager();
            InputService = new ODEditorInputService();
            EditorRoot = new ODEditor(DataManager, InputService);
            SymbolTable = new ODSymbolTable();
            DrawConnectorRoot = new ODDrawConnector(DataManager, Editor, SymbolTable);
            // Debug XSVG Reader
            /*ODXsvgReader xsvgR = new ODXsvgReader("XSVG/Example XSVG/example.xsvg");
            List<ODElement> xsvgElements = xsvgR.ExtractModelSpace();
            foreach (ODElement elem in xsvgElements)
            {
                Editor.AddStaticElement(elem);
            }*/
            /* Create test layer */
            DataManager.LayerManager.AddLayer("New Layer");
            ODLayer? lay = DataManager.LayerManager.GetLayerByName("New Layer");
            DataManager.LayerManager.SetActiveLayer("New Layer");
            lay!.Color = new ODColour("#00FF00");
            lay!.LineWeight = 2.0f;
            Debug.WriteLine("Setup complete");
            // Test Symbols
            ODSymbolDefinition symDef = new ODSymbolDefinition("MySymbol");
            ODLine L1 = new ODLine(new ODVec2(0, 0), new ODVec2(50, 50));
            ODLine L2 = new ODLine(new ODVec2(0, 50), new ODVec2(50, 0));
            symDef.Elements.Add(L1);
            symDef.Elements.Add(L2);
            SymbolTable.AddSymbol(symDef);
            ODSymbol S1 = new ODSymbol("MySymbol", new ODVec2(100, -10));
            ODSymbol S2 = new ODSymbol("MySymbol", new ODVec2(20, -10));
            DataManager.AddElement(S1);
            DataManager.AddElement(S2);
        }
        [RelayCommand]
        private void ExecuteEditor(string command)
        {
            EditorRoot.ExecuteCommand(command);
        }
    }
}

** ViewModelBase.cs **
Path: D:\OpenDraft\OpenDraft\ViewModels\ViewModelBase.cs

ï»¿using CommunityToolkit.Mvvm.ComponentModel;
namespace OpenDraft.ViewModels
{
    public class ViewModelBase : ObservableObject
    {
    }
}


** MainWindow.axaml **
Path: D:\OpenDraft\OpenDraft\Views\MainWindow.axaml

<Window xmlns="https://github.com/avaloniaui"
        xmlns:x="http://schemas.microsoft.com/winfx/2006/xaml"
        xmlns:vm="using:OpenDraft.ViewModels"
        xmlns:local="using:OpenDraft"
        xmlns:d="http://schemas.microsoft.com/expression/blend/2008"
        xmlns:mc="http://schemas.openxmlformats.org/markup-compatibility/2006"
        mc:Ignorable="d" d:DesignWidth="800" d:DesignHeight="450"
        x:Class="OpenDraft.Views.MainWindow"
        x:DataType="vm:MainWindowViewModel"
        Icon="/Assets/od-icon2.ico"
        Title="OpenDraft"
        Width="800"
        Height="400"
		MinWidth="800"
		MinHeight="400"
		>
  <!-- WindowState="Maximized"> -->
  <!-- Top Menu -->
  <Design.DataContext>
    <vm:MainWindowViewModel/>
  </Design.DataContext>
  <Grid>
    <Grid.RowDefinitions>
      <RowDefinition Height="Auto"/>      <!-- Menu strip -->
      <RowDefinition Height="Auto"/>      <!-- Toolbar -->
      <RowDefinition Height="*"/>         <!-- Viewport (fills space) -->
      <RowDefinition Height="Auto"/>      <!-- Status bar -->
    </Grid.RowDefinitions>
    <Menu Grid.Row="0" Height="22">
      <MenuItem Header="_File">
        <MenuItem Header="_New"/>
        <MenuItem Header="_Open"/>
        <MenuItem Header="_Save" />
        <MenuItem Header="Save _As" />
        <Separator/>
        <MenuItem Header="E_xit" />
      </MenuItem>
      <MenuItem Header="_Edit">
        <MenuItem Header="_Undo" />
        <MenuItem Header="_Redo" />
        <Separator/>
        <MenuItem Header="Cu_t" />
        <MenuItem Header="_Copy" />
        <MenuItem Header="_Paste" />
        <Separator/>
        <MenuItem Header="_Delete" />
        <Separator/>
        <MenuItem Header="Select _All" />
      </MenuItem>
      <MenuItem Header="_View">
        <MenuItem Header="Zoom _In" />
        <MenuItem Header="Zoom _Out" />
        <MenuItem Header="_Reset Zoom" />
        <Separator/>
        <MenuItem Header="_Grid Settings..." />
      </MenuItem>
      <MenuItem Header="_Help">
        <MenuItem Header="_About" />
      </MenuItem>
    </Menu>
    <!-- Toolbar -->
    <StackPanel
      Classes="toolbar"
      Grid.Row="1"
      HorizontalAlignment="Stretch"
      Orientation="Horizontal">
        <Button Content="Select" />
        <Button Content="Line" Command="{Binding ExecuteEditorCommand}" CommandParameter="LINE" />
        <Button Content="Circle" Command="{Binding ExecuteEditorCommand}" CommandParameter="CIRCLE" />
    </StackPanel>
    <!-- Use Grid.Row attached property -->
    <local:Viewport Grid.Row="2"
                    HorizontalAlignment="Stretch"
                    VerticalAlignment="Stretch"
                    Elements="{Binding GeometryElements}"
                    DynamicElements="{Binding Editor.DynamicElements}"
					DrawConnector="{Binding DrawConnectorRoot}"
                    InputService ="{Binding InputService}"/>
    <!-- Status Bar -->
    <StackPanel
      Classes="statusbar"
      Grid.Row="3"
      HorizontalAlignment="Stretch"
      Orientation="Horizontal">
      <Button Content="Select" />
      <Button Content="Line" />
      <Button Content="Circle" />
    </StackPanel>
  </Grid>
</Window>


** MainWindow.axaml.cs **
Path: D:\OpenDraft\OpenDraft\Views\MainWindow.axaml.cs

using Avalonia.Controls;
using Avalonia.Input;
using OpenDraft.ViewModels;
namespace OpenDraft.Views
{
    public partial class MainWindow : Window
    {
        public MainWindow()
        {
            InitializeComponent();
            // Subscribe to key events at window level
            AddHandler(KeyDownEvent, OnKeyDown, handledEventsToo: true);
        }
        private void OnKeyDown(object? sender, KeyEventArgs e)
        {
            if (DataContext is MainWindowViewModel vm)
            {
                // Route all keys to input service
                vm.InputService.RaiseKeyPressed(e.Key);
                // Special case: ESC also triggers cancel specifically
                if (e.Key == Key.Escape)
                {
                    vm.InputService.RaiseCancelRequested();
                    e.Handled = true;
                }
            }
        }
    }
}

** ODSvgReader.cs **
Path: D:\OpenDraft\OpenDraft\XSVG\ODSvgReader.cs

ï»¿using OpenDraft.ODCore.ODData;
using OpenDraft.ODCore.ODGeometry;
using OpenDraft.ODCore.ODMath;
using System;
using System.Collections.Generic;
using System.Diagnostics;
using System.Text;
using System.Xml.Linq;
namespace OpenDraft.XSVG
{
    internal struct ODSvgStyle
    {
        public ODColour StrokeColor;
        public ODColour FillColor;
        public double StrokeWidth;
        public string LineType;
        public string LayerName;
        public bool IsVisible;
        public bool IsLocked;
    }
    public class CADLayer
    {
        public string Id { get; set; }
        public string Name { get; set; }
        public ODColour Color { get; set; }
        public bool Visible { get; set; }
        public bool Locked { get; set; }
        public double LineWeight { get; set; }
        public string LineType { get; set; }
    }
    public class ODSvgReader
    {
        private string? _filePath;
        private XDocument? _xDocument;
        private XNamespace _ns = "http://www.w3.org/2000/svg";
        private XNamespace _cadNs = "http://your-cad-app.org/cad/1.0";
        private XNamespace _dcNs = "http://purl.org/dc/elements/1.1/";
        private Dictionary<string, CADLayer> _layers = new Dictionary<string, CADLayer>();
        private Dictionary<string, XElement> _blockDefinitions = new Dictionary<string, XElement>();
        private CADMetadata _metadata = new CADMetadata();
        public void LoadSvgFile(string filePath)
        {
            _filePath = filePath;
            if (!System.IO.File.Exists(filePath))
                throw new System.IO.FileNotFoundException("SVG file not found", filePath);
            string fileContentsRaw = System.IO.File.ReadAllText(filePath);
            _xDocument = XDocument.Parse(fileContentsRaw);
            // Parse CAD-specific metadata and definitions
            ParseCADMetadata();
            ParseLayerDefinitions();
            ParseBlockDefinitions();
        }
        #region CAD Metadata Parsing
        private void ParseCADMetadata()
        {
            if (_xDocument?.Root == null) return;
            // Parse root CAD attributes
            _metadata.AppVersion = _xDocument.Root.Attribute(_cadNs + "app-version")?.Value;
            _metadata.FileVersion = _xDocument.Root.Attribute(_cadNs + "file-version")?.Value;
            _metadata.Units = _xDocument.Root.Attribute(_cadNs + "units")?.Value;
            _metadata.Precision = ParseDouble(_xDocument.Root.Attribute(_cadNs + "precision")?.Value) ?? 0.001;
            // Parse metadata section
            var metadataElement = _xDocument.Root.Element("metadata");
            if (metadataElement != null)
            {
                _metadata.Application = metadataElement.Element(_cadNs + "application")?.Value;
                _metadata.Version = metadataElement.Element(_cadNs + "version")?.Value;
                _metadata.Created = ParseDateTime(metadataElement.Element(_cadNs + "created")?.Value);
                _metadata.Modified = ParseDateTime(metadataElement.Element(_cadNs + "modified")?.Value);
                // Parse Dublin Core metadata
                _metadata.Title = metadataElement.Element(_dcNs + "title")?.Value;
                _metadata.Creator = metadataElement.Element(_dcNs + "creator")?.Value;
                _metadata.Description = metadataElement.Element(_dcNs + "description")?.Value;
                // Parse custom properties
                var propertiesElement = metadataElement.Element(_cadNs + "properties");
                if (propertiesElement != null)
                {
                    _metadata.Properties = new Dictionary<string, string>();
                    foreach (var propElement in propertiesElement.Elements(_cadNs + "property"))
                    {
                        var name = propElement.Attribute("name")?.Value;
                        var value = propElement.Attribute("value")?.Value;
                        if (name != null)
                        {
                            _metadata.Properties[name] = value ?? string.Empty;
                        }
                    }
                }
            }
        }
        private void ParseLayerDefinitions()
        {
            var layersElement = _xDocument?.Root?
                .Element("defs")?
                .Element(_cadNs + "layers");
            if (layersElement == null) return;
            foreach (var layerElement in layersElement.Elements(_cadNs + "layer"))
            {
                var layer = new CADLayer
                {
                    Id = layerElement.Attribute("id")?.Value,
                    Name = layerElement.Attribute("name")?.Value,
                    Color = ParseColor(layerElement.Attribute("color")?.Value),
                    Visible = layerElement.Attribute("visible")?.Value == "true",
                    Locked = layerElement.Attribute("locked")?.Value == "true",
                    LineWeight = ParseDouble(layerElement.Attribute("lineweight")?.Value) ?? 0.25,
                    LineType = layerElement.Attribute("linetype")?.Value ?? "continuous"
                };
                if (layer.Id != null)
                {
                    _layers[layer.Id] = layer;
                }
            }
        }
        private void ParseBlockDefinitions()
        {
            var defsElement = _xDocument?.Root?.Element("defs");
            if (defsElement == null) return;
            foreach (var symbolElement in defsElement.Elements(_ns + "symbol"))
            {
                var id = symbolElement.Attribute("id")?.Value;
                if (id != null)
                {
                    _blockDefinitions[id] = symbolElement;
                }
            }
        }
        #endregion
        #region Geometry Import
        public List<ODElement> ImportGeometry()
        {
            if (_xDocument == null)
                throw new InvalidOperationException("No SVG file loaded. Call LoadSvgFile first.");
            var geometries = new List<ODElement>();
            var svgElement = _xDocument.Root;
            // Process groups (layers) first
            geometries.AddRange(ProcessGroups(svgElement));
            // Import individual elements not in groups
            geometries.AddRange(ImportPaths(svgElement));
            geometries.AddRange(ImportRectangles(svgElement));
            geometries.AddRange(ImportLines(svgElement));
            geometries.AddRange(ImportCircles(svgElement));
            geometries.AddRange(ImportBlockReferences(svgElement));
            Debug.WriteLine($"Imported {geometries.Count} geometry objects from {_layers.Count} layers");
            return geometries;
        }
        private List<ODElement> ProcessGroups(XElement parentElement)
        {
            var elements = new List<ODElement>();
            foreach (var groupElement in parentElement.Elements(_ns + "g"))
            {
                var layerId = groupElement.Attribute(_cadNs + "layer-id")?.Value;
                var style = ParseStyle(groupElement, layerId);
                // Process elements within the group
                elements.AddRange(ImportPaths(groupElement, style));
                elements.AddRange(ImportRectangles(groupElement, style));
                elements.AddRange(ImportLines(groupElement, style));
                elements.AddRange(ImportCircles(groupElement, style));
                elements.AddRange(ImportBlockReferences(groupElement, style));
                elements.AddRange(ProcessGroups(groupElement)); // Recursive for nested groups
            }
            return elements;
        }
        private List<ODElement> ImportBlockReferences(XElement parentElement, ODSvgStyle? parentStyle = null)
        {
            var blocks = new List<ODElement>();
            foreach (var useElement in parentElement.Descendants(_ns + "use"))
            {
                var href = useElement.Attribute(XNamespace.Get("http://www.w3.org/1999/xlink") + "href")?.Value;
                if (!string.IsNullOrEmpty(href) && href.StartsWith("#"))
                {
                    var blockId = href.Substring(1);
                    if (_blockDefinitions.TryGetValue(blockId, out var blockDefinition))
                    {
                        var style = ParseStyle(useElement, null, parentStyle);
                        var x = ParseDouble(useElement.Attribute("x")?.Value) ?? 0;
                        var y = ParseDouble(useElement.Attribute("y")?.Value) ?? 0;
                        // Parse transformation
                        var transform = useElement.Attribute("transform")?.Value;
                        var rotation = ParseDouble(useElement.Attribute(_cadNs + "rotation")?.Value) ?? 0;
                        var blockElements = ParseBlockDefinition(blockDefinition, x, y, rotation, style);
                        foreach (var element in blockElements)
                        {
                            ApplyCADMetadata(element, useElement);
                            blocks.Add(element);
                        }
                    }
                }
            }
            return blocks;
        }
        private List<ODElement> ParseBlockDefinition(XElement blockDefinition, double x, double y, double rotation, ODSvgStyle style)
        {
            var elements = new List<ODElement>();
            // Process paths in block definition
            foreach (var pathElement in blockDefinition.Descendants(_ns + "path"))
            {
                var pathData = pathElement.Attribute("d")?.Value;
                if (!string.IsNullOrEmpty(pathData))
                {
                    var path = ParsePathData(pathData, style);
                    if (path != null)
                    {
                        // Apply block transformation
                        ApplyTransformation(path, x, y, rotation);
                        elements.Add(path);
                    }
                }
            }
            // Process rectangles in block definition
            foreach (var rectElement in blockDefinition.Descendants(_ns + "rect"))
            {
                var rectX = ParseDouble(rectElement.Attribute("x")?.Value) ?? 0;
                var rectY = ParseDouble(rectElement.Attribute("y")?.Value) ?? 0;
                var width = ParseDouble(rectElement.Attribute("width")?.Value) ?? 0;
                var height = ParseDouble(rectElement.Attribute("height")?.Value) ?? 0;
                var rectangle = new ODRectangle(
                    new ODVec2(rectX + x, rectY + y),
                    new ODVec2(rectX + x + width, rectY + y + height)
                );
                ApplyTransformation(rectangle, x, y, rotation);
                elements.Add(rectangle);
            }
            return elements;
        }
        private void ApplyTransformation(ODElement element, double x, double y, double rotation)
        {
            // This is a simplified transformation - you'll need to implement
            // proper transformation logic based on your ODElement hierarchy
            if (element is ODPolyline polyline)
            {
                for (int i = 0; i < polyline.Points.Count; i++)
                {
                    var point = polyline.Points[i];
                    // Apply translation and rotation here
                    polyline.Points[i] = new ODVec2(point.X + x, point.Y + y);
                }
            }
            // Add similar logic for other element types
        }
        #endregion
        #region Original Geometry Import Methods (Preserved)
        private List<ODElement> ImportPaths(XElement parentElement, ODSvgStyle? parentStyle = null)
        {
            var paths = new List<ODElement>();
            foreach (var pathElement in parentElement.Descendants(_ns + "path"))
            {
                var pathData = pathElement.Attribute("d")?.Value;
                if (!string.IsNullOrEmpty(pathData))
                {
                    var style = ParseStyle(pathElement, null, parentStyle);
                    var path = ParsePathData(pathData, style);
                    if (path != null)
                    {
                        ApplyCADMetadata(path, pathElement);
                        paths.Add(path);
                    }
                }
            }
            return paths;
        }
        private List<ODElement> ImportRectangles(XElement parentElement, ODSvgStyle? parentStyle = null)
        {
            var rectangles = new List<ODElement>();
            foreach (var rectElement in parentElement.Descendants(_ns + "rect"))
            {
                var x = ParseDouble(rectElement.Attribute("x")?.Value) ?? 0;
                var y = ParseDouble(rectElement.Attribute("y")?.Value) ?? 0;
                var width = ParseDouble(rectElement.Attribute("width")?.Value) ?? 0;
                var height = ParseDouble(rectElement.Attribute("height")?.Value) ?? 0;
                if (width > 0 && height > 0)
                {
                    var style = ParseStyle(rectElement, null, parentStyle);
                    var rectangle = new ODRectangle(
                        new ODVec2(x, y),
                        new ODVec2(x + width, y + height)
                    );
                    ApplyCADMetadata(rectangle, rectElement);
                    rectangles.Add(rectangle);
                }
            }
            return rectangles;
        }
        private List<ODElement> ImportLines(XElement parentElement, ODSvgStyle? parentStyle = null)
        {
            var lines = new List<ODElement>();
            foreach (var lineElement in parentElement.Descendants(_ns + "line"))
            {
                var x1 = ParseDouble(lineElement.Attribute("x1")?.Value) ?? 0;
                var y1 = ParseDouble(lineElement.Attribute("y1")?.Value) ?? 0;
                var x2 = ParseDouble(lineElement.Attribute("x2")?.Value) ?? 0;
                var y2 = ParseDouble(lineElement.Attribute("y2")?.Value) ?? 0;
                var style = ParseStyle(lineElement, null, parentStyle);
                var line = new ODLine(
                    new ODVec2(x1, y1),
                    new ODVec2(x2, y2)
                );
                ApplyCADMetadata(line, lineElement);
                lines.Add(line);
            }
            return lines;
        }
        private List<ODElement> ImportCircles(XElement parentElement, ODSvgStyle? parentStyle = null)
        {
            var circles = new List<ODElement>();
            foreach (var circleElement in parentElement.Descendants(_ns + "circle"))
            {
                var cx = ParseDouble(circleElement.Attribute("cx")?.Value) ?? 0;
                var cy = ParseDouble(circleElement.Attribute("cy")?.Value) ?? 0;
                var r = ParseDouble(circleElement.Attribute("r")?.Value) ?? 0;
                if (r > 0)
                {
                    var style = ParseStyle(circleElement, null, parentStyle);
                    var circle = new ODCircle(
                        new ODVec2(cx, cy),
                        r
                    );
                    ApplyCADMetadata(circle, circleElement);
                    circles.Add(circle);
                }
            }
            return circles;
        }
        #endregion
        #region Path Data Parsing (Original Methods)
        private ODElement ParsePathData(string pathData, ODSvgStyle style)
        {
            try
            {
                var points = new List<ODVec2>();
                var tokens = TokenizePathData(pathData);
                double currentX = 0, currentY = 0;
                double startX = 0, startY = 0;
                bool hasValidData = false;
                for (int i = 0; i < tokens.Count; i++)
                {
                    var token = tokens[i];
                    var upperToken = token.ToUpper();
                    switch (upperToken)
                    {
                        case "M": // Move To
                            if (i + 2 < tokens.Count &&
                                TryParseDouble(tokens[i + 1], out double mx) &&
                                TryParseDouble(tokens[i + 2], out double my))
                            {
                                if (token == "m") // relative
                                {
                                    currentX += mx;
                                    currentY += my;
                                }
                                else // absolute
                                {
                                    currentX = mx;
                                    currentY = my;
                                }
                                startX = currentX;
                                startY = currentY;
                                points.Add(new ODVec2(currentX, currentY));
                                i += 2;
                                hasValidData = true;
                            }
                            break;
                        case "L": // Line To
                            if (i + 2 < tokens.Count &&
                                TryParseDouble(tokens[i + 1], out double lx) &&
                                TryParseDouble(tokens[i + 2], out double ly))
                            {
                                if (token == "l") // relative
                                {
                                    currentX += lx;
                                    currentY += ly;
                                }
                                else // absolute
                                {
                                    currentX = lx;
                                    currentY = ly;
                                }
                                points.Add(new ODVec2(currentX, currentY));
                                i += 2;
                                hasValidData = true;
                            }
                            break;
                        case "H": // Horizontal Line To
                            if (i + 1 < tokens.Count &&
                                TryParseDouble(tokens[i + 1], out double hx))
                            {
                                if (token == "h") // relative
                                {
                                    currentX += hx;
                                }
                                else // absolute
                                {
                                    currentX = hx;
                                }
                                points.Add(new ODVec2(currentX, currentY));
                                i += 1;
                                hasValidData = true;
                            }
                            break;
                        case "V": // Vertical Line To
                            if (i + 1 < tokens.Count &&
                                TryParseDouble(tokens[i + 1], out double vy))
                            {
                                if (token == "v") // relative
                                {
                                    currentY += vy;
                                }
                                else // absolute
                                {
                                    currentY = vy;
                                }
                                points.Add(new ODVec2(currentX, currentY));
                                i += 1;
                                hasValidData = true;
                            }
                            break;
                        case "Z": // Close Path
                            if (points.Count > 0)
                            {
                                // Close the path by returning to start point
                                points.Add(new ODVec2(startX, startY));
                                hasValidData = true;
                            }
                            break;
                        default:
                            // Skip unknown commands and their parameters
                            if (IsCommandToken(token))
                            {
                                // Skip the command and its parameters
                                i += GetParameterCountForCommand(token);
                            }
                            break;
                    }
                }
                if (hasValidData && points.Count > 1)
                {
                    return new ODPolyline(points);
                }
            }
            catch (Exception ex)
            {
                Debug.WriteLine($"Error parsing path data: {ex.Message}");
                Debug.WriteLine($"Path data: {pathData}");
            }
            return null;
        }
        private List<string> TokenizePathData(string pathData)
        {
            var tokens = new List<string>();
            if (string.IsNullOrEmpty(pathData)) return tokens;
            var currentToken = new StringBuilder();
            bool inNumber = false;
            foreach (char c in pathData)
            {
                if (char.IsWhiteSpace(c) || c == ',')
                {
                    if (currentToken.Length > 0)
                    {
                        tokens.Add(currentToken.ToString());
                        currentToken.Clear();
                    }
                    inNumber = false;
                }
                else if (char.IsLetter(c) && c != '.' && c != '-')
                {
                    if (currentToken.Length > 0)
                    {
                        tokens.Add(currentToken.ToString());
                        currentToken.Clear();
                    }
                    currentToken.Append(c);
                    tokens.Add(currentToken.ToString());
                    currentToken.Clear();
                    inNumber = false;
                }
                else if (c == '-' && inNumber)
                {
                    // Negative sign in the middle of tokens indicates a new number
                    if (currentToken.Length > 0)
                    {
                        tokens.Add(currentToken.ToString());
                        currentToken.Clear();
                    }
                    currentToken.Append(c);
                    inNumber = true;
                }
                else
                {
                    // Number or decimal point or negative sign at start
                    currentToken.Append(c);
                    inNumber = true;
                }
            }
            // Add the last token
            if (currentToken.Length > 0)
            {
                tokens.Add(currentToken.ToString());
            }
            return tokens;
        }
        private bool TryParseDouble(string value, out double result)
        {
            // Handle culture-specific formatting
            return double.TryParse(value,
                System.Globalization.NumberStyles.Float,
                System.Globalization.CultureInfo.InvariantCulture,
                out result);
        }
        private bool IsCommandToken(string token)
        {
            if (string.IsNullOrEmpty(token)) return false;
            char firstChar = token[0];
            return "MLHVCSQTAZ".Contains(char.ToUpper(firstChar));
        }
        private int GetParameterCountForCommand(string command)
        {
            if (string.IsNullOrEmpty(command)) return 0;
            return char.ToUpper(command[0]) switch
            {
                'M' or 'L' or 'T' => 2,  // Move, Line, Smooth Quadratic
                'H' or 'V' => 1,         // Horizontal, Vertical
                'S' or 'Q' => 4,         // Smooth Curve, Quadratic
                'C' => 6,                // Curve
                'A' => 7,                // Arc
                'Z' => 0,                // Close path
                _ => 0
            };
        }
        #endregion
        #region Enhanced Style Parsing
        private ODSvgStyle ParseStyle(XElement element, string? layerId = null, ODSvgStyle? parentStyle = null)
        {
            var style = parentStyle ?? new ODSvgStyle();
            // Apply layer style if layer ID is provided
            if (layerId != null && _layers.TryGetValue(layerId, out var layer))
            {
                style.StrokeColor = layer.Color;
                style.StrokeWidth = layer.LineWeight;
                style.LineType = layer.LineType;
                style.LayerName = layer.Name;
                style.IsVisible = layer.Visible;
                style.IsLocked = layer.Locked;
            }
            // Parse element-specific style attributes
            var styleAttr = element.Attribute("style")?.Value;
            if (!string.IsNullOrEmpty(styleAttr))
            {
                var styleParts = styleAttr.Split(';');
                foreach (var part in styleParts)
                {
                    var keyValue = part.Split(':');
                    if (keyValue.Length == 2)
                    {
                        var key = keyValue[0].Trim();
                        var value = keyValue[1].Trim();
                        switch (key)
                        {
                            case "stroke":
                                style.StrokeColor = ParseColor(value);
                                break;
                            case "stroke-width":
                                if (ParseDouble(value) is double strokeWidth)
                                    style.StrokeWidth = strokeWidth;
                                break;
                            case "stroke-dasharray":
                                style.LineType = ParseLineType(value);
                                break;
                            case "fill":
                                style.FillColor = ParseColor(value);
                                break;
                        }
                    }
                }
            }
            // Parse individual attributes (override style attribute)
            var strokeAttr = element.Attribute("stroke")?.Value;
            if (!string.IsNullOrEmpty(strokeAttr))
                style.StrokeColor = ParseColor(strokeAttr);
            var strokeWidthAttr = element.Attribute("stroke-width")?.Value;
            if (!string.IsNullOrEmpty(strokeWidthAttr) && ParseDouble(strokeWidthAttr) is double sw)
                style.StrokeWidth = sw;
            var fillAttr = element.Attribute("fill")?.Value;
            if (!string.IsNullOrEmpty(fillAttr))
                style.FillColor = ParseColor(fillAttr);
            return style;
        }
        private void ApplyCADMetadata(ODElement element, XElement xmlElement)
        {
            // Extract CAD-specific attributes
            var cadType = xmlElement.Attribute(_cadNs + "type")?.Value;
            var cadLayer = xmlElement.Attribute(_cadNs + "layer-id")?.Value;
            var isBlockRef = xmlElement.Attribute(_cadNs + "blockref")?.Value == "true";
            // Store CAD metadata in your element
            // This depends on your ODElement implementation
            // You might want to add CADMetadata property to ODElement
        }
        #endregion
        #region Utility Methods (Original + Enhanced)
        private DateTime? ParseDateTime(string value)
        {
            if (string.IsNullOrEmpty(value)) return null;
            return DateTime.TryParse(value, System.Globalization.CultureInfo.InvariantCulture,
                System.Globalization.DateTimeStyles.None, out DateTime result) ? result : null;
        }
        private ODColour ParseColor(string colorValue)
        {
            if (string.IsNullOrEmpty(colorValue) || colorValue == "none")
                return ODColour.Transparent;
            // Handle rgb() format
            if (colorValue.StartsWith("rgb("))
            {
                var parts = colorValue.Substring(4, colorValue.Length - 5).Split(',');
                if (parts.Length == 3 &&
                    byte.TryParse(parts[0], out byte r) &&
                    byte.TryParse(parts[1], out byte g) &&
                    byte.TryParse(parts[2], out byte b))
                {
                    return new ODColour(r, g, b);
                }
            }
            // Handle hex colors
            if (colorValue.StartsWith("#"))
            {
                try
                {
                    return new ODColour(colorValue);
                }
                catch
                {
                    // Fall through to named colors
                }
            }
            // Handle named colors
            return colorValue.ToLower() switch
            {
                "black" => ODColour.Black,
                "red" => ODColour.Red,
                "green" => ODColour.Green,
                "blue" => ODColour.Blue,
                "white" => ODColour.White,
                _ => ODColour.Black // Default
            };
        }
        private string ParseLineType(string dashArray)
        {
            if (string.IsNullOrEmpty(dashArray) || dashArray == "none")
                return "Continuous";
            // Simple dash array parsing
            var parts = dashArray.Split(',');
            if (parts.Length >= 2 &&
                ParseDouble(parts[0]) is double dash &&
                ParseDouble(parts[1]) is double gap)
            {
                if (dash == 10 && gap == 5) return "Dashed";
                if (dash == 2 && gap == 5) return "Dotted";
                // Add more patterns as needed
            }
            return "Continuous";
        }
        private double? ParseDouble(string value)
        {
            if (string.IsNullOrEmpty(value)) return null;
            // Remove units if present
            value = value.Trim().ToLower();
            if (value.EndsWith("px")) value = value[..^2];
            else if (value.EndsWith("mm"))
            {
                value = value[..^2];
                if (double.TryParse(value, System.Globalization.NumberStyles.Any,
                    System.Globalization.CultureInfo.InvariantCulture, out double mm))
                    return mm * 3.779527559;
                return null;
            }
            // Add other unit conversions as needed
            if (double.TryParse(value, System.Globalization.NumberStyles.Any,
                System.Globalization.CultureInfo.InvariantCulture, out double result))
                return result;
            return null;
        }
        private double ParseDimension(string value)
        {
            if (string.IsNullOrEmpty(value)) return 0;
            // Remove units and parse
            value = value.Trim().ToLower();
            // Handle common units
            if (value.EndsWith("px")) value = value[..^2];
            else if (value.EndsWith("pt")) value = value[..^2];
            else if (value.EndsWith("mm"))
            {
                value = value[..^2];
                if (double.TryParse(value, System.Globalization.NumberStyles.Any,
                    System.Globalization.CultureInfo.InvariantCulture, out double mm))
                    return mm * 3.779527559; // Convert mm to pixels
            }
            else if (value.EndsWith("cm"))
            {
                value = value[..^2];
                if (double.TryParse(value, System.Globalization.NumberStyles.Any,
                    System.Globalization.CultureInfo.InvariantCulture, out double cm))
                    return cm * 37.795275591; // Convert cm to pixels
            }
            else if (value.EndsWith("in"))
            {
                value = value[..^2];
                if (double.TryParse(value, System.Globalization.NumberStyles.Any,
                    System.Globalization.CultureInfo.InvariantCulture, out double inches))
                    return inches * 96; // Convert inches to pixels
            }
            return double.TryParse(value, System.Globalization.NumberStyles.Any,
                System.Globalization.CultureInfo.InvariantCulture, out double result) ? result : 0;
        }
        private (double Width, double Height)? ParseViewBox(string viewBoxValue)
        {
            if (string.IsNullOrEmpty(viewBoxValue)) return null;
            var parts = viewBoxValue.Split(new[] { ' ', ',' }, StringSplitOptions.RemoveEmptyEntries);
            if (parts.Length >= 4 &&
                double.TryParse(parts[2], System.Globalization.NumberStyles.Any,
                    System.Globalization.CultureInfo.InvariantCulture, out double width) &&
                double.TryParse(parts[3], System.Globalization.NumberStyles.Any,
                    System.Globalization.CultureInfo.InvariantCulture, out double height))
            {
                return (width, height);
            }
            return null;
        }
        #endregion
        #region Properties and Public Methods
        public CADMetadata Metadata => _metadata;
        public IReadOnlyDictionary<string, CADLayer> Layers => _layers;
        public bool IsLoaded => _xDocument != null;
        public ODVec2 GetDimensions()
        {
            if (_xDocument == null)
                throw new InvalidOperationException("No SVG file loaded. Call LoadSvgFile first.");
            var svgElement = _xDocument.Root;
            var width = ParseDimension(svgElement.Attribute("width")?.Value);
            var height = ParseDimension(svgElement.Attribute("height")?.Value);
            // Fallback to viewBox if dimensions aren't found
            if (width == 0 || height == 0)
            {
                var viewBox = ParseViewBox(svgElement.Attribute("viewBox")?.Value);
                if (viewBox.HasValue)
                {
                    width = width == 0 ? viewBox.Value.Width : width;
                    height = height == 0 ? viewBox.Value.Height : height;
                }
            }
            Debug.WriteLine($"SVG Dimensions: Width={width}, Height={height}");
            return new ODVec2(width, height);
        }
        public void Unload()
        {
            _xDocument = null;
            _filePath = null;
            _layers.Clear();
            _blockDefinitions.Clear();
            _metadata = new CADMetadata();
        }
        #endregion
    }
    public class CADMetadata
    {
        public string? AppVersion { get; set; }
        public string? FileVersion { get; set; }
        public string? Units { get; set; }
        public double Precision { get; set; }
        public string? Application { get; set; }
        public string? Version { get; set; }
        public DateTime? Created { get; set; }
        public DateTime? Modified { get; set; }
        public string? Title { get; set; }
        public string? Creator { get; set; }
        public string? Description { get; set; }
        public Dictionary<string, string>? Properties { get; set; }
    }
}

** ODXsvgReader.cs **
Path: D:\OpenDraft\OpenDraft\XSVG\ODXsvgReader.cs

ï»¿using OpenDraft.ODCore.ODGeometry;
using System;
using System.Collections.Generic;
using System.Diagnostics;
using System.IO;
using System.IO.Compression;
using System.Linq;
namespace OpenDraft.XSVG
{
    internal class ODXsvgReader
    {
        private static readonly List<string> _tempDirectories = new List<string>();
        private readonly string _filePath;
        private readonly string _tempPath;
        private bool _isValid = false;
        public static void CleanupAllTempFiles()
        {
            Debug.WriteLine($"Cleaning up {_tempDirectories.Count} temporary directories...");
            foreach (string dir in _tempDirectories.ToList())
            {
                try
                {
                    if (Directory.Exists(dir))
                    {
                        Directory.Delete(dir, true);
                        Debug.WriteLine($"Cleaned up temp directory: {dir}");
                    }
                    _tempDirectories.Remove(dir);
                }
                catch (Exception ex)
                {
                    Debug.WriteLine($"Failed to delete temp directory {dir}: {ex.Message}");
                }
            }
            Debug.WriteLine("Cleanup completed.");
        }
        public static bool IsValidXSVGFile(string filePath)
        {
            if (string.IsNullOrEmpty(filePath))
                return false;
            if (!File.Exists(filePath))
            {
                Debug.WriteLine($"File does not exist: {filePath}");
                return false;
            }
            try
            {
                FileInfo fileInfo = new FileInfo(filePath);
                if (fileInfo.Length == 0)
                {
                    Debug.WriteLine($"File is empty: {filePath}");
                    return false;
                }
                // Check file signature (first 4 bytes of ZIP file)
                byte[] zipSignature = new byte[] { 0x50, 0x4B, 0x03, 0x04 };
                byte[] fileSignature = new byte[4];
                using (FileStream fs = new FileStream(filePath, FileMode.Open, FileAccess.Read))
                {
                    if (fs.Read(fileSignature, 0, 4) != 4)
                    {
                        Debug.WriteLine($"Cannot read file signature: {filePath}");
                        return false;
                    }
                }
                if (!fileSignature.SequenceEqual(zipSignature))
                {
                    Debug.WriteLine($"File is not a ZIP file (invalid signature): {filePath}");
                    return false;
                }
                return true;
            }
            catch (Exception ex)
            {
                Debug.WriteLine($"File validation failed for {filePath}: {ex.Message}");
                return false;
            }
        }
        public ODXsvgReader(string filePath)
        {
            _filePath = filePath ?? throw new ArgumentNullException(nameof(filePath));
            Debug.WriteLine($"Attempting to open XSVG file: {_filePath}");
            // Step 1: Check if file exists
            if (!File.Exists(_filePath))
            {
                throw new FileNotFoundException($"XSVG file not found: {_filePath}");
            }
            // Step 2: Check file size
            FileInfo fileInfo = new FileInfo(_filePath);
            if (fileInfo.Length == 0)
            {
                throw new InvalidDataException($"XSVG file is empty: {_filePath}");
            }
            // Step 3: Create temp directory
            _tempPath = Path.Combine(Path.GetTempPath(), "OpenDraft2D", Guid.NewGuid().ToString());
            Directory.CreateDirectory(_tempPath);
            _tempDirectories.Add(_tempPath);
            Debug.WriteLine($"Created temp directory: {_tempPath}");
            try
            {
                // Step 4: Extract
                Debug.WriteLine("Extracting ZIP contents...");
                ZipFile.ExtractToDirectory(_filePath, _tempPath);
                // Step 5: Validate XSVG structure
                Debug.WriteLine("Validating XSVG structure...");
                ValidateXSVGStructure();
                _isValid = true;
                Debug.WriteLine($"XSVGReader successfully loaded: {_filePath}");
            }
            catch (Exception ex)
            {
                Debug.WriteLine($"Failed to process XSVG file: {ex.Message}");
                CleanupThisTempDirectory();
                throw new IOException($"Failed to read XSVG file '{_filePath}': {ex.Message}", ex);
            }
        }
        public List<ODElement> ExtractModelSpace()
        {
            Debug.WriteLine("Begining parsing of files...");
            ODSvgReader svgR = new ODSvgReader();
            svgR.LoadSvgFile(GetFullPath("mod/ms.svg"));
            return svgR.ImportGeometry();
        }
        private void ValidateXSVGStructure()
        {
            // Check for required XSVG directories and files
            string[] requiredDirs = { "lay", "meta", "mod", "res" };
            string[] requiredFiles = { "manifest.json", "meta/meta.json", "mod/ms.svg" };
            foreach (string dir in requiredDirs)
            {
                string dirPath = Path.Combine(_tempPath, dir);
                if (!Directory.Exists(dirPath))
                {
                    throw new InvalidDataException($"Required directory '{dir}' not found in XSVG file");
                }
            }
            foreach (string file in requiredFiles)
            {
                string filePath = Path.Combine(_tempPath, file);
                if (!File.Exists(filePath))
                {
                    throw new InvalidDataException($"Required file '{file}' not found in XSVG file");
                }
            }
            Debug.WriteLine("XSVG structure validation passed");
        }
        public string TempPath
        {
            get
            {
                if (!_isValid) throw new InvalidOperationException("XSVGReader is not in a valid state");
                return _tempPath;
            }
        }
        public string FilePath => _filePath;
        public bool IsValid => _isValid;
        public string GetFullPath(string relativePath)
        {
            if (!_isValid)
                throw new InvalidOperationException("XSVGReader is not in a valid state");
            string fullPath = Path.Combine(_tempPath, relativePath);
            if (!File.Exists(fullPath) && !Directory.Exists(fullPath))
                throw new FileNotFoundException($"Path '{relativePath}' not found in XSVG file");
            return fullPath;
        }
        public bool PathExists(string relativePath)
        {
            if (!_isValid) return false;
            string fullPath = Path.Combine(_tempPath, relativePath);
            return File.Exists(fullPath) || Directory.Exists(fullPath);
        }
        public string ReadManifest()
        {
            return File.ReadAllText(GetFullPath("manifest.json"));
        }
        public string ReadMetaJson()
        {
            return File.ReadAllText(GetFullPath("meta.json"));
        }
        public string[] GetLayerFiles()
        {
            if (!_isValid) return Array.Empty<string>();
            string layDir = Path.Combine(_tempPath, "lay");
            return Directory.Exists(layDir)
                ? Directory.GetFiles(layDir)
                : Array.Empty<string>();
        }
        public string[] GetResourceFiles()
        {
            if (!_isValid) return Array.Empty<string>();
            string resDir = Path.Combine(_tempPath, "res");
            return Directory.Exists(resDir)
                ? Directory.GetFiles(resDir)
                : Array.Empty<string>();
        }
        public string GetModelSvg()
        {
            return File.ReadAllText(GetFullPath("mod/ms.svg"));
        }
        private void CleanupThisTempDirectory()
        {
            try
            {
                if (!string.IsNullOrEmpty(_tempPath) && Directory.Exists(_tempPath))
                {
                    Directory.Delete(_tempPath, true);
                    _tempDirectories.Remove(_tempPath);
                    Debug.WriteLine($"Cleaned up temp directory: {_tempPath}");
                }
            }
            catch (Exception ex)
            {
                Debug.WriteLine($"Warning: Failed to clean up temp directory {_tempPath}: {ex.Message}");
            }
        }
        // Optional: Method to clean up this specific instance if needed before app closure
        public void Cleanup()
        {
            CleanupThisTempDirectory();
        }
    }
}